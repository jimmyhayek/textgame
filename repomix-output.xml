This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
packages/
  core/
    src/
      content/
        GenericContentLoader.ts
        index.ts
        LoaderRegistry.ts
        types.ts
        utils.ts
      effect/
        EffectManager.ts
        index.ts
        processors.ts
        types.ts
        utils.ts
      engine/
        GameEngine.ts
        index.ts
        types.ts
        utils.ts
      error/
        EngineError.ts
        Errors.ts
        index.ts
        types.ts
      event/
        EventEmitter.ts
        index.ts
        TypedEventEmitter.ts
        types.ts
        utils.ts
      logger/
        index.ts
        Logger.ts
        LogLevel.ts
      plugin/
        AbstractPlugin.ts
        index.ts
        PluginManager.ts
        types.ts
        utils.ts
      save/
        index.ts
        MemoryStorage.ts
        SaveManager.ts
        types.ts
        utils.ts
      scene/
        index.ts
        SceneManager.ts
        types.ts
        utils.ts
      state/
        persistence/
          index.ts
          StateConverter.ts
          StateMigrationService.ts
          types.ts
          utils.ts
        GameStateManager.ts
        index.ts
        types.ts
        utils.ts
      utils/
        immer.ts
        index.ts
        object.ts
        uuid.ts
      index.ts
    .prettierignore
    .prettierrc.js
    eslint.config.mjs
    jest.config.js
    LICENSE
    package.json
    rollup.config.js
    tsconfig.json
  plugin-choices/
    src/
      ChoicesPlugins.ts
      index.ts
      types.ts
    package.json
    README.md
    rollup.config.js
    tsconfig.json
  plugin-commands/
    src/
      CommandPlugin.ts
      index.ts
      types.ts
    package.json
    rollup.config.js
    tsconfig.json
  plugin-local-storage/
    src/
      index.ts
      LocalStorageSaveStorage.ts
    jest.config.js
    package.json
    rollup.config.js
    tsconfig.json
.gitignore
lerna.json
package.json
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="packages/core/src/error/EngineError.ts">
/**
 * Base class for all framework-specific errors.
 * Allows adding optional context data and helps distinguish framework errors
 * from generic JavaScript errors.
 */
export class EngineError extends Error {
    /** Optional additional data related to the error context. */
    public readonly context?: any;
    /** Timestamp (in milliseconds) when the error was created. */
    public readonly timestamp: number;

    /**
     * Creates an instance of EngineError.
     * @param message The primary error message.
     * @param context Optional additional data providing context about the error.
     * @param options Optional standard Error options, including 'cause' for error chaining.
     */
    constructor(message: string, context?: any, options?: ErrorOptions) {
        // Pass message and options (like 'cause') to the parent Error constructor
        super(message, options);

        // Set the error name to the actual class name for better identification
        this.name = this.constructor.name;

        this.context = context;
        this.timestamp = Date.now();

        // Improve stack trace readability in V8 environments (Node.js, Chrome)
        // This removes the constructor call from the stack trace.
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
}
</file>

<file path="packages/core/src/error/Errors.ts">
import { EngineError } from './EngineError';
import type { SceneKey } from '../scene';
import type { EffectType } from '../effect';

/**
 * Represents an error related to scene loading, transitions, or lifecycle events.
 */
export class SceneError extends EngineError {
    /** The key of the scene related to the error, if applicable. */
    public readonly sceneKey?: SceneKey;

    /**
     * Creates an instance of SceneError.
     * @param message The error message.
     * @param sceneKey The key of the relevant scene.
     * @param context Optional additional context.
     * @param options Optional standard Error options.
     */
    constructor(message: string, sceneKey?: SceneKey, context?: any, options?: ErrorOptions) {
        super(message, context, options);
        this.sceneKey = sceneKey;
    }
}

/**
 * Represents an error related to content loading, registration, or access.
 */
export class ContentError extends EngineError {
    /** The key of the content item related to the error, if applicable. */
    public readonly contentKey?: string;
    /** The type identifier (e.g., 'scenes', 'items') of the content related to the error, if applicable. */
    public readonly contentType?: string;

    /**
     * Creates an instance of ContentError.
     * @param message The error message.
     * @param contentKey The key of the relevant content item.
     * @param contentType The type identifier of the relevant content.
     * @param context Optional additional context.
     * @param options Optional standard Error options.
     */
    constructor(message: string, contentKey?: string, contentType?: string, context?: any, options?: ErrorOptions) {
        super(message, context, options);
        this.contentKey = contentKey;
        this.contentType = contentType;
    }
}

/**
 * Represents an error related to effect processing, application, or definition.
 */
export class EffectError extends EngineError {
    /** The type identifier of the effect related to the error, if applicable. */
    public readonly effectType?: EffectType; // Use EffectType from effect/types

    /**
     * Creates an instance of EffectError.
     * @param message The error message.
     * @param effectType The type identifier of the relevant effect.
     * @param context Optional additional context.
     * @param options Optional standard Error options.
     */
    constructor(message: string, effectType?: EffectType, context?: any, options?: ErrorOptions) {
        super(message, context, options);
        this.effectType = effectType;
    }
}

/**
 * Represents an error related to plugin initialization, execution, registration, or lifecycle.
 */
export class PluginError extends EngineError {
    /** The name of the plugin related to the error, if applicable. */
    public readonly pluginName?: string;
    /** The phase during which the error occurred (e.g., 'initialize', 'destroy'). */
    public readonly phase?: string;

    /**
     * Creates an instance of PluginError.
     * @param message The error message.
     * @param pluginName The name of the relevant plugin.
     * @param phase The lifecycle phase where the error occurred.
     * @param context Optional additional context.
     * @param options Optional standard Error options.
     */
    constructor(message: string, pluginName?: string, phase?: string, context?: any, options?: ErrorOptions) {
        super(message, context, options);
        this.pluginName = pluginName;
        this.phase = phase;
    }
}

/**
 * Represents an error related to saving, loading, deleting, or managing game saves.
 */
export class SaveError extends EngineError {
    /** The ID of the save slot related to the error, if applicable. */
    public readonly saveId?: string;

    /**
     * Creates an instance of SaveError.
     * @param message The error message.
     * @param saveId The ID of the relevant save slot.
     * @param context Optional additional context.
     * @param options Optional standard Error options.
     */
    constructor(message: string, saveId?: string, context?: any, options?: ErrorOptions) {
        super(message, context, options);
        this.saveId = saveId;
    }
}

/**
 * Represents an error related to game state management, validation, persistence, or structure.
 */
export class StateError extends EngineError {
    /** Describes the specific context within state management where the error occurred (e.g., 'validation', 'serialization'). */
    public readonly stateContext?: string;

    /**
     * Creates an instance of StateError.
     * @param message The error message.
     * @param stateContext The context within state operations.
     * @param context Optional additional context.
     * @param options Optional standard Error options.
     */
    constructor(message: string, stateContext?: string, context?: any, options?: ErrorOptions) {
        super(message, context, options);
        this.stateContext = stateContext;
    }
}

/**
 * Represents an error specifically related to state format migration issues.
 * Inherits from StateError.
 */
export class MigrationError extends StateError {
    /** The state format version the migration started from, if known. */
    public readonly fromVersion?: number;
    /** The target state format version the migration was attempting to reach, if known. */
    public readonly toVersion?: number;

    /**
     * Creates an instance of MigrationError.
     * @param message The error message.
     * @param fromVersion The source format version.
     * @param toVersion The target format version.
     * @param context Optional additional context.
     * @param options Optional standard Error options.
     */
    constructor(message: string, fromVersion?: number, toVersion?: number, context?: any, options?: ErrorOptions) {
        // Pass 'migration' as the stateContext to the parent StateError constructor
        super(message, 'migration', context, options);
        this.fromVersion = fromVersion;
        this.toVersion = toVersion;
    }
}
</file>

<file path="packages/core/src/error/index.ts">
export { EngineError } from './EngineError';
export * from './Errors';
export * from './types';
</file>

<file path="packages/core/src/error/types.ts">
import type { EngineError } from './EngineError';
import type { SceneError, ContentError, EffectError, PluginError, SaveError, StateError, MigrationError } from './Errors';

/**
 * A type union representing any of the specific framework error classes.
 */
export type FrameworkError = SceneError | ContentError | EffectError | PluginError | SaveError | StateError | MigrationError | EngineError;
</file>

<file path="packages/core/src/logger/index.ts">
/**
 * Exports the Logger class and LogLevel enum for use throughout the framework
 * and by consumers of the framework.
 */
export { Logger } from './Logger';
export { LogLevel } from './LogLevel';
</file>

<file path="packages/core/src/logger/Logger.ts">
import { LogLevel } from './LogLevel';

/**
 * A simple logger class for consistent logging across the framework.
 * Allows setting a log level to filter messages based on severity.
 *
 * By default, only messages with level Warn or Error are logged unless
 * explicitly configured otherwise.
 */
export class Logger {
    private currentLevel: LogLevel;
    private readonly prefix: string;

    /**
     * Creates a new Logger instance.
     * @param initialLevel The minimum level of messages to log.
     *                     Defaults to `LogLevel.Warn` for safer production behavior.
     * @param prefix An optional prefix string added to the beginning of each log message.
     *               Defaults to '[Pabitel]'.
     */
    constructor(initialLevel: LogLevel = LogLevel.Warn, prefix: string = '[Pabitel]') {
        this.currentLevel = initialLevel;
        // Ensure prefix ends with a space if it's not empty
        this.prefix = prefix ? `${prefix} ` : '';
    }

    /**
     * Sets the minimum log level. Messages with severity lower than this level
     * (i.e., higher numeric value) will be ignored.
     * @param level The new minimum `LogLevel` to display.
     */
    public setLevel(level: LogLevel): void {
        this.currentLevel = level;
    }

    /**
     * Gets the current minimum log level.
     * @returns The current `LogLevel`.
     */
    public getLevel(): LogLevel {
        return this.currentLevel;
    }

    /**
     * Logs a debug message if the current log level allows it (`Debug`).
     * Output is sent to `console.debug`.
     * Use for detailed diagnostic information during development.
     *
     * @param message The primary message or first argument to log.
     * @param optionalParams Additional arguments to log (similar to `console.debug`).
     */
    public debug(message?: any, ...optionalParams: any[]): void {
        if (this.currentLevel >= LogLevel.Debug) {
            // Using console.debug for semantic correctness, though often styled like log.
            console.debug(`${this.prefix}[DBG]`, message, ...optionalParams);
        }
    }

    /**
     * Logs an informational message if the current log level allows it (`Info` or higher).
     * Output is sent to `console.info`.
     * Use for general information about application flow or state.
     *
     * @param message The primary message or first argument to log.
     * @param optionalParams Additional arguments to log (similar to `console.info`).
     */
    public info(message?: any, ...optionalParams: any[]): void {
        if (this.currentLevel >= LogLevel.Info) {
            // Using console.info for semantic correctness, though often styled like log.
            console.info(`${this.prefix}[INF]`, message, ...optionalParams);
        }
    }

    /**
     * Logs a warning message if the current log level allows it (`Warn` or higher).
     * Output is sent to `console.warn`.
     * Use for indicating potential issues or non-ideal situations that don't halt execution.
     *
     * @param message The primary message or first argument to log.
     * @param optionalParams Additional arguments to log (similar to `console.warn`).
     */
    public warn(message?: any, ...optionalParams: any[]): void {
        if (this.currentLevel >= LogLevel.Warn) {
            console.warn(`${this.prefix}[WRN]`, message, ...optionalParams);
        }
    }

    /**
     * Logs an error message if the current log level allows it (`Error` or higher).
     * Output is sent to `console.error`.
     * Use for reporting errors, exceptions, or failures.
     *
     * @param message The primary message or first argument (often an Error object).
     * @param optionalParams Additional arguments to log (similar to `console.error`).
     */
    public error(message?: any, ...optionalParams: any[]): void {
        // Errors should generally always be logged unless level is explicitly None.
        if (this.currentLevel >= LogLevel.Error) {
            console.error(`${this.prefix}[ERR]`, message, ...optionalParams);
        }
    }
}
</file>

<file path="packages/core/src/logger/LogLevel.ts">
/**
 * Defines the available logging levels, ordered by severity.
 * Lower number means higher priority (Error is 0, Debug is 3).
 * Use `LogLevel.None` to disable all logging output.
 */
export enum LogLevel {
    /** For critical errors that might prevent the application from continuing. */
    Error = 0,
    /** For potential issues or non-critical problems that don't stop execution. */
    Warn = 1,
    /** For general informational messages about the application's progress or state. */
    Info = 2,
    /** For detailed diagnostic information useful during development and debugging. */
    Debug = 3,
    /** Special level to disable all logging output. */
    None = 99,
}
</file>

<file path="packages/core/.prettierignore">
node_modules
dist
coverage
*.md
*.json
</file>

<file path="packages/core/.prettierrc.js">
module.exports = {
  singleQuote: true,
  trailingComma: 'es5',
  printWidth: 100,
  tabWidth: 2,
  semi: true,
  bracketSpacing: true,
  arrowParens: 'avoid',
  endOfLine: 'lf',
};
</file>

<file path="packages/core/eslint.config.mjs">
// eslint.config.mjs
import eslintJs from '@eslint/js';
import tseslint from '@typescript-eslint/eslint-plugin';
import tsparser from '@typescript-eslint/parser';
import prettierPlugin from 'eslint-plugin-prettier';

export default [
  eslintJs.configs.recommended,
  {
    ignores: [
      'node_modules/**',
      'dist/**',
      'coverage/**',
      'rollup.config.js',
      'jest.config.js'
    ]
  },
  {
    files: ['**/*.ts'],
    languageOptions: {
      parser: tsparser,
      ecmaVersion: 2020,
      sourceType: 'module',
      globals: {
        // Přidáno pro vyřešení 'console is not defined'
        console: 'readonly',
        // Další globální proměnné, které mohou být potřeba
        process: 'readonly',
        setTimeout: 'readonly',
        clearTimeout: 'readonly',
        Set: 'readonly',
        Map: 'readonly',
        Promise: 'readonly'
      }
    },
    plugins: {
      '@typescript-eslint': tseslint,
      'prettier': prettierPlugin
    },
    rules: {
      'prettier/prettier': 'error',
      'no-console': ['warn', { allow: ['warn', 'error'] }],
      'no-unused-vars': 'off'
    }
  }
];
</file>

<file path="packages/core/LICENSE">
MIT License

Copyright (c) 2025 Jakub Hájek

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="packages/plugin-choices/src/ChoicesPlugins.ts">
import { AbstractPlugin, GameState, Scene, SceneKey } from '@pabitel/core';
import {
    Choice,
    ChoicesPluginOptions,
    ChoiceSelectedEventData,
    AvailableChoicesEventData,
    ChoicesPluginEvents
} from './types';

/**
 * Plugin poskytující funkcionalitu pro volby (choices) ve scénách
 */
export class ChoicesPlugin extends AbstractPlugin<ChoicesPluginOptions> {
    /**
     * Vytvoří novou instanci ChoicesPluginu
     *
     * @param options Možnosti konfigurace pluginu
     */
    constructor(options: ChoicesPluginOptions = {}) {
        super('choices', {
            emitAvailableChoicesOnSceneChange: true,
            enableShortcuts: true,
            ...options
        });
    }

    /**
     * Inicializace pluginu
     */
    protected override async onInitialize(): Promise<void> {
        // Naslouchání na změnu scény
        if (this.options.emitAvailableChoicesOnSceneChange) {
            this.registerEventListener('sceneChanged', () => {
                this.emitAvailableChoices();
            });
        }
    }

    /**
     * Vrátí všechny dostupné volby pro aktuální scénu
     *
     * @returns Pole dostupných voleb
     */
    public getAvailableChoices(): Choice[] {
        if (!this.engine) return [];

        const currentScene = this.engine.getCurrentScene() as Scene;
        if (!currentScene || !currentScene.choices) return [];

        const state = this.engine.getState();

        return currentScene.choices.filter(choice => {
            if (!choice.condition) return true;
            return choice.condition(state);
        });
    }

    /**
     * Emituje událost s dostupnými volbami
     */
    public emitAvailableChoices(): void {
        if (!this.engine) return;

        const choices = this.getAvailableChoices();
        const sceneKey = this.engine.getCurrentSceneKey();

        if (!sceneKey) return;

        const eventData: AvailableChoicesEventData = {
            choices,
            sceneKey
        };

        this.emitNamespacedEvent(ChoicesPluginEvents.AVAILABLE_CHOICES, eventData);
    }

    /**
     * Vybere volbu podle indexu
     *
     * @param index Index volby k výběru
     * @returns Promise, který se vyřeší na true, pokud byla volba úspěšně zpracována
     */
    public async selectChoice(index: number): Promise<boolean> {
        if (!this.engine) return false;

        const choices = this.getAvailableChoices();
        if (index < 0 || index >= choices.length) {
            console.warn(`Choice with index ${index} not found.`);
            return false;
        }

        const choice = choices[index];

        // Emituje událost o vybrané volbě
        const eventData: ChoiceSelectedEventData = {
            choice,
            index
        };

        this.emitNamespacedEvent(ChoicesPluginEvents.CHOICE_SELECTED, eventData);

        // Zpracování volby
        return await this.processChoice(choice);
    }

    /**
     * Vybere volbu podle klávesové zkratky
     *
     * @param shortcut Klávesová zkratka volby
     * @returns Promise, který se vyřeší na true, pokud byla volba úspěšně zpracována
     */
    public async selectChoiceByShortcut(shortcut: string): Promise<boolean> {
        if (!this.engine || !this.options.enableShortcuts) return false;

        const choices = this.getAvailableChoices();
        const index = choices.findIndex(choice => choice.shortcut === shortcut);

        if (index === -1) {
            return false;
        }

        return await this.selectChoice(index);
    }

    /**
     * Zpracuje volbu - aplikuje efekty, zobrazí odpověď a přejde na další scénu
     *
     * @param choice Volba ke zpracování
     * @returns Promise, který se vyřeší na true, pokud byla volba úspěšně zpracována
     * @private
     */
    private async processChoice(choice: Choice): Promise<boolean> {
        if (!this.engine) return false;

        const state = this.engine.getState();

        // Zpracování textové odpovědi
        if (choice.response) {
            const response = typeof choice.response === 'function'
                ? choice.response(state)
                : choice.response;

            this.emitNamespacedEvent(ChoicesPluginEvents.CHOICE_RESPONSE, { response });
        }

        // Aplikace efektů
        if (choice.effects && choice.effects.length > 0) {
            this.applyEffects(choice.effects);
        }

        // Přechod na další scénu
        if (choice.scene) {
            const nextSceneKey = typeof choice.scene === 'function'
                ? choice.scene(this.engine.getState())
                : choice.scene;

            const success = await this.transitionToScene(nextSceneKey);

            // Emitujeme události o dokončení zpracování volby
            this.emitNamespacedEvent(ChoicesPluginEvents.CHOICE_PROCESSED, { choice, success });

            return success;
        }

        // Pokud volba nemá scénu, považujeme zpracování za úspěšné
        this.emitNamespacedEvent(ChoicesPluginEvents.CHOICE_PROCESSED, { choice, success: true });

        return true;
    }

    /**
     * Získá text volby, vyhodnotí dynamické labely
     *
     * @param choice Volba k získání textu
     * @returns Text volby
     */
    public getChoiceLabel(choice: Choice): string {
        if (!this.engine) return '';

        if (typeof choice.label === 'function') {
            return choice.label(this.engine.getState());
        }

        return choice.label;
    }

    /**
     * Vrátí, zda je volba dostupná podle její podmínky
     *
     * @param choice Volba ke kontrole
     * @returns True, pokud je volba dostupná
     */
    public isChoiceAvailable(choice: Choice): boolean {
        if (!this.engine) return false;

        if (!choice.condition) return true;

        return choice.condition(this.engine.getState());
    }
}
</file>

<file path="packages/plugin-choices/src/index.ts">
export * from './ChoicesPlugin';
export * from './types';
</file>

<file path="packages/plugin-choices/src/types.ts">
import { GameState, SceneKey, Effect } from '@pabitel/core';

/**
 * Reprezentuje volbu v rámci scény
 */
export interface Choice {
    /**
     * Text volby zobrazený v UI
     */
    label: string | ((state: GameState) => string);

    /**
     * Volitelná klávesová zkratka pro rychlý výběr volby
     */
    shortcut?: string;

    /**
     * Volitelný klíč scény, na kterou se přejde po výběru této volby
     */
    scene?: SceneKey | ((state: GameState) => SceneKey);

    /**
     * Volitelná podmínka, která určuje, zda je volba dostupná
     */
    condition?: (state: GameState) => boolean;

    /**
     * Efekty, které se aplikují na stav hry po výběru této volby
     */
    effects?: Effect[];

    /**
     * Textová odpověď po výběru volby
     */
    response?: string | ((state: GameState) => string);

    /**
     * Další metadata pro rozšíření funkcionality
     */
    metadata?: Record<string, any>;
}

/**
 * Konfigurace pro ChoicesPlugin
 */
export interface ChoicesPluginOptions {
    /**
     * Zda automaticky emitovat událost o nových dostupných volbách při změně scény
     * Výchozí: true
     */
    emitAvailableChoicesOnSceneChange?: boolean;

    /**
     * Zda povolit klávesové zkratky pro volby
     * Výchozí: true
     */
    enableShortcuts?: boolean;
}

/**
 * Data události o vybrané volbě
 */
export interface ChoiceSelectedEventData {
    /**
     * Vybraná volba
     */
    choice: Choice;

    /**
     * Index vybrané volby
     */
    index: number;
}

/**
 * Data události o dostupných volbách
 */
export interface AvailableChoicesEventData {
    /**
     * Dostupné volby
     */
    choices: Choice[];

    /**
     * Aktuální scéna
     */
    sceneKey: SceneKey;
}

/**
 * Typy událostí emitovaných ChoicesPluginem
 */
export enum ChoicesPluginEvents {
    CHOICE_SELECTED = 'choices:choiceSelected',
    CHOICE_PROCESSED = 'choices:choiceProcessed',
    AVAILABLE_CHOICES = 'choices:availableChoices',
    CHOICE_RESPONSE = 'choices:choiceResponse'
}

/**
 * Rozšíření Scene interface o choices
 */
declare module '@pabitel/core' {
    interface Scene {
        /**
         * Dostupné volby v této scéně
         */
        choices?: Choice[];
    }
}
</file>

<file path="packages/plugin-choices/package.json">
{
  "name": "@pabitel/plugin-choices",
  "version": "0.1.0",
  "description": "Choices plugin for Pabitel.js",
  "license": "MIT",
  "main": "dist/index.js",
  "module": "dist/index.esm.js",
  "types": "dist/index.d.ts",
  "files": [
    "dist"
  ],
  "exports": {
    ".": {
      "import": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.esm.js"
      },
      "require": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.js"
      },
      "development": "./src/index.ts"
    },
    "./package.json": "./package.json"
  },
  "scripts": {
    "build": "tsc && rollup -c",
    "dev": "tsc --watch",
    "test": "jest",
    "lint": "eslint src --ext .ts",
    "lint:fix": "eslint src --ext .ts --fix",
    "format": "prettier --write \"src/**/*.ts\"",
    "format:check": "prettier --check \"src/**/*.ts\"",
    "prepublishOnly": "yarn lint && yarn test && yarn build"
  },
  "peerDependencies": {
    "@pabitel/core": "^0.1.0"
  },
  "devDependencies": {
    "@pabitel/core": "^0.1.0",
    "@rollup/plugin-commonjs": "^28.0.3",
    "@rollup/plugin-node-resolve": "^16.0.1",
    "@types/jest": "^29.5.14",
    "eslint": "^9",
    "jest": "^29.7.0",
    "prettier": "^3",
    "rollup": "^4",
    "rollup-plugin-typescript2": "^0.36.0",
    "ts-jest": "^29.3.1",
    "typescript": "^5.8.2"
  },
  "keywords": [
    "pabitel",
    "choices",
    "text-adventure",
    "plugin",
    "interactive-fiction"
  ],
  "author": "Jakub Hájek",
  "repository": {
    "type": "git",
    "url": "https://github.com/jimmyhayek/textgame.git"
  }
}
</file>

<file path="packages/plugin-choices/README.md">
# @pabitel/plugin-choices

Plugin pro podporu voleb (choices) v Pabitel.js textovém herním enginu.

## Přehled

Plugin choices implementuje tradiční mechanismus výběru voleb v textových hrách. Umožňuje definovat explicitní volby ve scénách a poskytuje API pro jejich zpracování.

## Instalace

```bash
# Pomocí yarn
yarn add @pabitel/plugin-choices

# Pomocí npm
npm install @pabitel/plugin-choices
```

## Použití

### Základní použití

```typescript
import { createGameEngine, defineScene, defineScenes, createSceneLoader } from '@pabitel/core';
import { ChoicesPlugin, Choice } from '@pabitel/plugin-choices';

// Vytvoření enginu
const engine = createGameEngine({
  sceneLoader: /* ... */,
  initialState: { /* ... */ }
});

// Registrace pluginu
const choicesPlugin = new ChoicesPlugin();
engine.registerPlugin(choicesPlugin);

// Definice scén s volbami
const forestScene = defineScene({
  title: 'Les',
  content: 'Jsi v lese plném vysokých stromů.',
  choices: [
    {
      label: 'Jít na sever',
      scene: 'forest/north'
    },
    {
      label: 'Prohledat okolí',
      effects: [{ type: 'SET_VARIABLE', variable: 'foundMap', value: true }],
      response: 'Našel jsi starou mapu!'
    },
    {
      label: 'Vrátit se zpět',
      scene: 'village',
      condition: (state) => state.variables.hasItem === true
    }
  ]
});

// Spuštění hry
await engine.start('forest');

// Získání dostupných voleb
const choices = choicesPlugin.getAvailableChoices();
console.log(choices.map(choice => choicesPlugin.getChoiceLabel(choice)));

// Výběr volby podle indexu
await choicesPlugin.selectChoice(0);
```

### Naslouchání událostem

Plugin emituje několik událostí, které můžete využít k interakci s UI:

```typescript
// Naslouchání na dostupné volby
engine.on('choices:availableChoices', (data) => {
  console.log('Dostupné volby:', data.choices);
  renderChoices(data.choices);
});

// Naslouchání na vybranou volbu
engine.on('choices:choiceSelected', (data) => {
  console.log('Vybrána volba:', data.choice, 'index:', data.index);
});

// Naslouchání na odpověď po výběru volby
engine.on('choices:choiceResponse', (data) => {
  console.log('Odpověď:', data.response);
  showResponse(data.response);
});
```

### Klávesové zkratky

Plugin podporuje klávesové zkratky pro volby:

```typescript
// Definice volby s klávesovou zkratkou
const choices = [
  {
    label: 'Jít na sever (N)',
    scene: 'north',
    shortcut: 'n'
  },
  {
    label: 'Jít na jih (S)',
    scene: 'south',
    shortcut: 's'
  }
];

// Zpracování klávesové zkratky
document.addEventListener('keydown', (event) => {
  choicesPlugin.selectChoiceByShortcut(event.key.toLowerCase());
});
```

## API

### `ChoicesPlugin`

Hlavní třída pluginu.

#### Konstruktor

```typescript
constructor(options: ChoicesPluginOptions = {})
```

**Parametry:**
- `options` - Nastavení pluginu

#### Metody

- `getAvailableChoices()` - Vrátí dostupné volby pro aktuální scénu
- `selectChoice(index)` - Vybere volbu podle indexu
- `selectChoiceByShortcut(shortcut)` - Vybere volbu podle klávesové zkratky
- `getChoiceLabel(choice)` - Získá textový popisek volby
- `isChoiceAvailable(choice)` - Kontroluje, zda je volba dostupná
- `emitAvailableChoices()` - Vynutí emitování události s dostupnými volbami

### `Choice` Interface

Reprezentuje volbu ve scéně.

```typescript
interface Choice {
  label: string | ((state: GameState) => string);
  shortcut?: string;
  scene?: SceneKey | ((state: GameState) => SceneKey);
  condition?: (state: GameState) => boolean;
  effects?: Effect[];
  response?: string | ((state: GameState) => string);
  metadata?: Record<string, any>;
}
```

### `ChoicesPluginOptions` Interface

Možnosti konfigurace pluginu.

```typescript
interface ChoicesPluginOptions {
  emitAvailableChoicesOnSceneChange?: boolean; // Výchozí: true
  enableShortcuts?: boolean; // Výchozí: true
}
```

### Události

Plugin emituje tyto události:

- `choices:availableChoices` - Když jsou dostupné nové volby
- `choices:choiceSelected` - Když je vybrána volba
- `choices:choiceProcessed` - Když je volba úplně zpracována
- `choices:choiceResponse` - Když volba vrátí textovou odpověď

## Rozšíření typů v Pabitel Core

Plugin rozšiřuje interface `Scene` z `@pabitel/core` o vlastnost `choices`:

```typescript
declare module '@pabitel/core' {
  interface Scene {
    choices?: Choice[];
  }
}
```

## Licence

MIT © Jakub Hájek
</file>

<file path="packages/plugin-choices/rollup.config.js">
import typescript from 'rollup-plugin-typescript2';
import { nodeResolve } from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import pkg from './package.json';

export default [
  {
    input: 'src/index.ts',
    output: {
      file: pkg.module,
      format: 'esm',
      sourcemap: true
    },
    plugins: [
      typescript({
        tsconfig: './tsconfig.json',
        useTsconfigDeclarationDir: true
      }),
      nodeResolve(),
      commonjs()
    ],
    external: [...Object.keys(pkg.dependencies || {}), ...Object.keys(pkg.peerDependencies || {})]
  },
  {
    input: 'src/index.ts',
    output: {
      file: pkg.main,
      format: 'cjs',
      sourcemap: true
    },
    plugins: [
      typescript({
        tsconfig: './tsconfig.json',
        useTsconfigDeclarationDir: true
      }),
      nodeResolve(),
      commonjs()
    ],
    external: [...Object.keys(pkg.dependencies || {}), ...Object.keys(pkg.peerDependencies || {})]
  }
];
</file>

<file path="packages/plugin-choices/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "declaration": true,
    "declarationDir": "./dist",
    "outDir": "./dist",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node"
  },
  "paths": {
    "@pabitel/core": ["../core/src"]
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "test", "examples"]
}
</file>

<file path="packages/plugin-commands/rollup.config.js">
import typescript from 'rollup-plugin-typescript2';
import { nodeResolve } from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import pkg from './package.json';

export default [
  {
    input: 'src/index.ts',
    output: {
      file: pkg.module,
      format: 'esm',
      sourcemap: true
    },
    plugins: [
      typescript({
        tsconfig: './tsconfig.json',
        useTsconfigDeclarationDir: true
      }),
      nodeResolve(),
      commonjs()
    ],
    external: [...Object.keys(pkg.dependencies || {}), ...Object.keys(pkg.peerDependencies || {})]
  },
  {
    input: 'src/index.ts',
    output: {
      file: pkg.main,
      format: 'cjs',
      sourcemap: true
    },
    plugins: [
      typescript({
        tsconfig: './tsconfig.json',
        useTsconfigDeclarationDir: true
      }),
      nodeResolve(),
      commonjs()
    ],
    external: [...Object.keys(pkg.dependencies || {}), ...Object.keys(pkg.peerDependencies || {})]
  }
];
</file>

<file path="packages/plugin-local-storage/src/index.ts">
export * from './LocalStorageSaveStorage';
</file>

<file path="packages/plugin-local-storage/src/LocalStorageSaveStorage.ts">
import { SaveData, SaveMetadata, SaveStorage } from '@pabitel/core';

/**
 * Možnosti pro konfiguraci LocalStorageSaveStorage
 */
export interface LocalStorageSaveStorageOptions {
    /**
     * Prefix pro klíče v localStorage
     * Používá se k oddělení uložených her od ostatních dat
     * Výchozí: 'pabitel_save_'
     */
    prefix?: string;
}

/**
 * Implementace SaveStorage využívající localStorage
 *
 * Tato třída poskytuje implementaci pro ukládání a načítání
 * uložených her s využitím localStorage prohlížeče.
 */
export class LocalStorageSaveStorage implements SaveStorage {
    /**
     * Prefix pro klíče v localStorage
     * Používá se k oddělení uložených her od ostatních dat
     */
    private readonly prefix: string;

    /**
     * Klíč pro metadata o všech uložených hrách
     */
    private readonly metadataKey: string;

    /**
     * Vytvoří novou instanci LocalStorageSaveStorage
     *
     * @param options Možnosti konfigurace
     */
    constructor(options: LocalStorageSaveStorageOptions = {}) {
        this.prefix = options.prefix || 'pabitel_save_';
        this.metadataKey = `${this.prefix}metadata`;
    }

    /**
     * Uloží data do localStorage
     *
     * @param id Identifikátor uložené hry
     * @param data Data k uložení
     * @returns Promise rozhodnutý na true, pokud bylo uložení úspěšné
     */
    public async save(id: string, data: SaveData): Promise<boolean> {
        try {
            // Uložení dat
            localStorage.setItem(this.getKey(id), JSON.stringify(data));

            // Aktualizace metadat
            const metadataMap = await this.getMetadataMap();
            metadataMap[id] = data.metadata;
            localStorage.setItem(this.metadataKey, JSON.stringify(metadataMap));

            return true;
        } catch (error) {
            console.error(`Failed to save game with id '${id}':`, error);
            return false;
        }
    }

    /**
     * Načte data z localStorage
     *
     * @param id Identifikátor uložené hry
     * @returns Promise rozhodnutý na data, nebo null pokud uložená hra neexistuje
     */
    public async load(id: string): Promise<SaveData | null> {
        try {
            const dataStr = localStorage.getItem(this.getKey(id));
            if (!dataStr) {
                return null;
            }

            return JSON.parse(dataStr) as SaveData;
        } catch (error) {
            console.error(`Failed to load game with id '${id}':`, error);
            return null;
        }
    }

    /**
     * Vrátí seznam všech uložených her
     *
     * @returns Promise rozhodnutý na objekt mapující ID na metadata
     */
    public async list(): Promise<Record<string, SaveMetadata>> {
        return await this.getMetadataMap();
    }

    /**
     * Smaže uloženou hru
     *
     * @param id Identifikátor uložené hry
     * @returns Promise rozhodnutý na true, pokud bylo smazání úspěšné
     */
    public async delete(id: string): Promise<boolean> {
        try {
            // Odstranění dat
            localStorage.removeItem(this.getKey(id));

            // Aktualizace metadat
            const metadataMap = await this.getMetadataMap();
            delete metadataMap[id];
            localStorage.setItem(this.metadataKey, JSON.stringify(metadataMap));

            return true;
        } catch (error) {
            console.error(`Failed to delete game with id '${id}':`, error);
            return false;
        }
    }

    /**
     * Zkontroluje, zda existuje uložená hra s daným ID
     *
     * @param id Identifikátor uložené hry
     * @returns Promise rozhodnutý na true, pokud uložená hra existuje
     */
    public async exists(id: string): Promise<boolean> {
        return localStorage.getItem(this.getKey(id)) !== null;
    }

    /**
     * Vrátí kompletní klíč pro localStorage
     *
     * @param id Identifikátor uložené hry
     * @returns Kompletní klíč pro localStorage
     * @private
     */
    private getKey(id: string): string {
        return `${this.prefix}${id}`;
    }

    /**
     * Získá mapu všech metadat
     *
     * @returns Mapa ID na metadata
     * @private
     */
    private async getMetadataMap(): Promise<Record<string, SaveMetadata>> {
        const metadataStr = localStorage.getItem(this.metadataKey);
        if (!metadataStr) {
            return {};
        }

        try {
            return JSON.parse(metadataStr) as Record<string, SaveMetadata>;
        } catch (error) {
            console.error('Failed to parse metadata:', error);
            return {};
        }
    }

    /**
     * Vyčistí všechna uložení s daným prefixem
     *
     * @returns Promise rozhodnutý na true, pokud bylo vyčištění úspěšné
     */
    public async clearAll(): Promise<boolean> {
        try {
            const metadataMap = await this.getMetadataMap();

            // Odstranění všech uložených her
            for (const id of Object.keys(metadataMap)) {
                localStorage.removeItem(this.getKey(id));
            }

            // Odstranění metadat
            localStorage.removeItem(this.metadataKey);

            return true;
        } catch (error) {
            console.error('Failed to clear all saves:', error);
            return false;
        }
    }

    /**
     * Vrátí všechny klíče v localStorage, které mají daný prefix
     *
     * @returns Pole klíčů
     */
    public getAllKeys(): string[] {
        const keys: string[] = [];

        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith(this.prefix)) {
                // Odstranění prefixu z klíče
                keys.push(key.substring(this.prefix.length));
            }
        }

        return keys;
    }

    /**
     * Vrátí celkovou velikost uložených dat v bajtech
     *
     * @returns Velikost v bajtech
     */
    public getTotalSize(): number {
        let totalSize = 0;

        // Velikost metadat
        const metadataStr = localStorage.getItem(this.metadataKey);
        if (metadataStr) {
            totalSize += metadataStr.length * 2; // 2 bajty na znak
        }

        // Velikost jednotlivých uložení
        for (const id of this.getAllKeys()) {
            const saveStr = localStorage.getItem(this.getKey(id));
            if (saveStr) {
                totalSize += saveStr.length * 2; // 2 bajty na znak
            }
        }

        return totalSize;
    }
}
</file>

<file path="packages/plugin-local-storage/jest.config.js">
import typescript from 'rollup-plugin-typescript2';
import { nodeResolve } from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import pkg from './package.json';

export default [
  {
    input: 'src/index.ts',
    output: {
      file: pkg.module,
      format: 'esm',
      sourcemap: true
    },
    plugins: [
      typescript({
        tsconfig: './tsconfig.json',
        useTsconfigDeclarationDir: true
      }),
      nodeResolve(),
      commonjs()
    ],
    external: [...Object.keys(pkg.dependencies || {}), ...Object.keys(pkg.peerDependencies || {})]
  },
  {
    input: 'src/index.ts',
    output: {
      file: pkg.main,
      format: 'cjs',
      sourcemap: true
    },
    plugins: [
      typescript({
        tsconfig: './tsconfig.json',
        useTsconfigDeclarationDir: true
      }),
      nodeResolve(),
      commonjs()
    ],
    external: [...Object.keys(pkg.dependencies || {}), ...Object.keys(pkg.peerDependencies || {})]
  }
];
</file>

<file path="packages/plugin-local-storage/package.json">
{
  "name": "@pabitel/plugin-local-storage",
  "version": "0.1.0",
  "description": "LocalStorage implementation for Pabitel.js",
  "license": "MIT",
  "main": "dist/index.js",
  "module": "dist/index.esm.js",
  "types": "dist/index.d.ts",
  "files": [
    "dist"
  ],
  "exports": {
    ".": {
      "import": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.esm.js"
      },
      "require": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.js"
      },
      "development": "./src/index.ts"
    },
    "./package.json": "./package.json"
  },
  "scripts": {
    "build": "tsc && rollup -c",
    "dev": "tsc --watch",
    "test": "jest",
    "lint": "eslint src --ext .ts",
    "lint:fix": "eslint src --ext .ts --fix",
    "format": "prettier --write \"src/**/*.ts\"",
    "format:check": "prettier --check \"src/**/*.ts\"",
    "prepublishOnly": "yarn lint && yarn test && yarn build"
  },
  "peerDependencies": {
    "@pabitel/core": "^0.1.0"
  },
  "devDependencies": {
    "@rollup/plugin-commonjs": "^28.0.3",
    "@rollup/plugin-node-resolve": "^16.0.1",
    "@types/jest": "^29.5.14",
    "eslint": "^9",
    "jest": "^29.7.0",
    "prettier": "^3",
    "rollup": "^4",
    "rollup-plugin-typescript2": "^0.36.0",
    "ts-jest": "^29.3.1",
    "typescript": "^5.8.2"
  },
  "keywords": [
    "pabitel",
    "save",
    "storage",
    "plugin",
    "localStorage"
  ],
  "author": "Jakub Hájek",
  "repository": {
    "type": "git",
    "url": "https://github.com/jimmyhayek/textgame.git"
  }
}
</file>

<file path="packages/plugin-local-storage/rollup.config.js">
import typescript from 'rollup-plugin-typescript2';
import { nodeResolve } from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import pkg from './package.json';

export default [
  {
    input: 'src/index.ts',
    output: {
      file: pkg.module,
      format: 'esm',
      sourcemap: true
    },
    plugins: [
      typescript({
        tsconfig: './tsconfig.json',
        useTsconfigDeclarationDir: true
      }),
      nodeResolve(),
      commonjs()
    ],
    external: [...Object.keys(pkg.dependencies || {}), ...Object.keys(pkg.peerDependencies || {})]
  },
  {
    input: 'src/index.ts',
    output: {
      file: pkg.main,
      format: 'cjs',
      sourcemap: true
    },
    plugins: [
      typescript({
        tsconfig: './tsconfig.json',
        useTsconfigDeclarationDir: true
      }),
      nodeResolve(),
      commonjs()
    ],
    external: [...Object.keys(pkg.dependencies || {}), ...Object.keys(pkg.peerDependencies || {})]
  }
];
</file>

<file path="packages/plugin-local-storage/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "declaration": true,
    "declarationDir": "./dist",
    "outDir": "./dist",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "test", "examples"]
}
</file>

<file path="packages/core/src/effect/index.ts">
// Export typů
export * from './types';

// Export hlavních tříd
export { EffectManager } from './EffectManager';

// Export procesorů
export { createDefaultEffectProcessors } from './processors';

// Export utilit
export {
  createSetEffect,
  createIncrementEffect,
  createDecrementEffect,
  createToggleEffect,
  createPushEffect,
  createRemoveEffect,
  createBatchEffect,
  createSequenceEffect,
  createConditionalEffect,
  createRepeatEffect,
  toBatchEffect,
  toSequenceEffect,
  isEffectOfType,
  isEffectFromNamespace,
} from './utils';
</file>

<file path="packages/core/src/effect/processors.ts">
import {
  EffectProcessor,
  BuiltInEffectType,
  BatchEffect,
  SequenceEffect,
  ConditionalEffect,
  RepeatEffect,
} from './types';
import { GameState } from '../state/types';
import { produce } from '../utils/immer';
import get from 'lodash/get';
import set from 'lodash/set';

type ProcessorRegistry = Record<string, EffectProcessor>;

/**
 * Pomocná funkce pro zpracování efektu
 * (Lokální ekvivalent processSingleEffect z EffectManager)
 * @private
 */
function processSingleEffect(
  effect: any,
  draftState: GameState,
  processors: ProcessorRegistry
): void {
  const processor = processors[effect.type];

  if (processor) {
    processor(effect, draftState);
  } else {
    console.warn(`No processor registered for effect type '${effect.type}'`);
  }
}

/**
 * Vytvoří registry procesorů výchozích efektů
 *
 * @returns Objekt mapující typy efektů na jejich procesory
 */
export function createDefaultEffectProcessors(): ProcessorRegistry {
  const processors: ProcessorRegistry = {};

  // Základní operace s proměnnými
  processors[BuiltInEffectType.set] = (effect, draftState) => {
    const { variable, value, path } = effect;

    if (path) {
      set(draftState, path, value);
    } else {
      draftState.variables[variable] = value;
    }
  };

  processors[BuiltInEffectType.increment] = (effect, draftState) => {
    const { variable, value = 1, path } = effect;

    if (path) {
      const currentValue = get(draftState, path, 0);
      const newValue = typeof currentValue !== 'number' ? value : currentValue + value;
      set(draftState, path, newValue);
    } else {
      if (typeof draftState.variables[variable] !== 'number') {
        draftState.variables[variable] = 0;
      }
      draftState.variables[variable] += value;
    }
  };

  processors[BuiltInEffectType.decrement] = (effect, draftState) => {
    const { variable, value = 1, path } = effect;

    if (path) {
      const currentValue = get(draftState, path, 0);
      const newValue = typeof currentValue !== 'number' ? -value : currentValue - value;
      set(draftState, path, newValue);
    } else {
      if (typeof draftState.variables[variable] !== 'number') {
        draftState.variables[variable] = 0;
      }
      draftState.variables[variable] -= value;
    }
  };

  processors[BuiltInEffectType.multiply] = (effect, draftState) => {
    const { variable, value, path } = effect;

    if (path) {
      const currentValue = get(draftState, path, 0);
      const newValue = typeof currentValue !== 'number' ? 0 : currentValue * value;
      set(draftState, path, newValue);
    } else {
      if (typeof draftState.variables[variable] !== 'number') {
        draftState.variables[variable] = 0;
      }
      draftState.variables[variable] *= value;
    }
  };

  processors[BuiltInEffectType.divide] = (effect, draftState) => {
    const { variable, value, path } = effect;

    if (value === 0) {
      throw new Error('Cannot divide by zero');
    }

    if (path) {
      const currentValue = get(draftState, path, 0);
      const newValue = typeof currentValue !== 'number' ? 0 : currentValue / value;
      set(draftState, path, newValue);
    } else {
      if (typeof draftState.variables[variable] !== 'number') {
        draftState.variables[variable] = 0;
      }
      draftState.variables[variable] /= value;
    }
  };

  processors[BuiltInEffectType.toggle] = (effect, draftState) => {
    const { variable, path } = effect;

    if (path) {
      const currentValue = get(draftState, path, false);
      set(draftState, path, !currentValue);
    } else {
      draftState.variables[variable] = !draftState.variables[variable];
    }
  };

  // Operace s poli
  processors[BuiltInEffectType.push] = (effect, draftState) => {
    const { array, value, path } = effect;

    if (path) {
      const currentArray = get(draftState, path, []);
      if (!Array.isArray(currentArray)) {
        set(draftState, path, [value]);
      } else {
        currentArray.push(value);
      }
    } else {
      if (!Array.isArray(draftState.variables[array])) {
        draftState.variables[array] = [];
      }
      draftState.variables[array].push(value);
    }
  };

  processors[BuiltInEffectType.remove] = (effect, draftState) => {
    const { array, value, byIndex = false, path } = effect;

    const removeByIndexOrValue = (arr: any[], val: any, useIndex: boolean) => {
      if (useIndex) {
        if (val >= 0 && val < arr.length) {
          arr.splice(val, 1);
        }
      } else if (typeof val === 'object') {
        // Pro objektové hodnoty hledáme podle equality funkce, pokud je poskytnuta
        const equalityFn = effect.equalityFn || ((a: any, b: any) => a === b);
        const index = arr.findIndex(item => equalityFn(item, val));
        if (index !== -1) {
          arr.splice(index, 1);
        }
      } else {
        const index = arr.indexOf(val);
        if (index !== -1) {
          arr.splice(index, 1);
        }
      }
    };

    if (path) {
      const currentArray = get(draftState, path, []);
      if (Array.isArray(currentArray)) {
        removeByIndexOrValue(currentArray, value, byIndex);
      }
    } else {
      if (Array.isArray(draftState.variables[array])) {
        removeByIndexOrValue(draftState.variables[array], value, byIndex);
      }
    }
  };

  // Kompozitní efekty
  processors[BuiltInEffectType.batch] = (effect, draftState) => {
    const batchEffect = effect as BatchEffect;

    if (!batchEffect.effects || !Array.isArray(batchEffect.effects)) {
      throw new Error('Batch effect requires an array of effects');
    }

    for (const subEffect of batchEffect.effects) {
      processSingleEffect(subEffect, draftState, processors);
    }
  };

  processors[BuiltInEffectType.sequence] = (effect, draftState) => {
    const sequenceEffect = effect as SequenceEffect;

    if (!sequenceEffect.effects || !Array.isArray(sequenceEffect.effects)) {
      throw new Error('Sequence effect requires an array of effects');
    }

    for (const subEffect of sequenceEffect.effects) {
      processSingleEffect(subEffect, draftState, processors);
    }
  };

  processors[BuiltInEffectType.conditional] = (effect, draftState) => {
    const conditionalEffect = effect as ConditionalEffect;

    if (!conditionalEffect.condition || typeof conditionalEffect.condition !== 'function') {
      throw new Error('Conditional effect requires a condition function');
    }

    if (!conditionalEffect.thenEffects || !Array.isArray(conditionalEffect.thenEffects)) {
      throw new Error('Conditional effect requires thenEffects array');
    }

    // Pro vyhodnocení podmínky použijeme immutable kopii stavu
    const immutableState = produce(draftState, () => {});
    const conditionResult = conditionalEffect.condition(immutableState);

    if (conditionResult) {
      // Aplikujeme 'then' efekty
      for (const subEffect of conditionalEffect.thenEffects) {
        processSingleEffect(subEffect, draftState, processors);
      }
    } else if (conditionalEffect.elseEffects && Array.isArray(conditionalEffect.elseEffects)) {
      // Aplikujeme 'else' efekty, pokud existují
      for (const subEffect of conditionalEffect.elseEffects) {
        processSingleEffect(subEffect, draftState, processors);
      }
    }
  };

  processors[BuiltInEffectType.repeat] = (effect, draftState) => {
    const repeatEffect = effect as RepeatEffect;

    if (!repeatEffect.effect) {
      throw new Error('Repeat effect requires an effect to repeat');
    }

    let count: number;

    if (typeof repeatEffect.count === 'function') {
      // Pro vyhodnocení počtu opakování použijeme immutable kopii stavu
      const immutableState = produce(draftState, () => {});
      count = repeatEffect.count(immutableState);
    } else {
      count = repeatEffect.count;
    }

    if (!Number.isInteger(count) || count < 0) {
      throw new Error('Repeat count must be a non-negative integer');
    }

    for (let i = 0; i < count; i++) {
      processSingleEffect(repeatEffect.effect, draftState, processors);
    }
  };

  return processors;
}
</file>

<file path="packages/core/src/effect/utils.ts">
import {
  Effect,
  BatchEffect,
  SequenceEffect,
  ConditionalEffect,
  RepeatEffect,
  SetVariableEffect,
  IncrementVariableEffect,
  DecrementVariableEffect,
  ToggleVariableEffect,
  PushToArrayEffect,
  RemoveFromArrayEffect,
  BuiltInEffectType,
} from './types';
import { GameState } from '../state/types';

/**
 * Vytvoří efekt pro nastavení hodnoty proměnné
 */
export function createSetEffect(variable: string, value: any, path?: string): SetVariableEffect {
  return {
    type: BuiltInEffectType.set,
    variable,
    value,
    path,
  };
}

/**
 * Vytvoří efekt pro zvýšení hodnoty proměnné
 */
export function createIncrementEffect(
  variable: string,
  value = 1,
  path?: string
): IncrementVariableEffect {
  return {
    type: BuiltInEffectType.increment,
    variable,
    value,
    path,
  };
}

/**
 * Vytvoří efekt pro snížení hodnoty proměnné
 */
export function createDecrementEffect(
  variable: string,
  value = 1,
  path?: string
): DecrementVariableEffect {
  return {
    type: BuiltInEffectType.decrement,
    variable,
    value,
    path,
  };
}

/**
 * Vytvoří efekt pro přepnutí boolean hodnoty proměnné
 */
export function createToggleEffect(variable: string, path?: string): ToggleVariableEffect {
  return {
    type: BuiltInEffectType.toggle,
    variable,
    path,
  };
}

/**
 * Vytvoří efekt pro přidání hodnoty do pole
 */
export function createPushEffect(array: string, value: any, path?: string): PushToArrayEffect {
  return {
    type: BuiltInEffectType.push,
    array,
    value,
    path,
  };
}

/**
 * Vytvoří efekt pro odstranění hodnoty z pole
 */
export function createRemoveEffect(
  array: string,
  value: any,
  options: { byIndex?: boolean; path?: string; equalityFn?: (a: any, b: any) => boolean } = {}
): RemoveFromArrayEffect {
  return {
    type: BuiltInEffectType.remove,
    array,
    value,
    ...options,
  };
}

/**
 * Vytvoří efekt pro dávkové provedení více efektů najednou
 */
export function createBatchEffect(effects: Effect[]): BatchEffect {
  return {
    type: BuiltInEffectType.batch,
    effects,
  };
}

/**
 * Vytvoří efekt pro sekvenční provedení více efektů
 */
export function createSequenceEffect(effects: Effect[]): SequenceEffect {
  return {
    type: BuiltInEffectType.sequence,
    effects,
  };
}

/**
 * Vytvoří efekt pro podmíněné provedení efektů
 */
export function createConditionalEffect(
  condition: (state: GameState) => boolean,
  thenEffects: Effect[],
  elseEffects?: Effect[]
): ConditionalEffect {
  return {
    type: BuiltInEffectType.conditional,
    condition,
    thenEffects,
    elseEffects,
  };
}

/**
 * Vytvoří efekt pro opakované provedení jiného efektu
 */
export function createRepeatEffect(
  effect: Effect,
  count: number | ((state: GameState) => number)
): RepeatEffect {
  return {
    type: BuiltInEffectType.repeat,
    count,
    effect,
  };
}

/**
 * Převede neuspořádaný seznam efektů na batch efekt
 */
export function toBatchEffect(effects: Effect[]): BatchEffect {
  return createBatchEffect(effects);
}

/**
 * Převede neuspořádaný seznam efektů na sequence efekt
 */
export function toSequenceEffect(effects: Effect[]): SequenceEffect {
  return createSequenceEffect(effects);
}

/**
 * Zkontroluje, zda je efekt určitého typu
 */
export function isEffectOfType<T extends Effect>(
  effect: Effect,
  type: BuiltInEffectType | string
): effect is T {
  return effect.type === type;
}

/**
 * Zkontroluje, zda je efekt z určitého jmenného prostoru
 */
export function isEffectFromNamespace(effect: Effect, namespace: string): boolean {
  return 'namespace' in effect && (effect as any).namespace === namespace;
}
</file>

<file path="packages/core/src/engine/utils.ts">
import { GameEngine } from './GameEngine';
import { GameEngineOptions } from './types';
import { Scene } from '../scene/types';
import { GenericContentLoader } from '../content/GenericContentLoader';
import { ContentDefinition } from '../content/types';
import { Plugin } from '../plugin/types';
import { GameState } from '../state/types';

/**
 * Možnosti pro vytvoření herního enginu
 */
export interface CreateGameEngineOptions {
  /**
   * Definice obsahu k registraci
   */
  content?: ContentDefinition<any>[];

  /**
   * Pluginy k registraci
   */
  plugins?: Plugin[];

  /**
   * Počáteční stav hry
   */
  initialState?: Partial<GameState>;

  /**
   * Vlastní content loader pro scény
   */
  sceneLoader?: GenericContentLoader<Scene>;

  /**
   * Další možnosti konfigurace enginu
   */
  engineOptions?: Partial<GameEngineOptions>;
}

/**
 * Vytvoří nový herní engine s danou konfigurací
 *
 * @param options Možnosti pro vytvoření enginu
 * @returns Nová instance herního enginu
 */
export function createGameEngine(options: CreateGameEngineOptions = {}): GameEngine {
  const {
    content = [],
    plugins = [],
    initialState = {},
    sceneLoader = new GenericContentLoader<Scene>(),
    engineOptions = {},
  } = options;

  // Vytvoření enginu
  const engine = new GameEngine({
    sceneLoader,
    initialState,
    plugins,
    ...engineOptions,
  });

  // Registrace obsahu
  for (const contentDef of content) {
    engine.registerContent(contentDef);
  }

  return engine;
}
</file>

<file path="packages/core/src/event/EventEmitter.ts">
import { GameEventType, EventListener, EventEmitterOptions } from './types';

/**
 * EventEmitter implementuje návrhový vzor Observer
 * Umožňuje registraci posluchačů událostí a emitování událostí
 */
export class EventEmitter {
  /**
   * Mapa posluchačů událostí
   * Klíč je typ události, hodnota je množina posluchačů
   */
  private listeners: Map<GameEventType, Set<EventListener>> = new Map();

  /**
   * Mapa jednorázových posluchačů událostí
   * Posluchači jsou automaticky odstraněni po prvním zavolání
   */
  private onceListeners: Map<GameEventType, Set<EventListener>> = new Map();

  /**
   * Maximální počet posluchačů na jeden typ události
   */
  private maxListeners: number;

  /**
   * Zda zachytávat chyby v posluchačích
   */
  private catchErrors: boolean;

  /**
   * Vytvoří nový EventEmitter
   *
   * @param options Možnosti konfigurace EventEmitter
   */
  constructor(options: EventEmitterOptions = {}) {
    const { catchErrors = true, maxListeners = 10 } = options;
    this.catchErrors = catchErrors;
    this.maxListeners = maxListeners;
  }

  /**
   * Registruje posluchače pro daný typ události
   *
   * @param eventType Typ události
   * @param listener Funkce posluchače
   */
  public on(eventType: GameEventType, listener: EventListener): void {
    if (!this.listeners.has(eventType)) {
      this.listeners.set(eventType, new Set());
    }

    const eventListeners = this.listeners.get(eventType)!;
    eventListeners.add(listener);

    // Kontrola počtu posluchačů
    if (eventListeners.size > this.maxListeners) {
      console.warn(
        `Possible EventEmitter memory leak detected. ${eventListeners.size} listeners added for event type '${eventType}'`
      );
    }
  }

  /**
   * Registruje jednorázového posluchače pro daný typ události
   * Posluchač bude automaticky odstraněn po prvním zavolání
   *
   * @param eventType Typ události
   * @param listener Funkce posluchače
   */
  public once(eventType: GameEventType, listener: EventListener): void {
    if (!this.onceListeners.has(eventType)) {
      this.onceListeners.set(eventType, new Set());
    }

    const eventListeners = this.onceListeners.get(eventType)!;
    eventListeners.add(listener);
  }

  /**
   * Odregistruje posluchače pro daný typ události
   *
   * @param eventType Typ události
   * @param listener Funkce posluchače
   */
  public off(eventType: GameEventType, listener: EventListener): void {
    // Kontrola běžných posluchačů
    const eventListeners = this.listeners.get(eventType);
    if (eventListeners) {
      eventListeners.delete(listener);
      if (eventListeners.size === 0) {
        this.listeners.delete(eventType);
      }
    }

    // Kontrola jednorázových posluchačů
    const onceEventListeners = this.onceListeners.get(eventType);
    if (onceEventListeners) {
      onceEventListeners.delete(listener);
      if (onceEventListeners.size === 0) {
        this.onceListeners.delete(eventType);
      }
    }
  }

  /**
   * Emituje událost daného typu s volitelným datovým objektem
   *
   * @param eventType Typ události
   * @param data Volitelná data předaná posluchačům
   */
  public emit(eventType: GameEventType, data?: any): void {
    // Zavolání běžných posluchačů
    const eventListeners = this.listeners.get(eventType);
    if (eventListeners) {
      this.callListeners(eventListeners, data);
    }

    // Zavolání a odstranění jednorázových posluchačů
    const onceEventListeners = this.onceListeners.get(eventType);
    if (onceEventListeners && onceEventListeners.size > 0) {
      this.callListeners(onceEventListeners, data);
      this.onceListeners.delete(eventType);
    }
  }

  /**
   * Volá všechny posluchače v dané množině s danými daty
   *
   * @param listeners Množina posluchačů
   * @param data Data k předání posluchačům
   * @private
   */
  private callListeners(listeners: Set<EventListener>, data: any): void {
    for (const listener of listeners) {
      try {
        listener(data);
      } catch (error) {
        if (!this.catchErrors) {
          throw error;
        }
        console.error(`Error in event listener:`, error);
      }
    }
  }

  /**
   * Odstraní všechny posluchače pro daný typ události
   * Pokud není typ události specifikován, odstraní všechny posluchače
   *
   * @param eventType Volitelný typ události
   */
  public removeAllListeners(eventType?: GameEventType): void {
    if (eventType) {
      this.listeners.delete(eventType);
      this.onceListeners.delete(eventType);
    } else {
      this.listeners.clear();
      this.onceListeners.clear();
    }
  }

  /**
   * Vrátí seznam všech registrovaných typů událostí
   *
   * @returns Pole typů událostí
   */
  public getEventTypes(): GameEventType[] {
    const types = new Set([...this.listeners.keys(), ...this.onceListeners.keys()]);
    return Array.from(types);
  }

  /**
   * Vrátí počet posluchačů pro daný typ události
   *
   * @param eventType Typ události
   * @returns Počet posluchačů
   */
  public listenerCount(eventType: GameEventType): number {
    let count = 0;

    const eventListeners = this.listeners.get(eventType);
    if (eventListeners) {
      count += eventListeners.size;
    }

    const onceEventListeners = this.onceListeners.get(eventType);
    if (onceEventListeners) {
      count += onceEventListeners.size;
    }

    return count;
  }

  /**
   * Nastaví maximální počet posluchačů na jeden typ události
   *
   * @param n Maximální počet posluchačů
   */
  public setMaxListeners(n: number): void {
    this.maxListeners = n;
  }

  /**
   * Získá maximální počet posluchačů na jeden typ události
   *
   * @returns Maximální počet posluchačů
   */
  public getMaxListeners(): number {
    return this.maxListeners;
  }
}
</file>

<file path="packages/core/src/event/index.ts">
// Export typů
export * from './types';

// Export hlavních tříd
export { EventEmitter } from './EventEmitter';

// Export utilit
export {
  combineListeners,
  createFilteredListener,
  createCountLimitedListener,
  createDebouncedListener,
  createThrottledListener,
  createAsyncListener,
} from './utils';
</file>

<file path="packages/core/src/event/TypedEventEmitter.ts">
import { EventEmitter } from './EventEmitter';

/**
 * Typově bezpečný EventEmitter
 * @template T Mapa typů eventů na jejich datové typy
 */
export class TypedEventEmitter<T extends Record<string, any>> {
  private emitter: EventEmitter;

  constructor(emitter: EventEmitter) {
    // Přijímá existující EventEmitter
    this.emitter = emitter;
  }

  public on<K extends keyof T>(event: K, listener: (data: T[K]) => void): void {
    this.emitter.on(event as string, listener);
  }

  public once<K extends keyof T>(event: K, listener: (data: T[K]) => void): void {
    this.emitter.once(event as string, listener);
  }

  public off<K extends keyof T>(event: K, listener: (data: T[K]) => void): void {
    this.emitter.off(event as string, listener);
  }

  public emit<K extends keyof T>(event: K, data: T[K]): void {
    this.emitter.emit(event as string, data);
  }

  public listenerCount<K extends keyof T>(event: K): number {
    return this.emitter.listenerCount(event as string);
  }

  public removeAllListeners<K extends keyof T>(event?: K): void {
    this.emitter.removeAllListeners(event as string | undefined);
  }

  public setMaxListeners(n: number): void {
    this.emitter.setMaxListeners(n);
  }

  public getUnderlyingEmitter(): EventEmitter {
    return this.emitter;
  }
}
</file>

<file path="packages/core/src/event/utils.ts">
import { EventEmitter } from './EventEmitter';
import { GameEventType, EventListener } from './types';

/**
 * Vytvoří funkci, která spojí více posluchačů do jednoho
 *
 * @param listeners Pole posluchačů k spojení
 * @returns Funkce, která volá všechny zadané posluchače
 */
export function combineListeners(listeners: EventListener[]): EventListener {
  return (data: any) => {
    for (const listener of listeners) {
      listener(data);
    }
  };
}

/**
 * Vytvoří předfiltrovaného posluchače, který se volá pouze pokud data splňují podmínku
 *
 * @param listener Původní posluchač
 * @param filter Funkce, která určuje, zda se posluchač zavolá
 * @returns Nový posluchač s filtrem
 */
export function createFilteredListener(
  listener: EventListener,
  filter: (data: any) => boolean
): EventListener {
  return (data: any) => {
    if (filter(data)) {
      listener(data);
    }
  };
}

/**
 * Vytvoří posluchače, který se automaticky odregistruje po N voláních
 *
 * @param emitter Instance EventEmitter
 * @param eventType Typ události
 * @param listener Původní posluchač
 * @param count Počet volání před odregistrací
 * @returns Nový posluchač, který se sám odregistruje
 */
export function createCountLimitedListener(
  emitter: EventEmitter,
  eventType: GameEventType,
  listener: EventListener,
  count: number
): EventListener {
  let callCount = 0;

  const wrappedListener: EventListener = (data: any) => {
    listener(data);
    callCount++;

    if (callCount >= count) {
      emitter.off(eventType, wrappedListener);
    }
  };

  return wrappedListener;
}

/**
 * Vytvoří debounced verzi posluchače, která se volá maximálně jednou za daný interval
 *
 * @param listener Původní posluchač
 * @param wait Čekací doba v milisekundách
 * @returns Debounced posluchač
 */
export function createDebouncedListener(listener: EventListener, wait: number): EventListener {
  let timeout: any = null;

  return (data: any) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      listener(data);
    }, wait);
  };
}

/**
 * Vytvoří throttled verzi posluchače, která se volá maximálně jednou za daný interval
 *
 * @param listener Původní posluchač
 * @param limit Minimální interval mezi voláními v milisekundách
 * @returns Throttled posluchač
 */
export function createThrottledListener(listener: EventListener, limit: number): EventListener {
  let waiting = false;
  let lastData: any = null;

  return (data: any) => {
    if (!waiting) {
      listener(data);
      waiting = true;
      setTimeout(() => {
        waiting = false;
        if (lastData !== null) {
          const currentData = lastData;
          lastData = null;
          listener(currentData);
        }
      }, limit);
    } else {
      lastData = data;
    }
  };
}

/**
 * Zabalí posluchače událostí tak, aby se vykonával asynchronně
 *
 * @param listener Původní posluchač
 * @returns Asynchronní posluchač
 */
export function createAsyncListener(listener: EventListener): EventListener {
  return (data: any) => {
    setTimeout(() => {
      listener(data);
    }, 0);
  };
}
</file>

<file path="packages/core/src/plugin/utils.ts">
import { Plugin, PluginOptions } from './types';
import { AbstractPlugin } from './AbstractPlugin';
import { GameEngine } from '../engine/GameEngine';

/**
 * Vytvoří jednoduchý plugin pomocí konfigurační funkce
 *
 * @param name Název pluginu
 * @param configureFn Funkce pro konfiguraci pluginu
 * @param options Volitelné možnosti konfigurace
 * @returns Nová instance pluginu
 */
export function createPlugin(
  name: string,
  configureFn: (engine: GameEngine, options: PluginOptions) => void | Promise<void>,
  options: PluginOptions = {}
): Plugin {
  class SimplePlugin extends AbstractPlugin {
    constructor() {
      super(name, options);
    }

    protected async onInitialize(): Promise<void> {
      if (this.engine) {
        await Promise.resolve(configureFn(this.engine, this.options));
      }
    }
  }

  return new SimplePlugin();
}
</file>

<file path="packages/core/src/save/MemoryStorage.ts">
import { SaveData, SaveMetadata, SaveStorage } from './types';

/**
 * In-memory implementace SaveStorage
 * Používá se hlavně pro testování nebo pro dočasné ukládání
 */
export class MemoryStorage implements SaveStorage {
  /**
   * Mapa uložených her (ID -> data)
   */
  private saves: Map<string, SaveData> = new Map();

  /**
   * Uloží data do paměti
   *
   * @param id Identifikátor uložené hry
   * @param data Data k uložení
   * @returns Promise rozhodnutý na true
   */
  public async save(id: string, data: SaveData): Promise<boolean> {
    this.saves.set(id, { ...data });
    return true;
  }

  /**
   * Načte data z paměti
   *
   * @param id Identifikátor uložené hry
   * @returns Promise rozhodnutý na data, nebo null pokud neexistují
   */
  public async load(id: string): Promise<SaveData | null> {
    const save = this.saves.get(id);
    return save ? { ...save } : null;
  }

  /**
   * Vrátí seznam všech uložených her
   *
   * @returns Promise rozhodnutý na objekt mapující ID na metadata
   */
  public async list(): Promise<Record<string, SaveMetadata>> {
    const result: Record<string, SaveMetadata> = {};
    for (const [id, data] of this.saves.entries()) {
      result[id] = { ...data.metadata };
    }
    return result;
  }

  /**
   * Smaže uloženou hru
   *
   * @param id Identifikátor uložené hry
   * @returns Promise rozhodnutý na true, pokud byla hra smazána
   */
  public async delete(id: string): Promise<boolean> {
    return this.saves.delete(id);
  }

  /**
   * Zkontroluje, zda existuje uložená hra
   *
   * @param id Identifikátor uložené hry
   * @returns Promise rozhodnutý na true, pokud hra existuje
   */
  public async exists(id: string): Promise<boolean> {
    return this.saves.has(id);
  }

  /**
   * Vymaže všechna uložení
   *
   * @returns Promise rozhodnutý na true
   */
  public async clearAll(): Promise<boolean> {
    this.saves.clear();
    return true;
  }

  /**
   * Vrátí počet uložených her
   *
   * @returns Počet uložených her
   */
  public getCount(): number {
    return this.saves.size;
  }
}
</file>

<file path="packages/core/src/save/utils.ts">
import { GameEngine } from '../engine/GameEngine';
import { SaveManager } from './SaveManager';
import { SaveStorage, AutoSaveOptions } from './types';
import { MemoryStorage } from './MemoryStorage';
import { LocalStorageProxy } from './LocalStorageProxy';

/**
 * Možnosti pro vytvoření SaveManageru
 */
export interface CreateSaveManagerOptions {
  /**
   * Úložiště pro uložené hry
   */
  storage?: SaveStorage;

  /**
   * Verze enginu
   */
  engineVersion?: string;

  /**
   * Zda automaticky aktivovat automatické ukládání
   */
  enableAutoSave?: boolean;

  /**
   * Interval automatického ukládání v milisekundách
   */
  autoSaveInterval?: number;

  /**
   * Počet slotů pro automatické ukládání
   */
  autoSaveSlots?: number;

  /**
   * Prefix pro klíče v localStorage (pouze pro localStorage úložiště)
   */
  storagePrefix?: string;

  /**
   * Typ úložiště
   * 'memory' - uložení do paměti (pouze pro běh aplikace)
   * 'localStorage' - uložení do localStorage prohlížeče
   * Výchozí: 'localStorage'
   */
  storageType?: 'memory' | 'localStorage';
}

/**
 * Vytvoří SaveManager s předkonfigurovaným nastavením
 *
 * @param engine Instance herního enginu
 * @param options Možnosti pro vytvoření SaveManageru
 * @returns Instance SaveManageru
 */
export function createSaveManager(
  engine: GameEngine,
  options: CreateSaveManagerOptions = {}
): SaveManager {
  // Vytvoření úložiště, pokud není specifikováno
  let storage = options.storage;
  if (!storage) {
    const storageType = options.storageType || 'localStorage';
    if (storageType === 'memory') {
      storage = new MemoryStorage();
    } else {
      storage = new LocalStorageProxy({ prefix: options.storagePrefix });
    }
  }

  // Získání verze enginu z enginu, pokud existuje metoda getVersion
  const engineVersion =
    options.engineVersion ||
    (typeof engine.getVersion === 'function' ? engine.getVersion() : '0.1.0');

  // Vytvoření SaveManageru
  const saveManager = new SaveManager(engine, {
    storage,
    engineVersion,
  });

  // Aktivace automatického ukládání, pokud je požadováno
  if (options.enableAutoSave) {
    const autoSaveOptions: AutoSaveOptions = {};

    if (options.autoSaveInterval) {
      autoSaveOptions.interval = options.autoSaveInterval;
    }

    if (options.autoSaveSlots) {
      autoSaveOptions.slots = options.autoSaveSlots;
    }

    saveManager.enableAutoSave(autoSaveOptions);
  }

  return saveManager;
}

/**
 * Validuje data uložené hry
 *
 * @param saveData Data k validaci
 * @returns True pokud jsou data validní, jinak false
 */
export function validateSaveData(saveData: any): boolean {
  if (!saveData || typeof saveData !== 'object') {
    return false;
  }

  // Kontrola existence a typu požadovaných vlastností
  if (!saveData.metadata || typeof saveData.metadata !== 'object') {
    return false;
  }

  if (typeof saveData.state !== 'string') {
    return false;
  }

  // Kontrola požadovaných polí metadat
  const requiredMetadataFields = ['id', 'name', 'createdAt', 'updatedAt', 'saveVersion'];
  for (const field of requiredMetadataFields) {
    if (!(field in saveData.metadata)) {
      return false;
    }
  }

  return true;
}

/**
 * Vytvoří jedinečné ID pro uloženou hru
 *
 * @param prefix Volitelný prefix
 * @returns Jedinečné ID
 */
export function generateSaveId(prefix: string = 'save'): string {
  const timestamp = Date.now();
  const random = Math.floor(Math.random() * 1000000)
    .toString()
    .padStart(6, '0');
  return `${prefix}_${timestamp}_${random}`;
}

/**
 * Převede čas hraní z milisekund na formátovaný řetězec
 *
 * @param timeMs Čas v milisekundách
 * @param format Formát výstupu ('short', 'medium', 'long')
 * @returns Naformátovaný řetězec
 */
export function formatPlayTime(
  timeMs: number,
  format: 'short' | 'medium' | 'long' = 'medium'
): string {
  const seconds = Math.floor((timeMs / 1000) % 60);
  const minutes = Math.floor((timeMs / (1000 * 60)) % 60);
  const hours = Math.floor(timeMs / (1000 * 60 * 60));
  const days = Math.floor(timeMs / (1000 * 60 * 60 * 24));

  switch (format) {
    case 'short':
      if (hours > 0) {
        return `${hours}h ${minutes}m`;
      } else {
        return `${minutes}m ${seconds}s`;
      }
    case 'long':
      let parts = [];
      if (days > 0) parts.push(`${days} ${days === 1 ? 'den' : 'dnů'}`);
      if (hours > 0) parts.push(`${hours} ${getHoursText(hours)}`);
      if (minutes > 0) parts.push(`${minutes} ${getMinutesText(minutes)}`);
      if (seconds > 0 || parts.length === 0) {
        parts.push(`${seconds} ${getSecondsText(seconds)}`);
      }
      return parts.join(', ');
    case 'medium':
    default:
      return [
        hours.toString().padStart(2, '0'),
        minutes.toString().padStart(2, '0'),
        seconds.toString().padStart(2, '0'),
      ].join(':');
  }
}

// Pomocné funkce pro českou lokalizaci
function getHoursText(hours: number): string {
  if (hours === 1) return 'hodina';
  if (hours >= 2 && hours <= 4) return 'hodiny';
  return 'hodin';
}

function getMinutesText(minutes: number): string {
  if (minutes === 1) return 'minuta';
  if (minutes >= 2 && minutes <= 4) return 'minuty';
  return 'minut';
}

function getSecondsText(seconds: number): string {
  if (seconds === 1) return 'sekunda';
  if (seconds >= 2 && seconds <= 4) return 'sekundy';
  return 'sekund';
}

/**
 * Exportuje uloženou hru do souboru
 *
 * @param saveData Data uložené hry
 * @param filename Název souboru
 */
export function exportSaveToFile(saveData: any, filename: string = 'save.json'): void {
  if (typeof window === 'undefined') {
    console.warn('Export to file is only available in browser environment');
    return;
  }

  try {
    const json = JSON.stringify(saveData, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();

    // Uvolnění URL po stažení
    setTimeout(() => {
      URL.revokeObjectURL(url);
    }, 100);
  } catch (error) {
    console.error('Failed to export save file:', error);
  }
}

/**
 * Importuje uloženou hru ze souboru
 *
 * @param file Soubor k importu
 * @returns Promise rozhodnutý na data uložené hry
 */
export function importSaveFromFile(file: File): Promise<any> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();

    reader.onload = e => {
      try {
        const content = e.target?.result as string;
        const saveData = JSON.parse(content);

        if (!validateSaveData(saveData)) {
          reject(new Error('Invalid save file format'));
          return;
        }

        resolve(saveData);
      } catch (error) {
        reject(error);
      }
    };

    reader.onerror = () => {
      reject(new Error('Error reading file'));
    };

    reader.readAsText(file);
  });
}
</file>

<file path="packages/core/src/scene/index.ts">
// Export typů
export * from './types';

// Export hlavních tříd
export { SceneManager } from './SceneManager';

// Export utilit
export {
  getSceneContent,
  isSceneVisited,
  validateScene,
  normalizeSceneKey,
  getParentSceneKey,
  getSceneNameFromKey,
} from './utils';
</file>

<file path="packages/core/src/scene/SceneManager.ts">
import { GameState } from '../state/types';
import { Scene, SceneKey } from './types';
import { GenericContentLoader } from '../content/GenericContentLoader';

/**
 * Spravuje scény a přechody mezi nimi
 */
export class SceneManager {
  /** Klíč aktuální scény */
  private currentSceneKey: SceneKey | null = null;

  /** Reference na objekt aktuální scény */
  private currentScene: Scene | null = null;

  /** Content loader pro scény */
  private sceneLoader: GenericContentLoader<Scene>;

  /**
   * Vytvoří novou instanci SceneManager
   */
  constructor(sceneLoader: GenericContentLoader<Scene>) {
    this.sceneLoader = sceneLoader;
  }

  /**
   * Přechod na novou scénu
   */
  public async transitionToScene(
    sceneKey: SceneKey,
    state: GameState,
    engine: any
  ): Promise<boolean> {
    try {
      const targetScene: Scene = await this.sceneLoader.loadContent(sceneKey);

      if (!targetScene) {
        console.error(`Scene with key '${sceneKey}' not found.`);
        return false;
      }

      // Pokud existuje aktuální scéna, zavolá se její onExit metoda
      if (this.currentScene && this.currentScene.onExit) {
        this.currentScene.onExit(state, engine);
      }

      // Aktualizace aktuální scény
      this.currentSceneKey = sceneKey;
      this.currentScene = targetScene;

      // Aktualizace stavu pro sledování navštívených scén
      if (engine.getStateManager && typeof engine.getStateManager === 'function') {
        engine.getStateManager().updateState((draftState: GameState) => {
          draftState.visitedScenes.add(sceneKey);
        });
      } else {
        state.visitedScenes.add(sceneKey);
      }

      // Zavolání onEnter metody nové scény
      if (targetScene.onEnter) {
        targetScene.onEnter(state, engine);
      }

      return true;
    } catch (error) {
      console.error(`Error transitioning to scene '${sceneKey}':`, error);
      return false;
    }
  }

  /**
   * Získá aktuální scénu
   */
  public getCurrentScene(): Scene | null {
    return this.currentScene;
  }

  /**
   * Získá klíč aktuální scény
   */
  public getCurrentSceneKey(): SceneKey | null {
    return this.currentSceneKey;
  }

  /**
   * Předem načte scény podle klíčů
   */
  public async preloadScenes(sceneKeys?: SceneKey[]): Promise<void> {
    return this.sceneLoader.preloadContent(sceneKeys);
  }

  /**
   * Získá loader používaný tímto managerem
   */
  public getSceneLoader(): GenericContentLoader<Scene> {
    return this.sceneLoader;
  }
}
</file>

<file path="packages/core/src/scene/types.ts">
import { GameState } from '../state/types';
import { Effect } from '../effect/types';

/**
 * Typ pro klíč scény
 */
export type SceneKey = string;

/**
 * Reprezentuje scénu ve hře
 */
export interface Scene {
  /**
   * Titulek scény
   */
  title: string;

  /**
   * Obsah scény, může být statický nebo dynamický
   */
  content: string | ((state: GameState) => string);

  /**
   * Handler volaný při vstupu do scény
   */
  onEnter?: (state: GameState, engine: any) => void;

  /**
   * Handler volaný při odchodu ze scény
   */
  onExit?: (state: GameState, engine: any) => void;

  /**
   * Další metadata pro rozšíření funkcionality
   */
  metadata?: Record<string, any>;

  /**
   * Interní property obsahující klíč scény
   * @internal
   */
  _key?: SceneKey;
}

/**
 * Funkce pro načtení scény
 */
export type SceneLoader = () => Promise<{ default: Scene } | Scene>;

/**
 * Registry scén mapující klíče na definice nebo loadery
 */
export type ScenesRegistry = Record<SceneKey, Scene | SceneLoader>;

/**
 * Možnosti pro přechod mezi scénami
 */
export interface SceneTransitionOptions {
  /** Volitelné efekty, které se aplikují před přechodem */
  effects?: Effect[];

  /** Volitelná data pro předání scéně při přechodu */
  data?: any;
}
</file>

<file path="packages/core/src/scene/utils.ts">
import { Scene, SceneKey, ScenesRegistry } from './types';
import { GameState } from '../state/types';

/**
 * Získá text obsahu scény, řeší dynamický i statický obsah
 */
export function getSceneContent(scene: Scene, state: GameState): string {
  if (typeof scene.content === 'function') {
    return scene.content(state);
  }
  return scene.content;
}

/**
 * Zjistí, zda scéna byla již navštívena
 */
export function isSceneVisited(sceneKey: SceneKey, state: GameState): boolean {
  return state.visitedScenes.has(sceneKey);
}

/**
 * Validuje kompletnost a správnost definice scény
 */
export function validateScene(scene: Scene): boolean {
  if (!scene.title || !scene.content) {
    return false;
  }

  return true;
}

/**
 * Normalizuje klíč scény (např. převod neplatných znaků, normalizace cesty)
 */
export function normalizeSceneKey(key: string): SceneKey {
  return key
    .trim()
    .replace(/\/{2,}/g, '/')
    .replace(/^\/|\/$/g, '');
}

/**
 * Získá rodičovský klíč scény (např. pro 'forest/clearing' vrátí 'forest')
 */
export function getParentSceneKey(sceneKey: SceneKey): SceneKey | null {
  const lastSlashIndex = sceneKey.lastIndexOf('/');
  if (lastSlashIndex === -1) {
    return null;
  }
  return sceneKey.substring(0, lastSlashIndex);
}

/**
 * Získá název scény z klíče (např. pro 'forest/clearing' vrátí 'clearing')
 */
export function getSceneNameFromKey(sceneKey: SceneKey): string {
  const lastSlashIndex = sceneKey.lastIndexOf('/');
  if (lastSlashIndex === -1) {
    return sceneKey;
  }
  return sceneKey.substring(lastSlashIndex + 1);
}
</file>

<file path="packages/core/src/state/persistence/index.ts">
// Export typů specifických pro persistenci
export * from './types';

// Export hlavních služeb pro persistenci
export { StateConverter } from './StateConverter';
export { StateMigrationService } from './StateMigrationService';

// Export utilit pro vytváření migračních funkcí
export * from './utils';
</file>

<file path="packages/core/src/state/persistence/types.ts">
import { GameState } from '../types'; // Import GameState from runtime types

/**
 * Možnosti pro serializaci stavu
 */
export interface SerializationOptions {
  /**
   * Zda zahrnout metadata o stavu (např. verzi stavu)
   * Výchozí: true
   */
  includeMetadata?: boolean;

  /**
   * Vlastní replacer funkce pro JSON.stringify
   */
  replacer?: (key: string, value: any) => any;

  /**
   * Další volby specifické pro implementaci
   */
  [key: string]: any;
}

/**
 * Metadata o formátu stavu, uložená v persistovaném stavu
 */
export interface StateMetadata {
  /**
   * Verze formátu stavu (pro účely migrace)
   */
  version: number;

  /**
   * Časové razítko vytvoření metadat
   */
  timestamp: number;

  /**
   * Další metadata
   */
  [key: string]: any;
}

/**
 * Typ pro persistovanou část stavu (formát pro serializaci/deserializaci)
 * Jedná se o plain object, který může být konvertován na JSON.
 * Obsahuje pouze perzistentní klíče z GameState a metadata.
 */
export interface PersistedState<T extends Record<string, unknown> = Record<string, unknown>> {
  /**
   * Navštívené scény - konvertované na pole pro JSON serializaci.
   * Volitelné, pokud by persistentKeys neobsahovalo 'visitedScenes'.
   */
  visitedScenes?: string[];

  /**
   * Herní proměnné.
   * Volitelné, pokud by persistentKeys neobsahovalo 'variables'.
   */
  variables?: T;

  /**
   * Metadata stavu (volitelné, pokud includeMetadata=false).
   */
  _metadata?: StateMetadata;

  /**
   * Indexová signatura pro další persistované vlastnosti.
   */
  [key: string]: unknown;
}

/**
 * Typ pro migrační funkci
 * Přijímá PersistedState (ne GameState) a vrací novou PersistedState.
 */
export type StateMigrationFn = (
  state: PersistedState<unknown>,
  fromVersion: number,
  toVersion: number
) => PersistedState<unknown>;

/**
 * Eventy emitované Persistence vrstvou StateManageru (serializace, deserializace, migrace)
 */
export interface StateManagerPersistenceEvents<
  T extends Record<string, unknown> = Record<string, unknown>,
> {
  /**
   * Emitováno po aplikaci jednoho kroku migrace.
   */
  migrationApplied: {
    fromVersion: number;
    toVersion: number;
    state: PersistedState<T>; // Emituje PersistedState po kroku migrace
  };

  /**
   * Emitováno před serializací stavu (v rámci StateConverter).
   */
  beforeSerialize: { state: GameState<T> }; // Emituje GameState před konverzí na PersistedState

  /**
   * Emitováno po deserializaci stringu a migraci (v rámci StateConverter),
   * před jeho aplikací na GameStateManager.
   */
  afterDeserialize: { state: PersistedState<T> }; // Emituje PersistedState po deserializaci a migraci
}
</file>

<file path="packages/core/src/state/persistence/utils.ts">
import { PersistedState, StateMigrationFn } from './types';

/**
 * Vytvoří migrační funkci pro přejmenování vlastnosti na dané cestě v persistovaném stavu.
 * Používá standardní JS/lodash operace na plain objektu (PersistedState).
 * @param oldPath Původní cesta k vlastnosti (dot notation, např. 'variables.player.name' nebo 'inventory')
 * @param newPath Nová cesta k vlastnosti (dot notation)
 * @returns Migrační funkce
 */
export function createRenameMigration(oldPath: string, newPath: string): StateMigrationFn {
  return (state, fromVersion, toVersion) => {
    // Vytvoříme kopii stavu, aby migrační funkce byly immutable ve svém vstupu
    // a neměnily původní objekt předávaný do migrate().
    // Aplikace Immer produce by zde byla náročnější, ale bezpečnější pro složité struktury.
    // Pro jednoduché plain objekty stačí spread.
    const newState = { ...state }; // Kopie první úrovně

    // Implementace pro zanořené cesty
    const oldPathParts = oldPath.split('.');
    const newPathParts = newPath.split('.');

    let currentOld: any = newState;
    let parentOfOld: any = null;
    let oldKey: string | undefined;

    // Najdeme hodnotu na staré cestě a rodiče
    for (let i = 0; i < oldPathParts.length; i++) {
      oldKey = oldPathParts[i];
      if (currentOld === undefined || currentOld === null || typeof currentOld !== 'object') {
        console.warn(
          `Migration Warning (v${fromVersion} to v${toVersion}): Path segment '${oldPathParts[i]}' in old path '${oldPath}' is not an object. Skipping rename.`
        );
        return state; // Cesta se zlomila, nic neděláme
      }
      if (i < oldPathParts.length - 1) {
        parentOfOld = currentOld;
        currentOld = currentOld[oldKey];
      } else {
        currentOld = currentOld[oldKey]; // Hodnota na konci staré cesty
      }
    }

    // Pokud hodnota na staré cestě existuje (není undefined), provedeme přenos
    if (currentOld !== undefined) {
      // Vytvoříme novou strukturu pro novou cestu, pokud neexistuje
      let currentNew: any = newState;
      for (let i = 0; i < newPathParts.length - 1; i++) {
        const newKeyPart = newPathParts[i];
        if (
          currentNew[newKeyPart] === undefined ||
          currentNew[newKeyPart] === null ||
          typeof currentNew[newKeyPart] !== 'object'
        ) {
          currentNew[newKeyPart] = {}; // Vytvoříme zanořený objekt
        }
        currentNew = currentNew[newKeyPart];
      }

      // Nastavíme hodnotu na nové cestě
      const newKey = newPathParts[newPathParts.length - 1];
      currentNew[newKey] = currentOld;

      // Odstraníme hodnotu na staré cestě, pokud existuje rodič a klíč
      if (parentOfOld && oldKey !== undefined && typeof parentOfOld === 'object') {
        delete parentOfOld[oldKey];
      } else if (oldKey !== undefined && parentOfOld === null) {
        // Případ, kdy stará cesta začíná přímo na kořeni (např. 'myOldProp')
        delete newState[oldKey];
      }

      console.log(
        `Migration Applied (v${fromVersion} to v${toVersion}): Renamed '${oldPath}' to '${newPath}'`
      );
    } else {
      console.warn(
        `Migration Warning (v${fromVersion} to v${toVersion}): Value at old path '${oldPath}' is undefined. Skipping rename.`
      );
    }

    return newState; // Vracíme (modifikovaný) objekt stavu
  };
}

/**
 * Vytvoří migrační funkci pro transformaci hodnoty na dané cestě v persistovaném stavu.
 * @template T Původní typ hodnoty na cestě
 * @template U Nový typ hodnoty na cestě
 * @param path Cesta k hodnotě (dot notation)
 * @param transformFn Funkce pro transformaci hodnoty (oldValue: T => newValue: U)
 * @returns Migrační funkce
 */
export function createTransformMigration<T, U>(
  path: string,
  transformFn: (oldValue: T) => U
): StateMigrationFn {
  return (state, fromVersion, toVersion) => {
    const newState = { ...state }; // Kopie první úrovně
    const pathParts = path.split('.');
    let current: any = newState;
    let parent: any = null;
    let key: string | undefined;

    // Najdeme hodnotu na cestě a rodiče
    for (let i = 0; i < pathParts.length; i++) {
      key = pathParts[i];
      if (current === undefined || current === null || typeof current !== 'object') {
        console.warn(
          `Migration Warning (v${fromVersion} to v${toVersion}): Path segment '${pathParts[i]}' in path '${path}' is not an object. Skipping transform.`
        );
        return state; // Cesta se zlomila, nic neděláme
      }
      if (i < pathParts.length - 1) {
        parent = current;
        current = current[key];
      } else {
        parent = current; // Rodič je objekt před posledním klíčem
        current = current[key]; // Hodnota na konci cesty
      }
    }

    // Pokud hodnota na cestě existuje (není undefined) a rodič je objekt, provedeme transformaci
    if (current !== undefined && parent && key !== undefined && typeof parent === 'object') {
      try {
        parent[key] = transformFn(current as T);
        console.log(
          `Migration Applied (v${fromVersion} to v${toVersion}): Transformed value at '${path}'`
        );
      } catch (error) {
        console.error(
          `Migration Error (v${fromVersion} to v${toVersion}): Failed to transform value at '${path}'.`,
          error
        );
        // Můžete se rozhodnout vyhodit chybu nebo jen zalogovat a vrátit původní stav
        // throw error; // Vyhození chyby zastaví migrační proces
      }
    } else {
      console.warn(
        `Migration Warning (v${fromVersion} to v${toVersion}): Value at path '${path}' is undefined or path invalid. Skipping transform.`
      );
    }

    return newState; // Vracíme (modifikovaný) objekt stavu
  };
}

/**
 * Vytvoří migrační funkci pro přidání nové vlastnosti s výchozí hodnotou na dané cestě, pokud neexistuje.
 * Vytvoří zanořené objekty na cestě, pokud je to nutné.
 * @template T Typ výchozí hodnoty
 * @param path Cesta k nové vlastnosti (dot notation)
 * @param defaultValue Výchozí hodnota
 * @returns Migrační funkce
 */
export function createAddPropertyMigration<T>(path: string, defaultValue: T): StateMigrationFn {
  return (state, fromVersion, toVersion) => {
    const newState = { ...state }; // Kopie první úrovně
    const pathParts = path.split('.');
    let current: any = newState;
    let parent: any = null;
    let key: string | undefined;

    // Projdeme cestu a vytvoříme zanořené objekty
    for (let i = 0; i < pathParts.length; i++) {
      key = pathParts[i];
      if (current === undefined || current === null || typeof current !== 'object') {
        // Nelze pokračovat po neobjektové hodnotě, cesta pro přidání není platná v této struktuře
        console.warn(
          `Migration Warning (v${fromVersion} to v${toVersion}): Cannot add property at invalid path '${path}'. Path segment '${pathParts[i]}' is not an object.`
        );
        return state;
      }
      if (i < pathParts.length - 1) {
        parent = current;
        // Pokud neexistuje další zanořený objekt nebo není objekt, vytvoříme ho
        if (
          current[key] === undefined ||
          current[key] === null ||
          typeof current[key] !== 'object'
        ) {
          current[key] = {};
        }
        current = current[key];
      } else {
        // Jsme na poslední úrovni, kde má být vlastnost přidána
        parent = current;
        current = current[key]; // Toto je hodnota, kterou chceme zkontrolovat, zda existuje
      }
    }

    // Pokud vlastnost na cílové cestě neexistuje (je undefined), přidáme ji
    if (current === undefined && parent && key !== undefined && typeof parent === 'object') {
      parent[key] = defaultValue;
      console.log(
        `Migration Applied (v${fromVersion} to v${toVersion}): Added new property at '${path}'`
      );
    } else {
      // Vlastnost už existuje nebo cesta byla nevalidní (varování již zalogováno výše)
      if (current !== undefined) {
        console.warn(
          `Migration Warning (v${fromVersion} to v${toVersion}): Property at '${path}' already exists. Skipping add.`
        );
      }
    }

    return newState; // Vracíme (modifikovaný) objekt stavu
  };
}

/**
 * Vytvoří migrační funkci pro odstranění vlastnosti na dané cestě v persistovaném stavu.
 * @param path Cesta k vlastnosti (dot notation)
 * @returns Migrační funkce
 */
export function createRemovePropertyMigration(path: string): StateMigrationFn {
  return (state, fromVersion, toVersion) => {
    const newState = { ...state }; // Kopie první úrovně
    const pathParts = path.split('.');
    let current: any = newState;
    let parent: any = null;
    let key: string | undefined;

    // Najdeme rodiče a klíč cesty
    for (let i = 0; i < pathParts.length; i++) {
      key = pathParts[i];
      if (current === undefined || current === null || typeof current !== 'object') {
        console.warn(
          `Migration Warning (v${fromVersion} to v${toVersion}): Path segment '${pathParts[i]}' in path '${path}' is not an object. Skipping remove.`
        );
        return state; // Cesta se zlomila, nic neděláme
      }
      if (i < pathParts.length - 1) {
        parent = current;
        current = current[key];
      } else {
        parent = current; // Rodič je objekt před posledním klíčem
        current = current[key]; // Toto je hodnota, kterou chceme zkontrolovat, zda existuje k odstranění
      }
    }

    // Pokud vlastnost existuje (není undefined) a rodič je objekt, odstraníme ji
    if (current !== undefined && parent && key !== undefined && typeof parent === 'object') {
      delete parent[key];
      console.log(
        `Migration Applied (v${fromVersion} to v${toVersion}): Removed property at '${path}'`
      );
    } else {
      console.warn(
        `Migration Warning (v${fromVersion} to v${toVersion}): Property at '${path}' does not exist or path invalid. Skipping remove.`
      );
    }

    return newState; // Vracíme (modifikovaný) objekt stavu
  };
}

/**
 * Kombinuje více migračních funkcí do jedné.
 * Aplikuje funkce postupně v pořadí, v jakém jsou zadány.
 * @param migrations Pole migračních funkcí
 * @returns Kombinovaná migrační funkce
 */
export function combineMigrations(...migrations: StateMigrationFn[]): StateMigrationFn {
  return (state, fromVersion, toVersion) => {
    let currentState = state;
    for (const migration of migrations) {
      // Každá migrace pracuje na výstupu té předchozí
      currentState = migration(currentState, fromVersion, toVersion);
    }
    return currentState;
  };
}

/**
 * Vytvoří migrační funkci, která aplikuje libovolnou transformaci na celý persistovaný stav.
 * @param transformFn Funkce pro transformaci celého stavu (state: PersistedState<unknown> => PersistedState<unknown>)
 * @returns Migrační funkce
 */
export function createStateMigration(
  transformFn: (state: PersistedState<unknown>) => PersistedState<unknown>
): StateMigrationFn {
  return (state, fromVersion, toVersion) => {
    try {
      const newState = transformFn(state);
      console.log(
        `Migration Applied (v${fromVersion} to v${toVersion}): Applied custom state transformation.`
      );
      return newState;
    } catch (error) {
      console.error(
        `Migration Error (v${fromVersion} to v${toVersion}): Error during custom state transformation.`,
        error
      );
      // Propagace chyby, aby se migrační proces zastavil
      throw error;
    }
  };
}

// Speciální utility pro migraci variables (zde jako aliasy pro obecnější funkce)
// Tyto předpokládají, že proměnné jsou přímo na první úrovni 'variables'.
export const createVariableRenameMigration = (oldName: string, newName: string) =>
  createRenameMigration(`variables.${oldName}`, `variables.${newName}`);

export const createVariableTransformMigration = <T, U>(
  name: string,
  transformFn: (oldValue: T) => U
) => createTransformMigration<T, U>(`variables.${name}`, transformFn);

export const createAddVariableMigration = <T>(name: string, defaultValue: T) =>
  createAddPropertyMigration(`variables.${name}`, defaultValue);

export const createRemoveVariableMigration = (name: string) =>
  createRemovePropertyMigration(`variables.${name}`);
</file>

<file path="packages/core/src/utils/object.ts">
/**
 * Hluboká kopie objektu
 *
 * @param obj Objekt ke kopírování
 * @returns Hluboká kopie objektu
 */
export function deepClone<T>(obj: T): T {
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }

  // Převede Set na Array pro klonování a zpět
  if (obj instanceof Set) {
    return new Set(Array.from(obj).map(item => deepClone(item))) as any;
  }

  // Převede Map na Array pro klonování a zpět
  if (obj instanceof Map) {
    return new Map(
      Array.from(obj.entries()).map(([key, value]) => [deepClone(key), deepClone(value)])
    ) as any;
  }

  // Zpracování Date
  if (obj instanceof Date) {
    return new Date(obj.getTime()) as any;
  }

  // Zpracování RegExp
  if (obj instanceof RegExp) {
    return new RegExp(obj.source, obj.flags) as any;
  }

  // Zpracování Array
  if (Array.isArray(obj)) {
    return obj.map(item => deepClone(item)) as any;
  }

  // Zpracování obyčejného Object
  const clonedObj = {} as T;
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      clonedObj[key] = deepClone(obj[key]);
    }
  }

  return clonedObj;
}

/**
 * Hluboké porovnání dvou objektů
 *
 * @param obj1 První objekt
 * @param obj2 Druhý objekt
 * @returns True pokud jsou objekty hluboce rovny
 */
export function deepEqual(obj1: any, obj2: any): boolean {
  // Kontrola primitivních typů a null/undefined
  if (obj1 === obj2) {
    return true;
  }

  // Kontrola, že oba objekty jsou objekty
  if (typeof obj1 !== 'object' || obj1 === null || typeof obj2 !== 'object' || obj2 === null) {
    return false;
  }

  // Speciální ošetření pro Date
  if (obj1 instanceof Date && obj2 instanceof Date) {
    return obj1.getTime() === obj2.getTime();
  }

  // Speciální ošetření pro RegExp
  if (obj1 instanceof RegExp && obj2 instanceof RegExp) {
    return obj1.toString() === obj2.toString();
  }

  // Speciální ošetření pro Set
  if (obj1 instanceof Set && obj2 instanceof Set) {
    if (obj1.size !== obj2.size) return false;
    for (const item of obj1) {
      let found = false;
      for (const item2 of obj2) {
        if (deepEqual(item, item2)) {
          found = true;
          break;
        }
      }
      if (!found) return false;
    }
    return true;
  }

  // Speciální ošetření pro Map
  if (obj1 instanceof Map && obj2 instanceof Map) {
    if (obj1.size !== obj2.size) return false;
    for (const [key, val1] of obj1.entries()) {
      let found = false;
      for (const [key2, val2] of obj2.entries()) {
        if (deepEqual(key, key2) && deepEqual(val1, val2)) {
          found = true;
          break;
        }
      }
      if (!found) return false;
    }
    return true;
  }

  // Kontrola, že mají stejný konstruktor (jsou stejného typu)
  if (obj1.constructor !== obj2.constructor) {
    return false;
  }

  // Pro pole kontrolujeme délku a každý prvek
  if (Array.isArray(obj1)) {
    if (obj1.length !== obj2.length) {
      return false;
    }
    for (let i = 0; i < obj1.length; i++) {
      if (!deepEqual(obj1[i], obj2[i])) {
        return false;
      }
    }
    return true;
  }

  // Pro objekty kontrolujeme klíče a hodnoty
  const keys1 = Object.keys(obj1);
  const keys2 = Object.keys(obj2);

  if (keys1.length !== keys2.length) {
    return false;
  }

  for (const key of keys1) {
    if (!Object.prototype.hasOwnProperty.call(obj2, key)) {
      return false;
    }
    if (!deepEqual(obj1[key], obj2[key])) {
      return false;
    }
  }

  return true;
}

/**
 * Bezpečné získání hodnoty z objektu pomocí cesty (dot notation)
 *
 * @param obj Objekt
 * @param path Cesta k vlastnosti (např. 'user.address.street')
 * @param defaultValue Výchozí hodnota, pokud vlastnost neexistuje
 * @returns Hodnota vlastnosti nebo defaultValue
 */
export function getPath<T = any>(obj: any, path: string, defaultValue?: T): T | undefined {
  if (!obj || !path) return defaultValue;

  const keys = path.split('.');
  let result = obj;

  for (const key of keys) {
    if (result === null || result === undefined || typeof result !== 'object') {
      return defaultValue;
    }
    result = result[key];
  }

  return result === undefined ? defaultValue : (result as T);
}

/**
 * Bezpečné nastavení hodnoty v objektu pomocí cesty (dot notation)
 *
 * @param obj Objekt
 * @param path Cesta k vlastnosti (např. 'user.address.street')
 * @param value Hodnota k nastavení
 * @returns Modifikovaný objekt
 */
export function setPath<T>(obj: T, path: string, value: any): T {
  if (!obj || !path) return obj;

  const keys = path.split('.');
  let current: any = obj;

  for (let i = 0; i < keys.length - 1; i++) {
    const key = keys[i];

    // Vytvoříme nové zanořené objekty, pokud neexistují
    if (current[key] === undefined || current[key] === null || typeof current[key] !== 'object') {
      current[key] = {};
    }

    current = current[key];
  }

  // Nastavíme hodnotu na poslední úrovni
  const lastKey = keys[keys.length - 1];
  current[lastKey] = value;

  return obj;
}
</file>

<file path="packages/core/src/utils/uuid.ts">
/**
 * Generuje jedinečný identifikátor (UUID v4)
 *
 * @returns Jedinečný identifikátor
 */
export function generateUUID(): string {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
    const r = (Math.random() * 16) | 0;
    const v = c === 'x' ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

/**
 * Generuje krátký identifikátor (8 znaků)
 *
 * @param prefix Volitelný prefix pro ID
 * @returns Krátký jedinečný identifikátor
 */
export function generateShortId(prefix?: string): string {
  const randomPart = Math.random().toString(36).substring(2, 8);
  return prefix ? `${prefix}_${randomPart}` : randomPart;
}

/**
 * Kontroluje, zda řetězec je validní UUID
 *
 * @param id Řetězec k kontrole
 * @returns True pokud je validní UUID
 */
export function isValidUUID(id: string): boolean {
  const pattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  return pattern.test(id);
}
</file>

<file path="packages/core/rollup.config.js">
import typescript from 'rollup-plugin-typescript2';
import { nodeResolve } from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import pkg from './package.json';

export default [
  {
    input: 'src/index.ts',
    output: {
      file: pkg.module,
      format: 'esm',
      sourcemap: true
    },
    plugins: [
      typescript({
        tsconfig: './tsconfig.json',
        useTsconfigDeclarationDir: true
      }),
      nodeResolve(),
      commonjs()
    ],
    external: [...Object.keys(pkg.dependencies || {}), ...Object.keys(pkg.peerDependencies || {})]
  },
  {
    input: 'src/index.ts',
    output: {
      file: pkg.main,
      format: 'cjs',
      sourcemap: true
    },
    plugins: [
      typescript({
        tsconfig: './tsconfig.json',
        useTsconfigDeclarationDir: true
      }),
      nodeResolve(),
      commonjs()
    ],
    external: [...Object.keys(pkg.dependencies || {}), ...Object.keys(pkg.peerDependencies || {})]
  }
];
</file>

<file path="packages/plugin-commands/src/index.ts">
export { CommandPlugin } from './CommandPlugin';
export { CommandPluginEvents } from './types';
export type { Command, CommandPluginOptions, CommandProcessResult } from './types';
</file>

<file path="packages/plugin-commands/src/types.ts">
import { SceneKey, GameState, Effect } from '@pabitel/core';

/**
 * Reprezentuje textový příkaz pro interakci s herním světem
 */
export interface Command {
    /**
     * Vzory příkazů, které uživatel může zadat
     * Např. ['jít na sever', 'jdi severně', 'sever']
     */
    patterns: string[];

    /**
     * Volitelný klíč scény, na kterou se přejde po zpracování příkazu
     */
    scene?: SceneKey | ((state: GameState) => SceneKey);

    /**
     * Efekty, které se aplikují na stav hry po zpracování příkazu
     */
    effects?: Effect[];

    /**
     * Volitelná podmínka, která určuje, zda je příkaz dostupný
     */
    condition?: (state: GameState) => boolean;

    /**
     * Textová odpověď po zpracování příkazu
     */
    response?: string | ((state: GameState) => string);

    /**
     * Priorita příkazu při zpracování podobných příkazů
     * Vyšší číslo znamená vyšší prioritu
     */
    priority?: number;

    /**
     * Další metadata pro rozšíření funkcionality
     */
    metadata?: Record<string, any>;
}

/**
 * Nastavení pro CommandPlugin
 */
export interface CommandPluginOptions {
    /**
     * Nastavení pro Fuse.js
     * Hodnoty pro vyhledávání lze upravit pro lepší výsledky
     */
    fuseOptions?: {
        /**
         * Práh pro shodu (0-1, kde 0 znamená přesnou shodu)
         * Výchozí hodnota: 0.3
         */
        threshold?: number;

        /**
         * Ignorovat pozici nalezeného vzoru ve vstupu
         * Výchozí hodnota: true
         */
        ignoreLocation?: boolean;

        /**
         * Použít rozšířené vyhledávání
         * Výchozí hodnota: true
         */
        useExtendedSearch?: boolean;

        /**
         * Další hodnoty pro konfiguraci Fuse.js
         */
        [key: string]: any;
    };

    /**
     * Ignorovat velikost písmen při porovnávání příkazů
     * Výchozí hodnota: true
     */
    ignoreCase?: boolean;

    /**
     * Normalizovat diakritiku při porovnávání příkazů
     * Výchozí hodnota: true
     */
    normalizeDiacritics?: boolean;

    /**
     * Výchozí odpověď, pokud nebyl rozpoznán žádný příkaz
     * Může být statická nebo dynamická
     */
    defaultFallbackResponse?: string | ((input: string, state: GameState) => string);

    /**
     * Další možnosti pro rozšíření funkcionality
     */
    [key: string]: any;
}

/**
 * Typy událostí emitovaných CommandPluginem
 */
export enum CommandPluginEvents {
    COMMAND_PROCESSED = 'commands:commandProcessed',
    COMMAND_NOT_FOUND = 'commands:commandNotFound',
    AVAILABLE_COMMANDS = 'commands:availableCommands',
    COMMAND_HINTS = 'commands:commandHints'
}

/**
 * Rozšíření rozhraní Scene o příkazy
 */
declare module '@pabitel/core' {
    interface Scene {
        /**
         * Příkazy dostupné v této scéně
         */
        commands?: Command[];

        /**
         * Odpověď při zadání nerozpoznaného příkazu
         */
        fallbackResponse?: string | ((input: string, state: GameState) => string);

        /**
         * Nápověda dostupná v této scéně
         */
        hints?: string[] | ((state: GameState) => string[]);
    }
}

/**
 * Výsledek zpracování příkazu
 */
export interface CommandProcessResult {
    /**
     * Byl příkaz rozpoznán a zpracován
     */
    success: boolean;

    /**
     * Odpověď na příkaz
     */
    response?: string;

    /**
     * Rozpoznaný příkaz
     */
    command?: Command;

    /**
     * Detaily shody
     */
    matchDetails?: {
        /**
         * Skóre shody (0-1, kde 0 je přesná shoda)
         */
        score: number;

        /**
         * Rozpoznaný vzor
         */
        pattern: string;
    };
}
</file>

<file path="packages/plugin-commands/package.json">
{
  "name": "@pabitel/plugin-commands",
  "version": "0.1.0",
  "description": "Text command plugin for Pabitel.js",
  "license": "MIT",
  "main": "dist/index.js",
  "module": "dist/index.esm.js",
  "types": "dist/index.d.ts",
  "files": [
    "dist"
  ],
  "exports": {
    ".": {
      "import": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.esm.js"
      },
      "require": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.js"
      },
      "development": "./src/index.ts"
    },
    "./package.json": "./package.json"
  },
  "scripts": {
    "build": "tsc && rollup -c",
    "dev": "tsc --watch",
    "test": "jest",
    "lint": "eslint src --ext .ts",
    "lint:fix": "eslint src --ext .ts --fix",
    "format": "prettier --write \"src/**/*.ts\"",
    "format:check": "prettier --check \"src/**/*.ts\"",
    "prepublishOnly": "yarn lint && yarn test && yarn build"
  },
  "peerDependencies": {
    "@pabitel/core": "^0.1.0"
  },
  "devDependencies": {
    "@pabitel/core": "^0.1.0",
    "@rollup/plugin-commonjs": "^28.0.3",
    "@rollup/plugin-node-resolve": "^16.0.1",
    "@types/jest": "^29.5.14",
    "eslint": "^9",
    "jest": "^29.7.0",
    "prettier": "^3",
    "rollup": "^4",
    "rollup-plugin-typescript2": "^0.36.0",
    "ts-jest": "^29.3.1",
    "typescript": "^5.8.2"
  },
  "keywords": [
    "pabitel",
    "commands",
    "text-adventure",
    "plugin",
    "interactive-fiction"
  ],
  "author": "Jakub Hájek",
  "repository": {
    "type": "git",
    "url": "https://github.com/jimmyhayek/textgame.git"
  }
}
</file>

<file path="packages/plugin-commands/tsconfig.json">
// packages/plugin-commands/tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "declaration": true,
    "declarationDir": "./dist",
    "outDir": "./dist",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node"
  },
  "paths": {
    "@pabitel/core": ["../core/src"]
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "test", "examples"]
}
</file>

<file path=".gitignore">
.idea
node_modules
coverage
/e2e-tests/cypress/screenshots
/e2e-tests/cypress/videos
</file>

<file path="packages/core/src/content/index.ts">
// --- Types ---
export * from './types';

// --- Classes ---
export { GenericContentLoader } from './GenericContentLoader';
export { LoaderRegistry } from './LoaderRegistry';

// --- Utilities ---
export {
  createContentLoader,
  defineContent,
  defineScenes,
  mergeContentRegistries,
  generateContentKey,
  extractContentKeys,
  mapContentRegistry
} from './utils';
</file>

<file path="packages/core/src/content/LoaderRegistry.ts">
import { GenericContentLoader } from './GenericContentLoader';

/**
 * Manages multiple `GenericContentLoader` instances, organized by content type.
 * Provides a central point for registering and accessing loaders for different
 * kinds of game content (e.g., 'scenes', 'items', 'audio').
 */
export class LoaderRegistry {
  /** Map storing GenericContentLoader instances, keyed by content type identifier (string). */
  private loaders: Map<string, GenericContentLoader<any, any>> = new Map();
  // Note: `any` is used here because the registry holds loaders for various unknown `T` types.
  // Type safety is enforced when retrieving a specific loader using `getLoader<T, K>`.

  /**
   * Registers a specific `GenericContentLoader` instance for a given content type.
   * If a loader for this type already exists, it will be overwritten.
   *
   * @template T The type of content handled by the loader.
   * @template K The type of the content identifier key.
   * @param type A string identifying the type of content (e.g., 'scenes', 'items').
   * @param loader The `GenericContentLoader` instance to register.
   * @returns The `LoaderRegistry` instance for method chaining.
   */
  public registerLoader<T extends object, K extends string = string>(
      type: string,
      loader: GenericContentLoader<T, K>
  ): this { // Return `this` for chaining
    this.loaders.set(type, loader);
    return this;
  }

  /**
   * Retrieves the `GenericContentLoader` instance for a specific content type.
   * Returns `undefined` if no loader is registered for the given type.
   *
   * @template T The expected type of content handled by the loader.
   * @template K The expected type of the content identifier key.
   * @param type The string identifying the type of content.
   * @returns The `GenericContentLoader` instance for the specified type, or `undefined`.
   */
  public getLoader<T extends object, K extends string = string>(
      type: string
  ): GenericContentLoader<T, K> | undefined {
    // Cast is necessary due to the `any` type in the internal `loaders` map.
    // The caller is responsible for providing the correct T and K.
    return this.loaders.get(type) as GenericContentLoader<T, K> | undefined;
  }

  /**
   * Checks if a loader is registered for a specific content type.
   *
   * @param type The string identifying the type of content.
   * @returns `true` if a loader for the type exists, `false` otherwise.
   */
  public hasLoader(type: string): boolean {
    return this.loaders.has(type);
  }

  /**
   * Gets an array of all registered content type identifiers.
   *
   * @returns An array of strings representing the registered content types.
   */
  public getContentTypes(): string[] {
    return Array.from(this.loaders.keys());
  }

  /**
   * Removes the loader associated with a specific content type.
   *
   * @param type The string identifying the type of content whose loader should be removed.
   * @returns `true` if a loader was successfully removed, `false` if no loader was found for the type.
   */
  public removeLoader(type: string): boolean {
    return this.loaders.delete(type);
  }
}
</file>

<file path="packages/core/src/effect/types.ts">
import { GameState } from '../state/types';

/**
 * Výčet typů vestavěných efektů
 */
export enum BuiltInEffectType {
  set = 'set',
  increment = 'increment',
  decrement = 'decrement',
  multiply = 'multiply',
  divide = 'divide',
  toggle = 'toggle',

  // Efekty pro pole
  push = 'push',
  remove = 'remove',

  // Kompozitní efekty
  batch = 'batch',
  sequence = 'sequence',
  conditional = 'conditional',
  repeat = 'repeat',
}

/**
 * Typ pro identifikaci efektu (může být vestavěný nebo vlastní)
 */
export type EffectType = BuiltInEffectType | string;

/**
 * Základní rozhraní pro všechny efekty
 */
export interface Effect {
  /**
   * Typ efektu
   */
  type: EffectType;

  /**
   * Indexová signatura pro další vlastnosti
   */
  [key: string]: any;
}

/**
 * Funkce pro zpracování efektu
 */
export type EffectProcessor = (effect: Effect, draftState: GameState) => void;

/**
 * Rozhraní pro efekt z pluginu
 */
export interface PluginEffect extends Effect {
  /**
   * Jmenný prostor pluginu
   */
  namespace: string;
}

// Rozhraní pro kompozitní efekty

/**
 * Efekt pro aplikaci více efektů najednou
 */
export interface BatchEffect extends Effect {
  type: BuiltInEffectType.batch;
  /**
   * Pole efektů k aplikaci
   */
  effects: Effect[];
}

/**
 * Efekt pro sekvenční aplikaci efektů
 */
export interface SequenceEffect extends Effect {
  type: BuiltInEffectType.sequence;
  /**
   * Pole efektů k sekvenční aplikaci
   */
  effects: Effect[];
}

/**
 * Efekt pro podmíněnou aplikaci efektů
 */
export interface ConditionalEffect extends Effect {
  type: BuiltInEffectType.conditional;
  /**
   * Podmínka, která určuje, zda se efekty aplikují
   */
  condition: (state: GameState) => boolean;
  /**
   * Efekty aplikované, pokud je podmínka splněna
   */
  thenEffects: Effect[];
  /**
   * Efekty aplikované, pokud podmínka není splněna
   */
  elseEffects?: Effect[];
}

/**
 * Efekt pro opakování jiného efektu
 */
export interface RepeatEffect extends Effect {
  type: BuiltInEffectType.repeat;
  /**
   * Počet opakování nebo funkce, která vrátí počet opakování
   */
  count: number | ((state: GameState) => number);
  /**
   * Efekt, který se bude opakovat
   */
  effect: Effect;
}

// Rozhraní pro efekty proměnných

/**
 * Základní efekt pro operace s proměnnými
 */
export interface VariableEffect extends Effect {
  /**
   * Název proměnné
   */
  variable: string;
  /**
   * Volitelná cesta k vlastnosti (pro nested properties)
   */
  path?: string;
}

/**
 * Efekt pro nastavení hodnoty proměnné
 */
export interface SetVariableEffect extends VariableEffect {
  type: BuiltInEffectType.set;
  /**
   * Hodnota k nastavení
   */
  value: any;
}

/**
 * Efekt pro zvýšení hodnoty proměnné
 */
export interface IncrementVariableEffect extends VariableEffect {
  type: BuiltInEffectType.increment;
  /**
   * Hodnota k přičtení (výchozí: 1)
   */
  value?: number;
}

/**
 * Efekt pro snížení hodnoty proměnné
 */
export interface DecrementVariableEffect extends VariableEffect {
  type: BuiltInEffectType.decrement;
  /**
   * Hodnota k odečtení (výchozí: 1)
   */
  value?: number;
}

/**
 * Efekt pro násobení hodnoty proměnné
 */
export interface MultiplyVariableEffect extends VariableEffect {
  type: BuiltInEffectType.multiply;
  /**
   * Hodnota, kterou se proměnná vynásobí
   */
  value: number;
}

/**
 * Efekt pro dělení hodnoty proměnné
 */
export interface DivideVariableEffect extends VariableEffect {
  type: BuiltInEffectType.divide;
  /**
   * Hodnota, kterou se proměnná vydělí
   */
  value: number;
}

/**
 * Efekt pro přepnutí hodnoty proměnné (boolean toggle)
 */
export interface ToggleVariableEffect extends VariableEffect {
  type: BuiltInEffectType.toggle;
}

// Rozhraní pro efekty na polích

/**
 * Základní efekt pro operace s poli
 */
export interface ArrayEffect extends Effect {
  /**
   * Název pole
   */
  array: string;
  /**
   * Volitelná cesta k vlastnosti (pro nested properties)
   */
  path?: string;
}

/**
 * Efekt pro přidání hodnoty do pole
 */
export interface PushToArrayEffect extends ArrayEffect {
  type: BuiltInEffectType.push;
  /**
   * Hodnota k přidání do pole
   */
  value: any;
}

/**
 * Efekt pro odstranění hodnoty z pole
 */
export interface RemoveFromArrayEffect extends ArrayEffect {
  type: BuiltInEffectType.remove;
  /**
   * Hodnota k odstranění
   */
  value: any;
  /**
   * Zda se má odstranit podle indexu nebo hodnoty
   */
  byIndex?: boolean;
  /**
   * Volitelná funkce pro porovnání objektů
   */
  equalityFn?: (a: any, b: any) => boolean;
}
</file>

<file path="packages/core/src/engine/index.ts">
// Export typů
export * from './types';

// Export hlavních tříd
export { GameEngine } from './GameEngine';

// Export utilit
export { createGameEngine } from './utils';
</file>

<file path="packages/core/src/event/types.ts">
/**
 * Typ pro callback funkci posluchače události
 * Přijímá data události (typ 'any' pro obecný emitter, specifický typ pro TypedEventEmitter)
 */
export type EventListener = (data: any) => void;

/**
 * Typ pro identifikátor události
 * Může být řetězec nebo symbol. Zde používáme string.
 */
export type GameEventType = string;

/**
 * Možnosti pro konfiguraci EventEmitter
 */
export interface EventEmitterOptions {
  /**
   * Zachytávat chyby v posluchačích událostí
   * Výchozí: true
   */
  catchErrors?: boolean;

  /**
   * Maximální počet posluchačů na jeden typ události
   * Výchozí: 10
   */
  maxListeners?: number;
}

/**
 * Data předávaná při události změny scény (patří spíše do scene/types nebo engine/types)
 */
export interface SceneChangedEventData {
  scene: any; // Mělo by být importováno z scene/types
  sceneKey: string; // Mělo by být SceneKey z scene/types
  previousScene?: any;
  previousSceneKey?: string;
  transitionData?: any;
}

/**
 * Data předávaná při události startu hry (patří spíše do engine/types)
 */
export interface GameStartedEventData {
  sceneKey: string; // Mělo by být SceneKey z scene/types
  transitionData?: any;
}

/**
 * Data předávaná při události konce hry (patří spíše do engine/types)
 */
export interface GameEndedEventData {
  reason?: string;
  stats?: Record<string, any>; // nebo specifický typ
}

/**
 * Data předávaná při události aplikace efektu (patří spíše do engine/types nebo effect/types)
 */
export interface EffectAppliedEventData {
  effect: any; // Mělo by být Effect z effect/types
  previousState: any; // Mělo by být GameState
  newState: any; // Mělo by být GameState
}
</file>

<file path="packages/core/src/plugin/index.ts">
// Export typů
export * from './types';

// Export hlavních tříd
export { PluginManager } from './PluginManager';
export { AbstractPlugin } from './AbstractPlugin';

// Export konstant
export const CORE_PLUGIN_EVENTS = {
  REGISTERED: 'plugin:registered',
  UNREGISTERED: 'plugin:unregistered',
  INITIALIZED: 'plugin:initialized',
  ERROR: 'plugin:error',
} as const;

// Export utilit
export {
  createPlugin,
  createCompositePlugin,
  createLazyPlugin,
  createConditionalPlugin,
  createVersionedPlugin,
  createDebouncedPlugin,
} from './utils';
</file>

<file path="packages/core/src/plugin/PluginManager.ts">
import { EventEmitter } from '../event/EventEmitter';
import {
  Plugin,
  PluginRegistryOptions,
  PluginEvents,
  PluginRegisteredEventData,
  PluginUnregisteredEventData,
  PluginInitializedEventData,
  PluginErrorEventData,
} from './types';
import { GameEngine } from '../engine/GameEngine';

/**
 * Správce pluginů pro herní engine
 *
 * Zodpovídá za registraci, inicializaci a správu pluginů
 * připojených k hernímu enginu.
 */
export class PluginManager {
  /**
   * Reference na herní engine
   */
  private engine: GameEngine;

  /**
   * Mapa registrovaných pluginů podle názvu
   */
  private plugins: Map<string, Plugin> = new Map();

  /**
   * Množina aktivních (inicializovaných) pluginů
   */
  private activePlugins: Set<string> = new Set();

  /**
   * Event emitter pro události pluginů
   */
  private eventEmitter: EventEmitter;

  /**
   * Možnosti konfigurace manažeru pluginů
   */
  private options: PluginRegistryOptions;

  /**
   * Vytvoří novou instanci PluginManager
   *
   * @param engine Reference na herní engine
   * @param eventEmitter Event emitter pro události
   * @param options Možnosti konfigurace
   */
  constructor(engine: GameEngine, eventEmitter: EventEmitter, options: PluginRegistryOptions = {}) {
    this.engine = engine;
    this.eventEmitter = eventEmitter;
    this.options = {
      autoActivate: true,
      allowOverride: false,
      ...options,
    };
  }

  /**
   * Registruje plugin v herním enginu
   *
   * @param plugin Plugin k registraci
   * @param activate Zda aktivovat plugin ihned po registraci
   * @returns Promise který se vyřeší na true, pokud byl plugin úspěšně registrován
   */
  public async registerPlugin(plugin: Plugin, activate?: boolean): Promise<boolean> {
    const shouldActivate = activate ?? this.options.autoActivate;

    // Kontrola, zda plugin s tímto názvem již existuje
    if (this.plugins.has(plugin.name) && !this.options.allowOverride) {
      console.warn(`Plugin with name '${plugin.name}' is already registered.`);
      return false;
    }

    // Registrace pluginu
    this.plugins.set(plugin.name, plugin);

    // Emitování události registrace
    this.eventEmitter.emit(PluginEvents.REGISTERED, {
      name: plugin.name,
      plugin,
    } as PluginRegisteredEventData);

    // Aktivace pluginu, pokud je požadováno
    if (shouldActivate) {
      return await this.activatePlugin(plugin.name);
    }

    return true;
  }

  /**
   * Registruje více pluginů najednou
   *
   * @param plugins Pole pluginů k registraci
   * @param activate Zda aktivovat pluginy ihned po registraci
   * @returns Promise který se vyřeší na počet úspěšně registrovaných pluginů
   */
  public async registerPlugins(plugins: Plugin[], activate?: boolean): Promise<number> {
    let successCount = 0;

    for (const plugin of plugins) {
      const success = await this.registerPlugin(plugin, activate);
      if (success) {
        successCount++;
      }
    }

    return successCount;
  }

  /**
   * Aktivuje registrovaný plugin
   *
   * @param pluginName Název pluginu k aktivaci
   * @returns Promise který se vyřeší na true, pokud byl plugin úspěšně aktivován
   */
  public async activatePlugin(pluginName: string): Promise<boolean> {
    const plugin = this.plugins.get(pluginName);

    if (!plugin) {
      console.warn(`Plugin with name '${pluginName}' is not registered.`);
      return false;
    }

    // Pokud je plugin již aktivní, vrátíme true
    if (this.activePlugins.has(pluginName)) {
      return true;
    }

    // Inicializace pluginu
    try {
      await Promise.resolve(plugin.initialize(this.engine));

      // Označení pluginu jako aktivního
      this.activePlugins.add(pluginName);

      // Emitování události inicializace
      this.eventEmitter.emit(PluginEvents.INITIALIZED, {
        name: pluginName,
        plugin,
      } as PluginInitializedEventData);

      console.log(`Plugin '${pluginName}' successfully initialized.`);
      return true;
    } catch (error) {
      // Emitování události chyby
      this.eventEmitter.emit(PluginEvents.ERROR, {
        name: pluginName,
        plugin,
        error,
        phase: 'initialize',
      } as PluginErrorEventData);

      console.error(`Error initializing plugin '${pluginName}':`, error);
      return false;
    }
  }

  /**
   * Deaktivuje aktivní plugin
   *
   * @param pluginName Název pluginu k deaktivaci
   * @returns Promise který se vyřeší na true, pokud byl plugin úspěšně deaktivován
   */
  public async deactivatePlugin(pluginName: string): Promise<boolean> {
    const plugin = this.plugins.get(pluginName);

    if (!plugin) {
      console.warn(`Plugin with name '${pluginName}' is not registered.`);
      return false;
    }

    // Pokud plugin není aktivní, vrátíme true
    if (!this.activePlugins.has(pluginName)) {
      return true;
    }

    // Volání destroy metody pluginu, pokud existuje
    if (plugin.destroy) {
      try {
        await Promise.resolve(plugin.destroy());
      } catch (error) {
        // Emitování události chyby
        this.eventEmitter.emit(PluginEvents.ERROR, {
          name: pluginName,
          plugin,
          error,
          phase: 'destroy',
        } as PluginErrorEventData);

        console.error(`Error destroying plugin '${pluginName}':`, error);
        return false;
      }
    }

    // Odstranění pluginu ze seznamu aktivních
    this.activePlugins.delete(pluginName);

    return true;
  }

  /**
   * Odregistruje plugin z herního enginu
   *
   * @param pluginName Název pluginu k odregistrování
   * @returns Promise který se vyřeší na true, pokud byl plugin úspěšně odregistrován
   */
  public async unregisterPlugin(pluginName: string): Promise<boolean> {
    const plugin = this.plugins.get(pluginName);

    if (!plugin) {
      console.warn(`Plugin with name '${pluginName}' is not registered.`);
      return false;
    }

    // Nejprve deaktivujeme plugin, pokud je aktivní
    if (this.activePlugins.has(pluginName)) {
      const success = await this.deactivatePlugin(pluginName);
      if (!success) {
        return false;
      }
    }

    // Odregistrace pluginu
    this.plugins.delete(pluginName);

    // Emitování události odregistrace
    this.eventEmitter.emit(PluginEvents.UNREGISTERED, {
      name: pluginName,
    } as PluginUnregisteredEventData);

    console.log(`Plugin '${pluginName}' successfully unregistered.`);
    return true;
  }

  /**
   * Získá plugin podle názvu
   *
   * @template T Typ očekávaného pluginu
   * @param pluginName Název pluginu
   * @returns Plugin daného typu nebo undefined pokud plugin nebyl nalezen
   */
  public getPlugin<T extends Plugin = Plugin>(pluginName: string): T | undefined {
    return this.plugins.get(pluginName) as T | undefined;
  }

  /**
   * Vrátí názvy všech registrovaných pluginů
   *
   * @returns Pole názvů registrovaných pluginů
   */
  public getPluginNames(): string[] {
    return Array.from(this.plugins.keys());
  }

  /**
   * Vrátí všechny registrované pluginy
   *
   * @returns Pole registrovaných pluginů
   */
  public getAllPlugins(): Plugin[] {
    return Array.from(this.plugins.values());
  }

  /**
   * Vrátí názvy všech aktivních pluginů
   *
   * @returns Pole názvů aktivních pluginů
   */
  public getActivePluginNames(): string[] {
    return Array.from(this.activePlugins);
  }

  /**
   * Vrátí všechny aktivní pluginy
   *
   * @returns Pole aktivních pluginů
   */
  public getActivePlugins(): Plugin[] {
    return Array.from(this.activePlugins).map(name => this.plugins.get(name)!);
  }

  /**
   * Kontroluje, zda je plugin registrován
   *
   * @param pluginName Název pluginu
   * @returns True pokud je plugin registrován, jinak false
   */
  public hasPlugin(pluginName: string): boolean {
    return this.plugins.has(pluginName);
  }

  /**
   * Kontroluje, zda je plugin aktivní
   *
   * @param pluginName Název pluginu
   * @returns True pokud je plugin aktivní, jinak false
   */
  public isPluginActive(pluginName: string): boolean {
    return this.activePlugins.has(pluginName);
  }

  /**
   * Vrátí počet registrovaných pluginů
   *
   * @returns Počet registrovaných pluginů
   */
  public getPluginCount(): number {
    return this.plugins.size;
  }

  /**
   * Vrátí počet aktivních pluginů
   *
   * @returns Počet aktivních pluginů
   */
  public getActivePluginCount(): number {
    return this.activePlugins.size;
  }

  /**
   * Deaktivuje všechny aktivní pluginy
   *
   * @returns Promise který se vyřeší, když jsou všechny pluginy deaktivovány
   */
  public async deactivateAllPlugins(): Promise<void> {
    const activePluginNames = Array.from(this.activePlugins);

    for (const pluginName of activePluginNames) {
      await this.deactivatePlugin(pluginName);
    }
  }

  /**
   * Nastaví novou instanci enginu pro všechny pluginy
   * Použije se například při resetování či restartování enginu
   *
   * @param engine Nová instance herního enginu
   */
  public setEngine(engine: GameEngine): void {
    this.engine = engine;

    // Reinicializace všech aktivních pluginů s novým enginem
    this.resetPlugins();
  }

  /**
   * Resetuje všechny aktivní pluginy
   * Deaktivuje všechny pluginy a znovu je aktivuje
   *
   * @returns Promise který se vyřeší na true, pokud byly všechny pluginy úspěšně resetovány
   */
  public async resetPlugins(): Promise<boolean> {
    const activePluginNames = Array.from(this.activePlugins);

    // Deaktivujeme všechny pluginy
    await this.deactivateAllPlugins();

    // Opět aktivujeme všechny pluginy, které byly aktivní
    let allSuccessful = true;
    for (const pluginName of activePluginNames) {
      const success = await this.activatePlugin(pluginName);
      if (!success) {
        allSuccessful = false;
      }
    }

    return allSuccessful;
  }
}
</file>

<file path="packages/core/src/save/index.ts">
// Export typů
export * from './types';

// Export hlavních tříd
export { SaveManager } from './SaveManager';
export { MemoryStorage } from './MemoryStorage';

// Export utilit
export {
  createSaveManager,
  validateSaveData,
  generateSaveId,
  formatPlayTime,
  exportSaveToFile,
  importSaveFromFile,
} from './utils';
</file>

<file path="packages/core/src/state/persistence/StateConverter.ts">
import { GameState } from '../types';
import {
  PersistedState,
  StateMetadata,
  SerializationOptions,
  StateManagerPersistenceEvents,
} from './types';
import { StateMigrationService } from './StateMigrationService';
import { TypedEventEmitter } from '../../event/TypedEventEmitter'; // Zkontroluj název souboru/třídy

/**
 * Služba zodpovědná za převod mezi runtime GameState a serializovatelnou PersistedState a zpět.
 */
export class StateConverter {
  private constructor() {}

  public static serialize<T extends Record<string, unknown>>(
    state: GameState<T>,
    persistentKeys: string[],
    options: SerializationOptions = {},
    onBeforeSerializeCallback?: (state: GameState<T>) => void,
    // Přijímá typovaný emitter
    eventEmitter?: TypedEventEmitter<StateManagerPersistenceEvents<T>>
  ): string {
    const { includeMetadata = true, replacer } = options;

    if (onBeforeSerializeCallback) {
      try {
        onBeforeSerializeCallback(state);
      } catch (error) {
        console.error('Error in onBeforeSerialize callback:', error);
        // Pokračovat v serializaci i přes chybu v callbacku? Záleží na požadavcích.
      }
    }

    eventEmitter?.emit('beforeSerialize', { state });

    const serializableState: PersistedState<T> = {} as PersistedState<T>;

    for (const key of persistentKeys) {
      if (key in state) {
        const value = (state as any)[key];
        if (key === 'visitedScenes') {
          serializableState.visitedScenes = this.convertSetToArray(value);
        } else if (key === 'variables') {
          serializableState.variables = value as T;
        } else {
          (serializableState as any)[key] = value;
        }
      } else {
        console.warn(
          `StateConverter: Persistent key '${key}' not found in GameState during serialization.`
        );
      }
    }

    if (includeMetadata) {
      serializableState._metadata = this.createStateMetadata();
    }

    try {
      return JSON.stringify(serializableState, replacer);
    } catch (error) {
      console.error('StateConverter: Failed to stringify serializable state.', error);
      throw new Error('Failed to serialize state to JSON');
    }
  }

  public static deserialize<T extends Record<string, unknown>>(
    serializedState: string,
    options: SerializationOptions = {},
    onAfterDeserializeCallback?: (state: GameState<T>) => void, // Stále zde, ale volá se z GameStateManageru
    // Přijímá typovaný emitter
    eventEmitter?: TypedEventEmitter<StateManagerPersistenceEvents<T>>
  ): PersistedState<T> {
    let parsedState: PersistedState<unknown>;
    try {
      parsedState = JSON.parse(serializedState) as PersistedState<unknown>;
    } catch (error) {
      console.error('StateConverter: Failed to parse serialized state string.', error);
      throw new Error('Invalid serialized state format');
    }

    const targetVersion = StateMigrationService.getCurrentStateFormatVersion();
    let migratedState: PersistedState<unknown>;
    try {
      // Předání typovaného emitteru migraci
      migratedState = StateMigrationService.migrate(
        parsedState,
        targetVersion,
        // StateMigrationService očekává emitter pro <unknown>
        eventEmitter as TypedEventEmitter<StateManagerPersistenceEvents<unknown>> | undefined
      );
    } catch (error) {
      console.error(`StateConverter: Failed to migrate state to version ${targetVersion}.`, error);
      throw error;
    }

    // Emitování události po deserializaci a migraci
    eventEmitter?.emit('afterDeserialize', { state: migratedState as PersistedState<T> });

    // Callback onAfterDeserialize se už zde nevolá, volá ho GameStateManager.applyPersistentState

    return migratedState as PersistedState<T>;
  }

  private static createStateMetadata(): StateMetadata {
    return {
      version: StateMigrationService.getCurrentStateFormatVersion(),
      timestamp: Date.now(),
    };
  }

  private static convertSetToArray(setOrArray: Set<string> | string[] | undefined): string[] {
    if (setOrArray instanceof Set) {
      return Array.from(setOrArray);
    }
    if (Array.isArray(setOrArray)) {
      return setOrArray;
    }
    if (setOrArray !== undefined && setOrArray !== null) {
      console.warn(
        'StateConverter: Expected Set<string> or Array<string> for visitedScenes, received',
        typeof setOrArray
      );
    }
    return [];
  }
}
</file>

<file path="packages/core/src/state/persistence/StateMigrationService.ts">
import {
  PersistedState,
  StateMetadata,
  StateMigrationFn,
  StateManagerPersistenceEvents,
} from './types';
import { TypedEventEmitter } from '../../event/TypedEventEmitter'; // Zkontroluj název souboru/třídy

const CURRENT_STATE_FORMAT_VERSION = 1;

/**
 * Služba zodpovědná za správu a aplikaci migračních funkcí pro persistovaný stav.
 */
export class StateMigrationService {
  private static migrations = new Map<number, StateMigrationFn>();
  private constructor() {}

  public static registerMigration(
    fromVersion: number,
    migrationFn: StateMigrationFn
  ): () => boolean {
    if (StateMigrationService.migrations.has(fromVersion)) {
      console.warn(
        `StateMigrationService: Migration for version ${fromVersion} is already registered. Overwriting.`
      );
    }
    StateMigrationService.migrations.set(fromVersion, migrationFn);
    return () => StateMigrationService.unregisterMigration(fromVersion);
  }

  public static unregisterMigration(fromVersion: number): boolean {
    return StateMigrationService.migrations.delete(fromVersion);
  }

  public static getCurrentStateFormatVersion(): number {
    return CURRENT_STATE_FORMAT_VERSION;
  }

  public static migrate(
    state: PersistedState<unknown>,
    targetVersion: number = CURRENT_STATE_FORMAT_VERSION,
    // Přijímá typovaný emitter pro <unknown>
    eventEmitter?: TypedEventEmitter<StateManagerPersistenceEvents<unknown>>
  ): PersistedState<unknown> {
    let migratedState = state; // Pracujeme s referencí, migrační funkce by měly být čisté nebo pracovat s kopiemi

    if (!migratedState._metadata) {
      console.warn('StateMigrationService: State is missing _metadata. Assuming version 0.');
      migratedState._metadata = { version: 0, timestamp: Date.now() };
    }

    let currentStateVersion = migratedState._metadata.version;

    if (currentStateVersion >= targetVersion) {
      if (currentStateVersion > targetVersion) {
        console.warn(
          `StateMigrationService: State version (${currentStateVersion}) is higher than target version (${targetVersion}). No migration applied.`
        );
      }
      // No migration needed if versions match
      return migratedState;
    }

    console.log(
      `StateMigrationService: Migrating state from version ${currentStateVersion} to ${targetVersion}`
    );

    for (let v = currentStateVersion; v < targetVersion; v++) {
      const migrationFn = StateMigrationService.migrations.get(v);

      if (migrationFn) {
        console.log(`StateMigrationService: Applying migration from version ${v} to ${v + 1}`);
        try {
          // Migrační funkce může modifikovat migratedState nebo vrátit nový
          migratedState = migrationFn(migratedState, v, v + 1);

          // Aktualizace verze v metadatech migrovaného stavu
          if (!migratedState._metadata) {
            // Mělo by být vytvořeno v prvním kroku, pokud chybělo
            migratedState._metadata = { version: v + 1, timestamp: Date.now() };
          } else {
            migratedState._metadata.version = v + 1;
          }

          // Emitování události
          eventEmitter?.emit('migrationApplied', {
            fromVersion: v,
            toVersion: v + 1,
            state: migratedState, // Emitujeme stav po aplikaci kroku
          });
        } catch (migrationError) {
          console.error(
            `StateMigrationService: Migration from version ${v} to ${v + 1} failed:`,
            migrationError
          );
          throw migrationError;
        }
      } else {
        const errorMsg = `StateMigrationService: Missing migration function for version ${v} to ${v + 1}`;
        console.error(errorMsg);
        throw new Error(errorMsg);
      }
    }

    console.log(
      `StateMigrationService: Migration complete. State is now version ${targetVersion}.`
    );
    return migratedState;
  }
}
</file>

<file path="packages/core/src/state/GameStateManager.ts">
import {
  GameState,
  GameStateManagerOptions,
  DEFAULT_PERSISTENT_KEYS,
  StateChangedEvent,
  GameStateManagerEvents, // Importuj typ pro mapu událostí
} from './types';
import { PersistedState } from './persistence/types';
import { produce } from '../utils/immer';
import { TypedEventEmitter } from '../event/TypedEventEmitter';
import { validateState } from './utils';
import { GameEngine } from '../engine/GameEngine'; // Importuj GameEngine

/**
 * Spravuje herní stav s důrazem na neměnnost.
 * @template T Typ proměnných ve stavu
 */
export class GameStateManager<T extends Record<string, unknown> = Record<string, unknown>> {
  private state: GameState<T>;
  private persistentKeys: string[];
  // Emitter specifický pro události tohoto manažeru
  private readonly eventEmitter: TypedEventEmitter<GameStateManagerEvents<T>>;
  private onBeforeSerialize?: (state: GameState<T>) => void;
  private onAfterDeserialize?: (state: GameState<T>) => void;

  /**
   * Vytvoří novou instanci GameStateManager.
   * @param engine Instance GameEngine pro získání typovaného emitteru.
   * @param options Možnosti konfigurace GameStateManageru.
   */
  constructor(engine: GameEngine, options: GameStateManagerOptions<T> = {}) {
    this.state = this.createInitialState(options.initialState || {});
    this.persistentKeys = Array.isArray(options.persistentKeys)
      ? [...options.persistentKeys]
      : [...DEFAULT_PERSISTENT_KEYS];

    // Získání specifického emitteru z enginu
    this.eventEmitter = engine.getStateManagerEventEmitter<T>();

    this.onBeforeSerialize = options.onBeforeSerialize;
    this.onAfterDeserialize = options.onAfterDeserialize;
    this.ensureDefaultPersistentKeys();
  }

  private ensureDefaultPersistentKeys(): void {
    if (!this.persistentKeys.includes('visitedScenes')) {
      this.persistentKeys.push('visitedScenes');
    }
    if (!this.persistentKeys.includes('variables')) {
      this.persistentKeys.push('variables');
    }
  }

  private createInitialState(initialState: Partial<GameState<T>>): GameState<T> {
    const baseState: GameState<T> = {
      visitedScenes: new Set<string>(),
      variables: {} as T,
    };
    const state = { ...baseState, ...initialState } as GameState<T>;

    if (!(state.visitedScenes instanceof Set)) {
      console.warn(
        'GameStateManager: Initial state for visitedScenes was not a Set. Converting to Set.'
      );
      state.visitedScenes = new Set(Array.isArray(state.visitedScenes) ? state.visitedScenes : []);
    }
    if (typeof state.variables !== 'object' || state.variables === null) {
      console.warn(
        'GameStateManager: Initial state for variables was not an object. Initializing as empty object.'
      );
      state.variables = {} as T;
    }
    return state;
  }

  public getState(): GameState<T> {
    return this.state;
  }

  public updateState(updater: (state: GameState<T>) => void, source?: string): void {
    const previousState = this.state;
    this.state = produce(this.state, (draft: GameState<T>) => {
      updater(draft);
    });
    if (this.state !== previousState) {
      this.emitStateChanged(previousState, this.state, source || 'update');
    }
  }

  public setState(newState: GameState<T>, source?: string): void {
    if (!validateState(newState)) {
      console.error('GameStateManager: Attempted to set invalid state.', newState);
      throw new Error('Attempted to set invalid state.');
    }
    const previousState = this.state;
    this.state = newState;
    this.emitStateChanged(previousState, this.state, source || 'setState');
  }

  public applyPersistentState(persistedStateData: PersistedState<T>, source?: string): void {
    const previousState = this.state;
    const newState: GameState<T> = {
      visitedScenes: new Set(
        Array.isArray(persistedStateData.visitedScenes) ? persistedStateData.visitedScenes : []
      ),
      variables: (typeof persistedStateData.variables === 'object' &&
      persistedStateData.variables !== null
        ? persistedStateData.variables
        : {}) as T,
    } as GameState<T>;

    for (const key of this.persistentKeys) {
      if (key === 'visitedScenes' || key === 'variables') continue;
      if (key in persistedStateData && key !== '_metadata') {
        (newState as any)[key] = (persistedStateData as any)[key];
      }
    }

    this.state = newState;

    if (this.onAfterDeserialize) {
      try {
        this.onAfterDeserialize(this.state);
      } catch (error) {
        console.error('Error in onAfterDeserialize callback:', error);
      }
    }

    this.emitStateChanged(previousState, this.state, source || 'applyPersistentState');
  }

  public resetState(options: Partial<GameState<T>> = {}): void {
    const previousState = this.state;
    this.state = this.createInitialState(options);
    this.emitStateChanged(previousState, this.state, 'reset');
  }

  public mergeState(externalState: Partial<GameState<T>>): void {
    this.updateState(state => {
      if (externalState.visitedScenes) {
        const scenesToAdd =
          externalState.visitedScenes instanceof Set
            ? externalState.visitedScenes
            : Array.isArray(externalState.visitedScenes)
              ? new Set(externalState.visitedScenes)
              : [];
        for (const sceneKey of scenesToAdd) {
          state.visitedScenes.add(sceneKey);
        }
      }
      if (externalState.variables && typeof externalState.variables === 'object') {
        Object.assign(state.variables, externalState.variables);
      }
      for (const key in externalState) {
        if (
          Object.prototype.hasOwnProperty.call(externalState, key) &&
          key !== 'visitedScenes' &&
          key !== 'variables'
        ) {
          (state as any)[key] = (externalState as any)[key];
        }
      }
    }, 'mergeState');
  }

  public getVariable<K extends keyof T>(name: K, defaultValue?: T[K]): T[K] | undefined {
    return this.state.variables[name] ?? defaultValue;
  }

  public setVariable<K extends keyof T>(name: K, value: T[K]): void {
    this.updateState(state => {
      state.variables[name] = value;
    }, 'setVariable');
  }

  public hasVariable<K extends keyof T>(name: K): boolean {
    return this.state.variables[name] !== undefined;
  }

  public removeVariable<K extends keyof T>(name: K): void {
    this.updateState(state => {
      delete state.variables[name];
    }, 'removeVariable');
  }

  public markSceneVisited(sceneKey: string): void {
    this.updateState(state => {
      state.visitedScenes.add(sceneKey);
    }, 'markSceneVisited');
  }

  public unmarkSceneVisited(sceneKey: string): void {
    this.updateState(state => {
      state.visitedScenes.delete(sceneKey);
    }, 'unmarkSceneVisited');
  }

  public clearVisitedScenes(): void {
    this.updateState(state => {
      state.visitedScenes.clear();
    }, 'clearVisitedScenes');
  }

  public hasVisitedScene(sceneKey: string): boolean {
    return this.state.visitedScenes.has(sceneKey);
  }

  public getVisitedScenesCount(): number {
    return this.state.visitedScenes.size;
  }

  public setPersistentKeys(keys: string[]): void {
    this.persistentKeys = Array.isArray(keys) ? [...keys] : [];
    this.ensureDefaultPersistentKeys();
    this.eventEmitter.emit('persistentKeysChanged', { keys: [...this.persistentKeys] });
  }

  public getPersistentKeys(): string[] {
    return [...this.persistentKeys];
  }

  public addPersistentKey(key: string): void {
    if (typeof key !== 'string' || key.length === 0) return;
    if (!this.persistentKeys.includes(key)) {
      this.persistentKeys = [...this.persistentKeys, key];
      this.eventEmitter.emit('persistentKeysChanged', { keys: [...this.persistentKeys] });
    }
  }

  public removePersistentKey(key: string): void {
    if (typeof key !== 'string' || key.length === 0) return;
    if (key === 'visitedScenes' || key === 'variables') {
      console.warn(`GameStateManager: Cannot remove default persistent key "${key}".`);
      return;
    }
    const index = this.persistentKeys.indexOf(key);
    if (index !== -1) {
      this.persistentKeys = [
        ...this.persistentKeys.slice(0, index),
        ...this.persistentKeys.slice(index + 1),
      ];
      this.eventEmitter.emit('persistentKeysChanged', { keys: [...this.persistentKeys] });
    }
  }

  private emitStateChanged(
    previousState: GameState<T> | null,
    newState: GameState<T>,
    source?: string
  ): void {
    const eventData: StateChangedEvent<T> = { previousState, newState, source };
    this.eventEmitter.emit('stateChanged', eventData);
  }

  // Veřejné on/off metody pro naslouchání na události GameStateManageru
  public on<K extends keyof GameStateManagerEvents<T>>(
    event: K,
    listener: (data: GameStateManagerEvents<T>[K]) => void
  ): void {
    this.eventEmitter.on(event, listener);
  }

  public off<K extends keyof GameStateManagerEvents<T>>(
    event: K,
    listener: (data: GameStateManagerEvents<T>[K]) => void
  ): void {
    this.eventEmitter.off(event, listener);
  }

  public getOnBeforeSerializeCallback(): ((state: GameState<T>) => void) | undefined {
    return this.onBeforeSerialize;
  }

  public getOnAfterDeserializeCallback(): ((state: GameState<T>) => void) | undefined {
    return this.onAfterDeserialize;
  }
}
</file>

<file path="packages/core/src/state/index.ts">
// Export runtime typů
export * from './types';

// Export hlavního runtime správce stavu
export { GameStateManager } from './GameStateManager';

// Export obecných runtime utilit pro stav
export * from './utils';

// Export všeho z persistence podsložky
// Tím se persistence služby a typy stávají součástí veřejného API modulu 'state'
export * from './persistence';
</file>

<file path="packages/core/src/utils/immer.ts">
/**
 * Reexport funkcionality z immer pro použití v aplikaci
 * Centralizuje konfiguraci a poskytuje konzistentní API
 */
import { enableMapSet, enablePatches } from 'immer';

// Aktivace podpory pro Map a Set v immer
enableMapSet();

// Aktivace podpory pro patches (příplaty)
enablePatches();

// Reexport hlavních funkcí
export { produce, current, createDraft, finishDraft } from 'immer';
</file>

<file path="packages/core/jest.config.js">
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ['**/test/**/*.test.ts'],
  collectCoverage: true,
  coverageDirectory: 'coverage',
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.d.ts',
    '!src/**/index.ts',
    '!src/types/**/*.ts'
  ],
  transform: {
    '^.+\\.tsx?$': [
      'ts-jest',
      {
        tsconfig: 'tsconfig.json',
      },
    ],
  },
};
</file>

<file path="packages/core/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "declaration": true,
    "declarationDir": "./dist",
    "outDir": "./dist",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node",
    "lib": [
      "ES2022",
      "DOM",
      "DOM.Iterable"
    ]
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "test", "examples"]
}
</file>

<file path="packages/plugin-commands/src/CommandPlugin.ts">
import { AbstractPlugin, GameState } from '@pabitel/core';
import { Command, CommandPluginOptions, CommandProcessResult } from './types';
import Fuse from 'fuse.js';

/**
 * Plugin pro zpracování textových příkazů s využitím Fuse.js pro fuzzy matching
 *
 * Přidává možnost interakce s herním světem pomocí textových příkazů
 * namísto nebo jako doplněk k volbám.
 */
export class CommandPlugin extends AbstractPlugin<CommandPluginOptions> {

    /**
     * Instance Fuse.js pro vyhledávání
     */
    private fuse: Fuse<{ command: Command; pattern: string }> | null = null;

    /**
     * Vytvoří novou instanci CommandPluginu
     *
     * @param options Nastavení pluginu
     */
    constructor(options: CommandPluginOptions = {}) {
        super('commands', {
            fuseOptions: {
                threshold: 0.3,
                ignoreLocation: true,
                useExtendedSearch: true,
                includeScore: true,
                keys: ['pattern']
            },
            ignoreCase: true,
            normalizeDiacritics: true,
            defaultFallbackResponse: "I don't understand that command.",
            ...options
        });
    }

    /**
     * Zpracuje textový příkaz od uživatele
     *
     * @param input Vstup od uživatele
     * @returns Výsledek zpracování příkazu
     */
    public async processCommand(input: string): Promise<CommandProcessResult> {
        if (!this.engine) {
            return { success: false, response: 'Plugin is not initialized.' };
        }

        // Normalizace vstupu
        const normalizedInput = this.normalizeInput(input);
        if (!normalizedInput) {
            return { success: false, response: 'Invalid input.' };
        }

        // Získání aktuálního stavu a scény
        const state = this.engine.getState();
        const currentScene = this.engine.getCurrentScene();
        if (!currentScene) {
            return { success: false, response: 'No active scene.' };
        }

        // Získání dostupných příkazů pro aktuální scénu
        const availableCommands = this.getAvailableCommands();

        // Vyhledání nejlepší shody pomocí Fuse.js
        const match = this.findBestMatch(normalizedInput, availableCommands);

        // Pokud nebyla nalezena shoda
        if (!match) {
            // Použití specifické fallback odpovědi ze scény, pokud existuje
            if (currentScene.fallbackResponse) {
                const response = typeof currentScene.fallbackResponse === 'function'
                    ? currentScene.fallbackResponse(input, state)
                    : currentScene.fallbackResponse;

                return { success: false, response };
            }

            // Použití výchozí fallback odpovědi
            const defaultResponse = typeof this.options.defaultFallbackResponse === 'function'
                ? this.options.defaultFallbackResponse(input, state)
                : this.options.defaultFallbackResponse || "I don't understand that command.";

            return { success: false, response: defaultResponse };
        }

        // Zpracování nalezeného příkazu
        return await this.executeCommand(match.command, state, match.pattern, match.score);
    }

    /**
     * Normalizuje vstupní text
     *
     * @param input Vstupní text
     * @returns Normalizovaný text
     */
    private normalizeInput(input: string): string {
        if (!input || typeof input !== 'string') {
            return '';
        }

        let normalized = input.trim();

        // Normalizace velikosti písmen
        if (this.options.ignoreCase) {
            normalized = normalized.toLowerCase();
        }

        // Normalizace diakritiky
        if (this.options.normalizeDiacritics) {
            normalized = normalized.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
        }

        return normalized;
    }

    /**
     * Najde nejlepší shodu mezi vstupem a dostupnými příkazy pomocí Fuse.js
     *
     * @param input Normalizovaný vstup
     * @param commands Dostupné příkazy
     * @returns Nejlepší shoda nebo undefined, pokud nebyla nalezena
     */
    private findBestMatch(input: string, commands: Command[]): {
        command: Command;
        pattern: string;
        score: number;
    } | undefined {
        // Pokud nemáme žádné příkazy, nemůžeme najít shodu
        if (commands.length === 0) {
            return undefined;
        }

        // Vytvoříme vyhledávací data pro Fuse.js
        const searchData: { command: Command; pattern: string }[] = [];
        for (const command of commands) {
            for (const pattern of command.patterns) {
                const normalizedPattern = this.normalizeInput(pattern);
                searchData.push({ command, pattern: normalizedPattern });
            }
        }

        // Vytvoříme nebo aktualizujeme Fuse.js instanci
        this.fuse = new Fuse(searchData, this.options.fuseOptions as Fuse.IFuseOptions<{ command: Command; pattern: string }>);

        // Vyhledáme nejlepší shodu
        const searchResults = this.fuse.search(input);

        // Pokud nemáme žádné výsledky, vrátíme undefined
        if (searchResults.length === 0) {
            return undefined;
        }

        // Vrátíme nejlepší shodu
        const bestMatch = searchResults[0];
        const { command, pattern } = bestMatch.item;

        // Skóre je v Fuse.js mezi 0-1, kde 0 je přesná shoda
        // Pro konzistenci s naším API konvertujeme na 0-1, kde 1 je přesná shoda
        const score = bestMatch.score ? 1 - bestMatch.score : 1;

        return { command, pattern, score };
    }

    /**
     * Vykoná příkaz
     *
     * @param command Příkaz k vykonání
     * @param state Aktuální stav hry
     * @param pattern Vzor, který vedl k rozpoznání příkazu
     * @param score Skóre shody
     * @returns Výsledek zpracování příkazu
     */
    private async executeCommand(
        command: Command,
        state: GameState,
        pattern: string,
        score: number
    ): Promise<CommandProcessResult> {
        if (!this.engine) {
            return {
                success: false,
                response: 'Plugin is not initialized.',
                command,
                matchDetails: { pattern, score }
            };
        }

        // Získání odpovědi
        let response: string | undefined;
        if (command.response) {
            response = typeof command.response === 'function'
                ? command.response(state)
                : command.response;
        }

        // Aplikace efektů
        if (command.effects && command.effects.length > 0) {
            // Použijeme nové API enginu pro aplikaci efektů
            this.engine.applyEffects(command.effects);
        }

        // Přechod na další scénu, pokud je specifikována
        let success = true;
        if (command.scene) {
            let nextSceneKey: string;

            if (typeof command.scene === 'function') {
                nextSceneKey = command.scene(state);
            } else {
                nextSceneKey = command.scene;
            }

            // Použijeme nové API enginu pro přechod na další scénu
            success = await this.engine.transitionToScene(nextSceneKey);
        }

        // Emitujeme událost o zpracování příkazu
        this.emitNamespacedEvent('commandProcessed', {
            command,
            response,
            pattern,
            score,
            success
        });

        return {
            success,
            response,
            command,
            matchDetails: { pattern, score }
        };
    }

    /**
     * Získá všechny dostupné příkazy v aktuální scéně
     *
     * @returns Pole dostupných příkazů
     */
    public getAvailableCommands(): Command[] {
        if (!this.engine) return [];

        const state = this.engine.getState();
        const currentScene = this.engine.getCurrentScene();
        if (!currentScene) return [];

        // Získáme příkazy z aktuální scény
        const sceneCommands = currentScene.commands || [];

        // Filtrace příkazů podle podmínek
        return sceneCommands.filter(command => {
            if (!command.condition) return true;
            return command.condition(state);
        });
    }

    /**
     * Čištění zdrojů při odregistrování pluginu
     */
    protected override async onDestroy(): Promise<void> {
        this.fuse = null;
    }
}
</file>

<file path="lerna.json">
{
  "packages": ["packages/*"],
  "version": "independent",
  "npmClient": "npm",
  "useWorkspaces": true
}
</file>

<file path="packages/core/src/content/GenericContentLoader.ts">
import { produce } from '../utils/immer';
import { ContentRegistry, ContentLoaderOptions } from './types';

/**
 * A generic loader for game content (like scenes, items, etc.)
 * with support for caching and lazy-loading via dynamic imports or async functions.
 *
 * Automatically injects a `_key` property containing the original registry key
 * into loaded content objects (if the content is an object).
 *
 * @template T The type of the content being loaded (should extend object for _key injection).
 * @template K The type of the content identifier key (defaults to string).
 */
export class GenericContentLoader<T extends object, K extends string = string> {
  /** Cache for already loaded content items, mapped by their key. */
  private loadedContent: Map<string, T> = new Map();

  /** Stores promises for content items that are currently being loaded to prevent duplicate loading attempts. */
  private loadingPromises: Map<string, Promise<T>> = new Map();

  /** The registry containing content definitions or lazy-loading functions. */
  private registry: ContentRegistry<T, K> = {} as ContentRegistry<T, K>;

  /**
   * Creates a new GenericContentLoader instance.
   * @param options Configuration options for the loader.
   */
  constructor(options: ContentLoaderOptions<T, K> = {}) {
    const { initialRegistry = {} as ContentRegistry<T, K> } = options;
    this.registry = { ...initialRegistry }; // Shallow copy initial registry
  }

  /**
   * Registers multiple content definitions with the loader, merging them
   * with the existing registry.
   * @param registry A ContentRegistry containing definitions or lazy-loading functions.
   */
  public registerContent(registry: ContentRegistry<T, K>): void {
    // Using produce for potential future complex merging logic, although Object.assign is sufficient here.
    this.registry = produce(this.registry, (draft) => {
      Object.assign(draft, registry);
    });
    // Alternative simple merge:
    // this.registry = { ...this.registry, ...registry };
  }

  /**
   * Alias for `registerContent`. Registers all content definitions from the provided registry.
   * @param registry A ContentRegistry containing definitions or lazy-loading functions.
   */
  public registerAll(registry: ContentRegistry<T, K>): void {
    this.registerContent(registry);
  }

  /**
   * Loads a content item by its key.
   * Handles both directly defined content and lazy-loaded content (functions returning Promises).
   * Caches loaded content and manages concurrent loading attempts.
   * Injects a `_key` property into the loaded content if it's an object.
   *
   * @param key The unique key identifying the content item to load.
   * @returns A Promise that resolves with the loaded content item.
   * @throws {Error} If content with the specified key is not found in the registry.
   * @throws {Error} If lazy-loading fails.
   */
  public async loadContent(key: string): Promise<T> {
    // Return from cache if already loaded
    if (this.loadedContent.has(key)) {
      return this.loadedContent.get(key)!;
    }

    // Return existing promise if currently loading
    if (this.loadingPromises.has(key)) {
      return this.loadingPromises.get(key)!;
    }

    const contentDefOrImport = this.registry[key];

    if (!contentDefOrImport) {
      throw new Error(`Content with key "${key}" not found in registry`);
    }

    let loadPromise: Promise<T>;

    if (typeof contentDefOrImport === 'function') {
      // Handle lazy-loaded content
      const loadFunction = contentDefOrImport as () => Promise<T | { default: T }>;
      loadPromise = loadFunction().then((moduleOrContent): T => {
        // Check for ES module default export or direct content
        const content = this.isModuleWithDefault(moduleOrContent) ? moduleOrContent.default : moduleOrContent;

        // Add _key to the loaded content if it's an object
        // Note: This modifies the loaded content instance.
        const enhancedContent = typeof content === 'object' && content !== null
            ? { ...content, _key: key }
            : content;

        this.loadedContent.set(key, enhancedContent);
        // Remove promise from loadingPromises map upon successful load
        this.loadingPromises.delete(key);
        return enhancedContent;
      }).catch(error => {
        // Remove promise from loadingPromises map even on error
        this.loadingPromises.delete(key);
        console.error(`Failed to load content for key "${key}":`, error);
        // Re-throw the error to allow callers (like preloadContent) to handle it
        throw error;
      });

      // Store the promise ONLY if it represents actual async loading
      this.loadingPromises.set(key, loadPromise);

    } else {
      // Handle directly defined content
      // Add _key if it's an object
      const content = typeof contentDefOrImport === 'object'
          ? { ...contentDefOrImport, _key: key }
          : contentDefOrImport;

      loadPromise = Promise.resolve(content);
      this.loadedContent.set(key, content);
    }

    return loadPromise;
  }

  /**
   * Checks if content with the given key exists in the registry.
   * Does not check if the content is already loaded or currently loading.
   * @param key The key of the content item.
   * @returns `true` if the content key is registered, `false` otherwise.
   */
  public hasContent(key: string): boolean {
    return key in this.registry;
  }

  /**
   * Gets an array of all content keys currently registered with this loader.
   * @returns An array of content keys.
   */
  public getContentKeys(): string[] {
    return Object.keys(this.registry);
  }

  /**
   * Preloads content items by their keys. Useful for loading assets upfront.
   * If a key refers to already loaded content, it's skipped.
   * If a key refers to lazy-loaded content, its loading process is initiated.
   *
   * @param keys An optional array of content keys to preload. If omitted,
   *             attempts to preload all *lazy-loaded* content items
   *             that are not already loaded or loading.
   * @returns A Promise that resolves when all requested items are loaded,
   *          or rejects if *any* of the loading attempts fail.
   * @throws {Error} If loading of any specified item fails.
   */
  public async preloadContent(keys?: string[]): Promise<void> {
    let keysToLoad: string[];

    if (keys) {
      // If keys are specified, filter only those present in the registry
      keysToLoad = keys.filter(key => this.hasContent(key));
    } else {
      // If no keys specified, find all registered lazy-loading functions
      // that haven't been loaded or aren't currently loading.
      keysToLoad = this.getContentKeys().filter(key =>
          typeof this.registry[key] === 'function' &&
          !this.loadedContent.has(key) &&
          !this.loadingPromises.has(key) // Don't re-trigger loading
      );
    }

    if (keysToLoad.length === 0) {
      // Nothing to preload
      return Promise.resolve();
    }

    console.log(`[ContentLoader] Preloading content for keys: ${keysToLoad.join(', ')}`);

    // Create an array of promises by calling loadContent for each key.
    // loadContent intelligently uses cache or existing loading promises.
    const preloadPromises = keysToLoad.map(key => this.loadContent(key));

    // Use Promise.all to run all loading operations concurrently.
    // It rejects if any of the inner promises reject.
    try {
      await Promise.all(preloadPromises);
      console.log(`[ContentLoader] Successfully preloaded content for keys: ${keysToLoad.join(', ')}`);
    } catch (error) {
      // The error was already logged in loadContent's catch block.
      console.error(`[ContentLoader] Error occurred during preloading content.`);
      throw error; // Re-throw to signal failure to the caller
    }
  }

  /**
   * Retrieves the underlying content registry.
   * @returns The current content registry.
   */
  public getRegistry(): ContentRegistry<T, K> {
    return this.registry;
  }

  /**
   * Clears the cache of loaded content items and cancels tracking of
   * currently loading items. Content will be re-loaded on the next request
   * (via `loadContent` or `preloadContent`).
   */
  public clearCache(): void {
    this.loadedContent.clear();
    this.loadingPromises.clear();
    console.log('[ContentLoader] Content loader cache cleared.');
  }

  /**
   * Type guard to check if an object is likely an ES module with a default export.
   * @param obj The object to check.
   * @returns `true` if the object has a 'default' property, `false` otherwise.
   * @private
   */
  private isModuleWithDefault(obj: any): obj is { default: T } {
    // Check if obj is a non-null object and has the 'default' key
    return obj && typeof obj === 'object' && 'default' in obj;
  }
}
</file>

<file path="packages/core/src/content/types.ts">
// src/content/types.ts

import { Scene } from '../scene/types'; // Assuming Scene is defined here

/**
 * Represents a registry for content items, supporting both direct definitions
 * and asynchronous lazy-loading functions.
 *
 * @template T The type of the content item (e.g., Scene, Item). Must be an object type if you rely on automatic _key injection.
 * @template K The type of the content identifier key (defaults to string).
 */
export type ContentRegistry<T, K extends string = string> = {
  // Using string index signature allows flexibility but loses specific key type checking beyond string.
  // If K needed stricter compile-time checks, a mapped type might be used, but string is common here.
  [key: string]: T | (() => Promise<T | { default: T }>);
};

/**
 * Configuration options for creating a GenericContentLoader.
 *
 * @template T The type of the content being loaded.
 * @template K The type of the content identifier key.
 */
export interface ContentLoaderOptions<T extends object, K extends string = string> {
  /** An optional initial registry of content definitions. */
  initialRegistry?: ContentRegistry<T, K>;
}

/**
 * Defines a structure for registering a collection of content with the engine
 * under a specific type identifier.
 *
 * @template T The type of the content items within the registry (e.g., Scene, Item). Must be an object.
 */
export interface ContentDefinition<T extends object> {
  /** An identifier for the type of content (e.g., 'scenes', 'items', 'characters'). */
  type: string;
  /** The ContentRegistry holding the actual content definitions or loaders for this type. */
  content: ContentRegistry<T>;
}


// --- Potential Future Event Types ---
// Note: These events are defined here but are not currently emitted by the core content module.
// They serve as a potential future enhancement for observing content loading and registration.

/**
 * Data for an event signaling that a specific content item has been loaded.
 * (Not currently emitted)
 * @template T The type of the loaded content.
 */
export interface ContentLoadedEvent<T> {
  /** The type identifier of the content (e.g., 'scenes'). */
  type: string;
  /** The key of the loaded content item. */
  key: string;
  /** The actual loaded content item. */
  content: T;
}

/**
 * Data for an event signaling that new content definitions have been registered.
 * (Not currently emitted)
 */
export interface ContentRegisteredEvent {
  /** The type identifier of the content (e.g., 'scenes'). */
  type: string;
  /** The number of content items registered in this batch. */
  count: number;
  /** The keys of the content items that were registered. */
  keys: string[];
}
</file>

<file path="packages/core/src/effect/EffectManager.ts">
import { GameState } from '../state';
import { Effect, EffectProcessor, EffectType, BuiltInEffectType } from './types';
import { produce } from '../utils/immer';
import { createDefaultEffectProcessors } from './processors';

const NAMESPACE_SEPARATOR = ':';

/**
 * Manažer efektů pro zpracování herních efektů
 */
export class EffectManager {
  /**
   * Mapa procesorů efektů podle typu
   */
  private effectProcessors: Map<string, EffectProcessor> = new Map();

  /**
   * Záložní procesor pro neznámé typy efektů
   */
  private fallbackProcessor: EffectProcessor | null = null;

  /**
   * Vytvoří novou instanci EffectManager
   *
   * @param options Možnosti konfigurace
   */
  constructor(options: { registerDefaultEffects?: boolean } = {}) {
    const { registerDefaultEffects = true } = options;

    if (registerDefaultEffects) {
      this.registerDefaultEffects();
    }
  }

  /**
   * Zpracuje jeden efekt s využitím příslušného procesoru
   *
   * @param effect Efekt ke zpracování
   * @param draftState Návrh herního stavu pro modifikaci
   * @private
   */
  private processSingleEffect(effect: Effect, draftState: GameState): void {
    const processor = this.effectProcessors.get(effect.type);

    if (processor) {
      processor(effect, draftState);
    } else if (this.fallbackProcessor) {
      this.fallbackProcessor(effect, draftState);
    } else {
      console.warn(`No processor registered for effect type '${effect.type}'`);
    }
  }

  /**
   * Registruje výchozí efektové procesory
   * @private
   */
  private registerDefaultEffects(): void {
    const defaultProcessors = createDefaultEffectProcessors();

    // Registrujeme všechny výchozí procesory
    this.registerEffectProcessors(defaultProcessors);
  }

  /**
   * Odregistruje výchozí efektové procesory
   */
  public unregisterDefaultEffects(): void {
    Object.values(BuiltInEffectType).forEach(type => {
      this.effectProcessors.delete(type);
    });
  }

  /**
   * Sestaví kompletní klíč procesoru včetně jmenného prostoru
   *
   * @param effectType Typ efektu
   * @param namespace Jmenný prostor (volitelný)
   * @returns Kompletní klíč procesoru
   * @private
   */
  private getFullEffectType(effectType: EffectType, namespace?: string): string {
    if (!namespace) {
      return effectType.toString();
    }
    return `${namespace}${NAMESPACE_SEPARATOR}${effectType}`;
  }

  /**
   * Registruje procesor pro daný typ efektu
   *
   * @param effectType Typ efektu
   * @param processor Funkce pro zpracování efektu
   * @param namespace Jmenný prostor (volitelný)
   */
  public registerEffectProcessor(
    effectType: EffectType,
    processor: EffectProcessor,
    namespace?: string
  ): void {
    const fullType = this.getFullEffectType(effectType, namespace);
    this.effectProcessors.set(fullType, processor);
  }

  /**
   * Odregistruje procesor pro daný typ efektu
   *
   * @param effectType Typ efektu
   * @param namespace Jmenný prostor (volitelný)
   * @returns True pokud byl procesor úspěšně odregistrován
   */
  public unregisterEffectProcessor(effectType: EffectType, namespace?: string): boolean {
    const fullType = this.getFullEffectType(effectType, namespace);
    return this.effectProcessors.delete(fullType);
  }

  /**
   * Registruje více procesorů najednou
   *
   * @param processors Objekt mapující typy efektů na procesory
   * @param namespace Jmenný prostor (volitelný)
   */
  public registerEffectProcessors(
    processors: Record<string, EffectProcessor>,
    namespace?: string
  ): void {
    for (const [type, processor] of Object.entries(processors)) {
      this.registerEffectProcessor(type as EffectType, processor, namespace);
    }
  }

  /**
   * Odregistruje všechny procesory patřící pod daný jmenný prostor
   *
   * @param namespace Jmenný prostor
   * @returns Počet odregistrovaných procesorů
   */
  public unregisterNamespace(namespace: string): number {
    const prefix = `${namespace}${NAMESPACE_SEPARATOR}`;
    let count = 0;

    for (const key of this.effectProcessors.keys()) {
      if (key.startsWith(prefix)) {
        this.effectProcessors.delete(key);
        count++;
      }
    }

    return count;
  }

  /**
   * Nastaví záložní procesor pro neznámé typy efektů
   *
   * @param processor Záložní procesor nebo null pro deaktivaci
   */
  public setFallbackProcessor(processor: EffectProcessor | null): void {
    this.fallbackProcessor = processor;
  }

  /**
   * Aplikuje efekt na herní stav
   *
   * @param effect Efekt k aplikaci
   * @param state Herní stav
   * @returns Nový herní stav
   */
  public applyEffect(effect: Effect, state: GameState): GameState {
    return produce(state, (draftState: GameState) => {
      this.processSingleEffect(effect, draftState);
    });
  }

  /**
   * Aplikuje více efektů na herní stav
   *
   * @param effects Pole efektů k aplikaci
   * @param state Herní stav
   * @returns Nový herní stav
   */
  public applyEffects(effects: Effect[], state: GameState): GameState {
    if (effects.length === 0) {
      return state;
    }

    return produce(state, (draftState: GameState) => {
      for (const effect of effects) {
        this.processSingleEffect(effect, draftState);
      }
    });
  }

  /**
   * Zkontroluje, zda existuje procesor pro daný typ efektu
   *
   * @param effectType Typ efektu
   * @param namespace Jmenný prostor (volitelný)
   * @returns True pokud procesor existuje
   */
  public hasProcessor(effectType: EffectType, namespace?: string): boolean {
    const fullType = this.getFullEffectType(effectType, namespace);
    return this.effectProcessors.has(fullType);
  }

  /**
   * Vrátí seznam registrovaných typů efektů
   *
   * @returns Pole typů efektů
   */
  public getRegisteredEffectTypes(): string[] {
    return Array.from(this.effectProcessors.keys());
  }
}
</file>

<file path="packages/core/src/save/types.ts">
/**
 * Metadata uložené hry
 * Obsahuje informace o uložené hře bez herního stavu samotného
 */
export interface SaveMetadata {
  /** Unikátní identifikátor uložené hry */
  id: string;
  /** Název nebo popis uložené hry */
  name: string;
  /** Časové razítko vytvoření uložené hry */
  createdAt: number;
  /** Časové razítko poslední aktualizace uložené hry */
  updatedAt: number;
  /** Celkový čas strávený hrou v milisekundách */
  playTime: number;
  /** Verze enginu, ve které byla hra uložena */
  engineVersion: string;

  /** Verze formátu struktury uložených dat (SaveData). */
  saveDataFormatVersion: number; // <--- Přidáno/Přejmenováno

  /** Verze formátu herního stavu (pro migraci stavu). */
  stateFormatVersion: number; // <--- Přidáno/Přejmenováno

  /** Klíč aktuální scény v době uložení */
  currentSceneKey: string | null;
  /** Thumbnail nebo obrázek reprezentující uloženou hru (volitelné) */
  thumbnail?: string;
  /** Další vlastnosti specifické pro konkrétní hru nebo implementaci úložiště */
  [key: string]: any;
}

/**
 * Reprezentace uložené hry včetně herního stavu
 */
export interface SaveData {
  /** Metadata o uložené hře */
  metadata: SaveMetadata;
  /** Serializovaný herní stav */
  state: string;
  /** Volitelné dodatečné údaje specifické pro implementaci úložiště */
  [key: string]: any;
}

/**
 * Možnosti pro vytvoření nové uložené hry
 */
export interface SaveOptions {
  /** Název nebo popis uložené hry (volitelné) */
  name?: string;
  /** Thumbnail nebo obrázek reprezentující uloženou hru (volitelné) */
  thumbnail?: string;
  /** Další možnosti specifické pro implementaci úložiště */
  [key: string]: any;
}

/**
 * Nastavení pro automatické ukládání
 */
export interface AutoSaveOptions {
  /** Interval v milisekundách mezi automatickými uloženími */
  interval?: number;
  /** Maximální počet automatických uložení */
  slots?: number;
  /** Prefix pro názvy automatických uložení */
  prefix?: string;
  /** Callback volaný před automatickým uložením */
  beforeSave?: () => boolean | Promise<boolean>;
  /** Callback volaný po automatickém uložení */
  afterSave?: (saveId: string) => void | Promise<void>;
  /** Další možnosti specifické pro implementaci úložiště */
  [key: string]: any;
}

/**
 * Metody pro práci s úložištěm uložených her
 */
export interface SaveStorage {
  /** Uloží data do úložiště */
  save(id: string, data: SaveData): Promise<boolean>;
  /** Načte data z úložiště */
  load(id: string): Promise<SaveData | null>;
  /** Vrátí seznam všech uložených her */
  list(): Promise<Record<string, SaveMetadata>>;
  /** Smaže uloženou hru */
  delete(id: string): Promise<boolean>;
  /** Zkontroluje, zda existuje uložená hra s daným ID */
  exists(id: string): Promise<boolean>;
  /** (Volitelné) Vymaže všechna uložení */
  clearAll?: () => Promise<boolean>;
}

/**
 * Typy událostí emitovaných SaveManager
 */
export enum SaveEvents {
  GAME_SAVED = 'save:gameSaved',
  GAME_LOADED = 'save:gameLoaded',
  GAME_DELETED = 'save:gameDeleted',
  AUTO_SAVE_ENABLED = 'save:autoSaveEnabled',
  AUTO_SAVE_DISABLED = 'save:autoSaveDisabled',
  ALL_SAVES_CLEARED = 'save:allSavesCleared',
  STORAGE_CHANGED = 'save:storageChanged',
}

// Přidání typů pro data událostí SaveManageru (příklad)
export interface GameSavedEventData {
  saveId: string;
  metadata?: SaveMetadata; // Metadata mohou chybět při selhání před jejich vytvořením
  success: boolean;
  error?: any;
}

export interface GameLoadedEventData {
  saveId: string;
  metadata?: SaveMetadata; // Metadata jsou dostupná jen při úspěchu
  success: boolean;
  error?: any;
}

export interface GameDeletedEventData {
  saveId: string;
  success: boolean;
  error?: any;
}

export interface AutoSaveEnabledEventData {
  options: AutoSaveOptions;
}
export interface AutoSaveDisabledEventData {}

export interface AllSavesClearedEventData {
  success: boolean;
  error?: any;
}

export interface StorageChangedEventData {
  storage: SaveStorage;
}

// Mapa událostí pro SaveManager
export type SaveEventMap = {
  [SaveEvents.GAME_SAVED]: GameSavedEventData;
  [SaveEvents.GAME_LOADED]: GameLoadedEventData;
  [SaveEvents.GAME_DELETED]: GameDeletedEventData;
  [SaveEvents.AUTO_SAVE_ENABLED]: AutoSaveEnabledEventData;
  [SaveEvents.AUTO_SAVE_DISABLED]: AutoSaveDisabledEventData;
  [SaveEvents.ALL_SAVES_CLEARED]: AllSavesClearedEventData;
  [SaveEvents.STORAGE_CHANGED]: StorageChangedEventData;
};
</file>

<file path="packages/core/src/state/types.ts">
/**
 * Základní herní stav
 * Obsahuje základní strukturu pro ukládání herního stavu
 * @template T Typ pro proměnné, výchozí je prázdný objekt
 */
export interface GameState<T extends Record<string, unknown> = Record<string, unknown>> {
  /**
   * Množina klíčů navštívených scén
   */
  visitedScenes: Set<string>;

  /**
   * Úložiště herních proměnných
   */
  variables: T;

  /**
   * Indexová signatura pro další vlastnosti
   * Umožňuje rozšiřování stavu pluginy a dalšími komponentami
   */
  [key: string]: any;
}

/**
 * Klíč pro perzistentní vlastnosti ve stavu - pro dokumentaci/API reference, ne interně
 */
export const PERSISTENT_KEYS_KEY = '__persistentKeys'; // Konstanta zůstává pro referenci

/**
 * Výchozí perzistentní klíče, které by měly být vždy ukládány
 */
export const DEFAULT_PERSISTENT_KEYS = ['visitedScenes', 'variables'];

/**
 * Funkce pro aktualizaci herního stavu
 * Používá se s immer pro bezpečné mutace
 * @template T Typ proměnných ve stavu
 */
export type StateUpdater<T extends Record<string, unknown> = Record<string, unknown>> = (
  state: GameState<T>
) => void;

/**
 * Možnosti pro vytvoření GameStateManager
 * @template T Typ proměnných ve stavu
 */
export interface GameStateManagerOptions<
  T extends Record<string, unknown> = Record<string, unknown>,
> {
  /**
   * Počáteční stav, který bude sloučen s výchozím prázdným stavem
   */
  initialState?: Partial<GameState<T>>;

  /**
   * Seznam klíčů, které budou persistovány při serializaci
   * Pokud není uveden, použijí se DEFAULT_PERSISTENT_KEYS
   */
  persistentKeys?: string[];

  /**
   * Callback volaný PŘED serializací stavu.
   * Tuto funkcionalitu by měl primárně implementovat SaveManager nebo PersistenceService,
   * ale je zde ponechána pro možnost, aby GameStateManager mohl provést přípravu.
   */
  onBeforeSerialize?: (state: GameState<T>) => void;

  /**
   * Callback volaný PO deserializaci stavu a jeho aplikaci na GameStateManager.
   * Stejně jako onBeforeSerialize, primárně patří do persistence vrstvy.
   */
  onAfterDeserialize?: (state: GameState<T>) => void;
}

/**
 * Data předávaná při události změny stavu
 */
export interface StateChangedEvent<T extends Record<string, unknown> = Record<string, unknown>> {
  /**
   * Předchozí stav (null při deserializaci)
   */
  previousState: GameState<T> | null;

  /**
   * Nový stav
   */
  newState: GameState<T>;

  /**
   * Zdroj změny (např. 'effect', 'scene', 'plugin', 'deserialize', 'reset', atd.)
   */
  source?: string;
}

/**
 * Eventy emitované GameStateManagerem (runtime události)
 */
export interface GameStateManagerEvents<
  T extends Record<string, unknown> = Record<string, unknown>,
> {
  /**
   * Emitováno při změně stavu
   */
  stateChanged: StateChangedEvent<T>;

  /**
   * Emitováno při změně perzistentních klíčů
   */
  persistentKeysChanged: { keys: string[] };

  // Události související s persistencí (jako beforeSerialize/afterDeserialize/migrationApplied)
  // by se nyní měly emitovat z StatePersistenceService nebo StateMigrationService,
  // jak je definováno v src/state/persistence/types.ts.
  // GameStateManager na ně může volitelně naslouchat, pokud je to potřeba.
}
</file>

<file path="packages/core/src/state/utils.ts">
import { GameState } from './types';
import lodashGet from 'lodash/get';
import lodashSet from 'lodash/set';
import lodashHas from 'lodash/has';
import { produce } from '../utils/immer'; // Předpokládá se, že Immer utilities jsou stále zde

/**
 * Získá hodnotu z herního stavu pomocí cesty (dot notation)
 * Používá Lodash get pro pohodlí a robustnost.
 * @template T Typ očekávaného výstupu
 * @param state Herní stav
 * @param path Cesta k hodnotě (např. 'variables.player.health', 'visitedScenes', 'somePluginData.config.value')
 * @param defaultValue Výchozí hodnota, pokud cesta neexistuje nebo je výsledek undefined.
 * @returns Hodnota proměnné nebo defaultValue, pokud je poskytnuto.
 */
export function getStatePath<T>(
  state: GameState<any>,
  path: string,
  defaultValue?: T
): T | undefined {
  // Lodash get umí procházet objekty i pole podle indexu nebo klíče
  return lodashGet(state, path, defaultValue);
}

/**
 * Nastaví hodnotu v herním stavu pomocí cesty (dot notation)
 * Tato funkce by se měla používat *uvnitř* `updateState` callbacku,
 * kde pracujete s draftem.
 * @param draftState Draft herního stavu (z Immer produce)
 * @param path Cesta k hodnotě (např. 'variables.player.health', 'somePluginData.config.value')
 * @param value Hodnota k nastavení
 */
export function setStatePath<T extends Record<string, unknown>>(
  draftState: GameState<T>, // Pracuje s draftem!
  path: string,
  value: any
): void {
  // V Immer draftu se mutuje in-place, nevrací se nový stav
  // Lodash set umí vytvářet zanořené objekty/pole, pokud neexistují
  lodashSet(draftState, path, value);
}

/**
 * Zkontroluje, zda cesta existuje v herním stavu a hodnota na ní není undefined.
 * Používá Lodash has.
 * @param state Herní stav
 * @param path Cesta k kontrole (např. 'variables.player.health', 'visitedScenes', 'somePluginData.config.value')
 * @returns True pokud cesta existuje a hodnota na ní není undefined.
 */
export function hasStatePath(state: GameState<any>, path: string): boolean {
  // Lodash has kontroluje pouze existenci klíče/indexu na cestě, ne hodnotu != undefined/null
  // Pokud potřebujete zkontrolovat, zda hodnota není undefined/null, použijte getStatePath !== undefined && getStatePath !== null
  return lodashHas(state, path);
}

/**
 * Vytvoří snapshot stavu (hluboká kopie).
 * Umožňuje bezpečně pracovat s kopií stavu, aniž by ovlivňoval aktuální runtime stav.
 * Poznámka: Tato utilita provede hlubokou kopii. Buďte opatrní s velkými nebo složitými stavy.
 * Používá JSON.parse/stringify a ručně zpracovává Set (předpokládá serializovatelný obsah Setu).
 * Pro komplexnější typy (Date, RegExp, Map, třídy) může být nutné použít vlastní rekurzivní klonování nebo specializovanou knihovnu pro deep clone (např. z lodash nebo vlastní implementaci deepClone z utils/object).
 * @param state Herní stav
 * @returns Hluboká kopie stavu.
 */
export function createStateSnapshot<T extends Record<string, unknown>>(
  state: GameState<T>
): GameState<T> {
  // Použijeme JSON.parse/stringify pro hluboké klonování, což je jednoduché pro plain objekty a pole.
  // Je nutné ručně převést Set na Array pro serializaci.
  try {
    const serializableState = {
      ...state,
      // visitedScenes je Set, převedeme na Array pro serializaci
      visitedScenes: Array.from(state.visitedScenes),
    };

    // Stringifikace
    const serialized = JSON.stringify(serializableState);
    // Parsvání
    const parsed = JSON.parse(serialized);

    // Převedeme Array zpět na Set a vrátíme hotový GameState objekt
    return {
      ...parsed,
      visitedScenes: new Set(parsed.visitedScenes), // Convert back to Set
    } as GameState<T>; // Přetypování pro jistotu
  } catch (error) {
    console.error('createStateSnapshot: Failed to create a deep copy of the state.', error);
    // V případě chyby vracíme původní referenci nebo null/undefined?
    // Vrátit původní referenci by porušilo očekávání, že jde o kopii.
    // V závislosti na aplikaci můžete chtít vyhodit chybu.
    throw new Error('Failed to create state snapshot.');
  }
}

/**
 * Porovná dva stavy a vrátí rozdíly.
 * Pomáhá při ladění a sledování změn stavu.
 * Poznámka: Toto porovnání používá JSON.stringify pro hluboké porovnání,
 * což nemusí být vhodné pro všechny datové typy (např. funkce, cirkulární reference) nebo pro velký výkon.
 * Pro robustnější porovnání lze použít dedikovanou deepEqual funkci (např. z lodash nebo vlastní implementaci z utils/object).
 * @param oldState Starý stav
 * @param newState Nový stav
 * @returns Objekt s rozdíly (klíč -> { old: any, new: any }). Zahrnuje rozdíly v visitedScenes (added/removed) a variables.
 */
export function compareStates<T extends Record<string, unknown>>(
  oldState: GameState<T>,
  newState: GameState<T>
): Record<string, any> {
  const differences: Record<string, any> = {};

  // Klíče, které jsou systémové nebo by se neměly přímo porovnávat na první úrovni
  const excludeKeys = ['_metadata'];

  // Kombinace všech klíčů z obou stavů
  const allKeys = new Set([...Object.keys(oldState), ...Object.keys(newState)]);

  for (const key of allKeys) {
    if (!excludeKeys.includes(key)) {
      const oldValue = (oldState as any)[key];
      const newValue = (newState as any)[key];

      // Speciální porovnání pro visitedScenes (Set)
      if (key === 'visitedScenes') {
        const oldScenes = oldValue instanceof Set ? Array.from(oldValue) : [];
        const newScenes = newValue instanceof Set ? Array.from(newValue) : [];

        // Porovnáme sady klíčů
        const addedScenes = newScenes.filter(scene => !(oldValue as Set<string>)?.has(scene));
        const removedScenes = oldScenes.filter(scene => !(newValue as Set<string>)?.has(scene));

        if (addedScenes.length > 0 || removedScenes.length > 0) {
          // Logujeme přidané/odebrané prvky Setu
          differences[key] = { added: addedScenes, removed: removedScenes };
        } else if (oldValue instanceof Set !== newValue instanceof Set) {
          // Pokud se změnil typ (např. Set na něco jiného)
          differences[key] = { old: oldValue, new: newValue };
        }
      } else if (key === 'variables') {
        // Porovnání variables (objekt)
        const oldVars = oldValue || {}; // Treat null/undefined as empty object for comparison
        const newVars = newValue || {};
        const variableKeys = new Set([...Object.keys(oldVars), ...Object.keys(newVars)]);
        const changedVars: Record<string, { old: any; new: any }> = {};

        // Projdeme všechny klíče proměnných a porovnáme jejich hodnoty
        for (const varKey of variableKeys) {
          const oldVal = oldVars[varKey];
          const newVal = newVars[varKey];

          // Hluboké porovnání hodnot proměnných pomocí JSON.stringify
          // Může být neefektivní nebo nesprávné pro některé typy (funkce, instance tříd).
          // Zvažte použití deepEqual utility z utils/object, pokud je potřeba robustnější porovnání.
          if (JSON.stringify(oldVal) !== JSON.stringify(newVal)) {
            changedVars[varKey] = { old: oldVal, new: newVal };
          }
        }
        if (Object.keys(changedVars).length > 0) {
          differences.variables = changedVars;
        }
      } else {
        // Standardní porovnání ostatních vlastností na první úrovni (JSON.stringify)
        // Toto je "hluboké" porovnání hodnot, ne jen referencí.
        if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {
          differences[key] = { old: oldValue, new: newValue };
        }
      }
    }
  }

  // Můžete přidat logiku pro detekci klíčů, které byly odstraněny v newState
  // Iterace přes oldState klíče a kontrola, zda neexistují v newState
  for (const key in oldState) {
    if (
      Object.prototype.hasOwnProperty.call(oldState, key) &&
      !excludeKeys.includes(key) &&
      !(key in newState)
    ) {
      // Klíč existoval ve starém stavu, ale neexistuje v novém
      differences[key] = { old: (oldState as any)[key], new: undefined };
    }
  }

  return differences;
}

/**
 * Validuje herní stav a kontroluje základní strukturu a typy klíčových vlastností.
 * @param state Herní stav
 * @returns True pokud je stav validní, jinak False.
 */
export function validateState<T extends Record<string, unknown>>(state: GameState<T>): boolean {
  if (!state || typeof state !== 'object') {
    console.error('Validation failed: State is null, undefined, or not an object.');
    return false;
  }

  // Kontrola základní struktury a typů
  if (!('variables' in state) || typeof state.variables !== 'object' || state.variables === null) {
    console.error('Validation failed: state.variables is missing, not an object, or null.');
    return false;
  }

  if (!('visitedScenes' in state)) {
    console.error('Validation failed: state.visitedScenes is missing.');
    return false;
  }

  // Zajištění, že visitedScenes je Set
  if (!(state.visitedScenes instanceof Set)) {
    // Může se stát po deserializaci, pokud nebyl použit applyPersistentState
    console.warn('Validation warning: state.visitedScenes is not a Set.', state.visitedScenes);
    // Můžeme se pokusit o konverzi nebo to označit jako chybu
    if (Array.isArray(state.visitedScenes)) {
      try {
        state.visitedScenes = new Set(state.visitedScenes);
        console.warn(
          'Validation warning: Successfully converted state.visitedScenes from Array to Set.'
        );
      } catch (e) {
        console.error(
          'Validation failed: Error converting state.visitedScenes from Array to Set.',
          e
        );
        return false;
      }
    } else {
      console.error('Validation failed: state.visitedScenes is neither a Set nor an Array.');
      return false;
    }
  }

  // Další vlastní validační logiku můžete přidat zde
  // Např. kontrola existence a typu specifických pluginových dat
  // if ('myPluginData' in state && (typeof state.myPluginData !== 'object' || state.myPluginData === null)) {
  //      console.error("Validation failed: state.myPluginData is not an object.");
  //      return false;
  // }

  return true;
}
</file>

<file path="package.json">
{
  "name": "pabitel",
  "private": true,
  "workspaces": [
    "packages/*",
    "examples/*",
    "e2e-tests"
  ],
  "scripts": {
    "build": "lerna run build",
    "test": "lerna run test",
    "lint": "lerna run lint",
    "e2e": "cd e2e-tests && npm run test",
    "dev:vanilla": "cd examples/vanilla && npm run dev",
    "dev:vue": "cd examples/vue && npm run dev"
  },
  "devDependencies": {
    "lerna": "^4.0.0"
  }
}
</file>

<file path="packages/core/src/content/utils.ts">
// Import types using 'import type' from the central types file
import type { ContentRegistry, ContentDefinition, ContentLoaderOptions } from './types';
// Import Scene type (assuming it's exported from scene module index)
import type { Scene } from '../scene';
// Import the GenericContentLoader class (runtime value)
import { GenericContentLoader } from './GenericContentLoader';

/**
 * Factory function to create a new instance of `GenericContentLoader`.
 *
 * @template T The type of content the loader will manage (must extend object).
 * @template K The type of the content identifier key.
 * @param options Optional configuration for the content loader, including an initial registry.
 * @returns A new instance of `GenericContentLoader<T, K>`.
 */
export function createContentLoader<T extends object, K extends string = string>(
    options?: ContentLoaderOptions<T, K> // Use options interface from types.ts
): GenericContentLoader<T, K> {
  return new GenericContentLoader<T, K>(options);
}

/**
 * Helper function to create a `ContentDefinition` object, typically used
 * for registering content collections with the engine's `LoaderRegistry`.
 *
 * @template T The type of the content items in the registry (must extend object).
 * @param type A string identifying the type of content (e.g., 'scenes', 'items').
 * @param contentRegistry The `ContentRegistry` containing the actual content definitions or loaders.
 * @returns A `ContentDefinition` object ready for registration.
 */
export function defineContent<T extends object>(
    type: string,
    contentRegistry: ContentRegistry<T>
): ContentDefinition<T> {
  return { type, content: contentRegistry };
}

/**
 * A specialized utility for defining a registry of scenes.
 * Automatically sets the content type identifier to 'scenes'.
 *
 * @param registry An object mapping scene keys (string) to `Scene` objects or lazy-loading functions.
 * @returns A `ContentDefinition<Scene>` object ready for registration.
 */
export function defineScenes(registry: ContentRegistry<Scene>): ContentDefinition<Scene> {
  // Internally calls the generic defineContent function with the type pre-filled.
  return defineContent<Scene>('scenes', registry);
}

/**
 * Merges multiple content registries into a single new registry.
 * Later registries overwrite entries with the same key from earlier ones.
 * Creates a new shallow copy; does not modify the original registries.
 *
 * @template T The type of content in the registries.
 * @template K The type of the content identifier key.
 * @param registries An array of `ContentRegistry` objects to merge.
 * @returns A new `ContentRegistry` containing all entries from the input registries.
 */
export function mergeContentRegistries<T, K extends string = string>(
    ...registries: ContentRegistry<T, K>[]
): ContentRegistry<T, K> {
  // Object.assign creates a new object and merges properties shallowly.
  return Object.assign({}, ...registries);
}

/**
 * Generates a normalized content key, typically used for hierarchical or path-based keys.
 * Joins parts with '/', removes duplicate slashes, filters empty parts, and trims leading/trailing slashes.
 *
 * @param parts String parts to join into a key. Empty or whitespace-only parts are filtered out.
 * @returns A normalized content key string.
 * @example
 * generateContentKey('items', ' potions ', '/healing', '', ' ') // Returns 'items/potions/healing'
 * generateContentKey(' single ') // Returns 'single'
 */
export function generateContentKey(...parts: string[]): string {
  // Filter out empty or whitespace-only parts
  const filteredParts = parts.filter(part => part && part.trim() !== '');

  // Handle the case where no valid parts are provided
  if (filteredParts.length === 0) {
    return '';
  }

  // Join with slash, replace multiple slashes with one, trim ends
  return filteredParts
      .join('/')
      .replace(/\/+/g, '/')      // Replace //, ///, etc. with /
      .replace(/^\/|\/$/g, ''); // Remove leading/trailing /
}

/**
 * Extracts all keys (content identifiers) from a given content registry.
 *
 * @template T The type of content in the registry.
 * @template K The type of the content identifier key.
 * @param registry The `ContentRegistry` object.
 * @returns An array of strings representing the keys in the registry.
 */
export function extractContentKeys<T, K extends string = string>(
    registry: ContentRegistry<T, K>
): string[] {
  return Object.keys(registry);
}

/**
 * Transformuje registry obsahu pomocí mapovací funkce
 * @template T Původní typ obsahu
 * @template U Nový typ obsahu
 * @template K Typ klíče obsahu
 * @param registry Původní registry obsahu
 * @param mapFn Funkce pro transformaci každé položky
 * @returns Transformovaný registry obsahu
 */
export function mapContentRegistry<T extends object, U extends object, K extends string = string>(
    registry: ContentRegistry<T, K>,
    mapFn: (content: T, key: string) => U
): ContentRegistry<U, K> {
  const result: ContentRegistry<U, K> = {} as ContentRegistry<U, K>;

  for (const [key, value] of Object.entries(registry)) {
    if (typeof value === 'function') {
      // Pro lazy-loaded obsah
      result[key] = async () => {
        const loadedContent = await (value as Function)();
        // Handle default export from ES modules
        const actualContent = ('default' in loadedContent) ? loadedContent.default : loadedContent;
        return mapFn(actualContent as T, key);
      };
    } else {
      // Pro okamžitý obsah
      result[key] = mapFn(value as T, key);
    }
  }

  return result;
}
</file>

<file path="packages/core/src/engine/GameEngine.ts">
// Importuj správně typy a enumy
import {
  GameEngineOptions,
  GameEngineCoreEvents, // Použij přejmenovaný enum
  GameStartedEventData,
  GameEndedEventData,
  SceneChangedEventData,
  EffectAppliedEventData,
  EngineEventMap, // Import sjednocené mapy
  EngineCoreEventMap, // Import mapy pro core události
} from './types';
import { GameState, GameStateManagerEvents } from '../state/types'; // GameStateManagerEvents z state/types
import { Scene, SceneKey, SceneTransitionOptions } from '../scene/types';
import { Effect } from '../effect/types';
import { EventEmitter } from '../event/EventEmitter';
import { TypedEventEmitter } from '../event/TypedEventEmitter'; // Zkontroluj název souboru!
import { GameStateManager } from '../state'; // GameStateManager z state/index
import { SceneManager } from '../scene/SceneManager';
import { EffectManager } from '../effect/EffectManager';
import { PluginManager } from '../plugin/PluginManager';
import { GenericContentLoader } from '../content/GenericContentLoader';
import { LoaderRegistry } from '../content/LoaderRegistry';
import { SaveManager, SaveEvents, SaveEventMap } from '../save'; // SaveEventMap ze save/index
import { ContentDefinition, ContentRegistry } from '../content/types';
import { Plugin, PluginEvents, PluginEventMap } from '../plugin/types'; // PluginEventMap z plugin/types
import { createSaveManager } from '../save/utils';
import { GameEventType, EventListener } from '../event/types'; // Import z event/types
import { StateManagerPersistenceEvents, PersistedState } from '../state/persistence/types';

/**
 * Hlavní třída herního enginu
 */
export class GameEngine {
  private readonly version: string;
  private readonly eventEmitter: EventEmitter;
  private readonly stateManager: GameStateManager;
  private readonly sceneManager: SceneManager;
  private readonly effectManager: EffectManager;
  private readonly pluginManager: PluginManager;
  private readonly loaderRegistry: LoaderRegistry;
  private readonly saveManager: SaveManager;
  private isRunning: boolean = false;

  constructor(options: GameEngineOptions) {
    const { sceneLoader, initialState = {}, plugins = [], engineVersion = '0.1.0' } = options;

    this.version = engineVersion;
    this.eventEmitter = options.eventEmitter || new EventEmitter();

    // GameStateManager nyní přijímá engine
    this.stateManager = new GameStateManager(this, {
      initialState,
      persistentKeys: options.persistentKeys, // Předání persistentKeys
      onBeforeSerialize: options.onBeforeSerialize, // Předání callbacků
      onAfterDeserialize: options.onAfterDeserialize,
    });

    this.loaderRegistry = new LoaderRegistry();
    this.effectManager = new EffectManager({
      registerDefaultEffects: options.registerDefaultEffects ?? true,
    });
    this.loaderRegistry.registerLoader('scenes', sceneLoader);
    this.sceneManager = new SceneManager(sceneLoader);

    this.pluginManager = new PluginManager(this, this.eventEmitter, {
      autoActivate: options.autoActivatePlugins ?? true,
      allowOverride: options.allowPluginOverride ?? false,
    });

    if (options.saveManager) {
      this.saveManager = options.saveManager;
    } else {
      this.saveManager = createSaveManager(this, {
        storage: options.saveStorage,
        engineVersion: this.version,
        storagePrefix: options.storagePrefix,
        enableAutoSave: options.enableAutoSave,
        autoSaveInterval: options.autoSaveInterval,
        autoSaveSlots: options.autoSaveSlots,
        storageType: options.storageType,
      });
    }

    this.initializePlugins(plugins); // Tato metoda je async
  }

  private async initializePlugins(plugins: Plugin[]): Promise<void> {
    for (const plugin of plugins) {
      // Ošetření chyby při registraci pluginu
      try {
        await this.pluginManager.registerPlugin(plugin);
      } catch (error) {
        console.error(`Failed to register or activate plugin '${plugin.name}':`, error);
        // Emituj engine error
        this.getCoreEventEmitter().emit(GameEngineCoreEvents.ERROR, {
          message: `Plugin registration/activation failed: ${plugin.name}`,
          error,
          context: 'pluginInitialization',
        });
      }
    }
  }

  // --- Typed Emitter Getters ---
  // Vrací typovaný emitter pro všechny události procházející enginem
  public getTypedEventEmitter(): TypedEventEmitter<EngineEventMap> {
    return new TypedEventEmitter<EngineEventMap>(this.eventEmitter);
  }
  // Specifické gettery pro jednotlivé mapy událostí
  public getCoreEventEmitter(): TypedEventEmitter<EngineCoreEventMap> {
    return new TypedEventEmitter<EngineCoreEventMap>(this.eventEmitter);
  }
  public getPluginEventEmitter(): TypedEventEmitter<PluginEventMap> {
    return new TypedEventEmitter<PluginEventMap>(this.eventEmitter);
  }
  public getSaveEventEmitter(): TypedEventEmitter<SaveEventMap> {
    return new TypedEventEmitter<SaveEventMap>(this.eventEmitter);
  }
  public getStateManagerEventEmitter<T extends Record<string, unknown>>(): TypedEventEmitter<
    GameStateManagerEvents<T>
  > {
    return new TypedEventEmitter<GameStateManagerEvents<T>>(this.eventEmitter);
  }
  public getPersistenceEventEmitter<T extends Record<string, unknown>>(): TypedEventEmitter<
    StateManagerPersistenceEvents<T>
  > {
    return new TypedEventEmitter<StateManagerPersistenceEvents<T>>(this.eventEmitter);
  }
  public getGenericEventEmitter(): EventEmitter {
    return this.eventEmitter;
  }
  // ---

  public async start(
    initialSceneKey: SceneKey,
    options?: SceneTransitionOptions
  ): Promise<boolean> {
    if (options?.effects && options.effects.length > 0) {
      this.applyEffects(options.effects);
    }

    const success = await this.sceneManager.transitionToScene(
      initialSceneKey,
      this.stateManager.getState(),
      this
    );

    if (success) {
      this.isRunning = true;
      const startEventData: GameStartedEventData = {
        sceneKey: initialSceneKey,
        transitionData: options?.data,
      };
      // Použij core emitter
      this.getCoreEventEmitter().emit(GameEngineCoreEvents.GAME_STARTED, startEventData);

      const sceneChangeEventData: SceneChangedEventData = {
        scene: this.sceneManager.getCurrentScene()!,
        sceneKey: initialSceneKey,
        transitionData: options?.data,
      };
      // Použij core emitter
      this.getCoreEventEmitter().emit(GameEngineCoreEvents.SCENE_CHANGED, sceneChangeEventData);
    } else {
      console.error(`Failed to start game at scene '${initialSceneKey}'`);
      this.getCoreEventEmitter().emit(GameEngineCoreEvents.ERROR, {
        message: `Failed to start game at scene '${initialSceneKey}'`,
        context: 'startGame',
      });
    }
    return success;
  }

  public end(reason?: string, data: Record<string, any> = {}): void {
    if (!this.isRunning) return;
    this.isRunning = false;
    const eventData: GameEndedEventData = { reason, ...data };
    // Použij core emitter
    this.getCoreEventEmitter().emit(GameEngineCoreEvents.GAME_ENDED, eventData);
  }

  public async transitionToScene(
    sceneKey: SceneKey,
    options?: SceneTransitionOptions
  ): Promise<boolean> {
    if (!this.isRunning) {
      console.warn('Cannot transition: game is not running. Call start() first.');
      return false;
    }
    const previousSceneKey = this.sceneManager.getCurrentSceneKey();
    const previousScene = this.sceneManager.getCurrentScene();

    if (options?.effects && options.effects.length > 0) {
      this.applyEffects(options.effects);
    }

    const success = await this.sceneManager.transitionToScene(
      sceneKey,
      this.stateManager.getState(),
      this
    );

    if (success) {
      const eventData: SceneChangedEventData = {
        scene: this.sceneManager.getCurrentScene()!,
        sceneKey,
        previousScene: previousScene ?? undefined,
        previousSceneKey: previousSceneKey ?? undefined,
        transitionData: options?.data,
      };
      // Použij core emitter
      this.getCoreEventEmitter().emit(GameEngineCoreEvents.SCENE_CHANGED, eventData);
    } else {
      console.error(`Failed to transition to scene '${sceneKey}'`);
      this.getCoreEventEmitter().emit(GameEngineCoreEvents.ERROR, {
        message: `Failed to transition to scene '${sceneKey}'`,
        context: 'transitionScene',
      });
    }
    return success;
  }

  public applyEffects(effects: Effect[]): void {
    if (!effects || effects.length === 0) return;

    const currentState = this.stateManager.getState();
    let newState = currentState; // Inicializace pro případ chyby
    try {
      // Předpokládáme, že EffectManager může pracovat s draftem nebo vrátí nový stav
      this.stateManager.updateState(draftState => {
        // Zde EffectManager *musí* modifikovat draft, pokud má být změna efektivní v rámci jednoho updateState
        // Pokud EffectManager vrací nový stav, logika by byla jiná (méně efektivní s Immer)
        this.effectManager.applyEffects(effects, draftState); // Předpokládáme, že toto modifikuje draftState
      }, 'applyEffects');

      newState = this.stateManager.getState(); // Získání nového stavu po úspěšné aktualizaci

      const eventData: EffectAppliedEventData = {
        effect: effects.length === 1 ? effects[0] : { type: 'batch', effects },
        previousState: currentState,
        newState,
      };
      this.getCoreEventEmitter().emit(GameEngineCoreEvents.EFFECT_APPLIED, eventData);
    } catch (error) {
      console.error('Error applying effects:', error);
      this.getCoreEventEmitter().emit(GameEngineCoreEvents.ERROR, {
        message: `Error applying effects`,
        error,
        context: 'applyEffects',
      });
      // Stav zůstane 'currentState', protože updateState selhal nebo nebyl dokončen
    }
  }

  public applyEffect(effect: Effect): void {
    if (!effect) return;
    this.applyEffects([effect]);
  }

  public registerContent(contentDefinition: ContentDefinition<any>): boolean {
    const { type, content } = contentDefinition;
    const loader = this.loaderRegistry.getLoader<any>(type);
    if (!loader) {
      console.warn(`No loader registered for content type '${type}'`);
      return false;
    }
    try {
      loader.registerContent(content);
      return true;
    } catch (error) {
      console.error(`Failed to register content for type '${type}':`, error);
      this.getCoreEventEmitter().emit(GameEngineCoreEvents.ERROR, {
        message: `Failed to register content for type '${type}'`,
        error,
        context: 'registerContent',
      });
      return false;
    }
  }

  public getLoader<T extends object, K extends string = string>(
    type: string
  ): GenericContentLoader<T, K> | undefined {
    return this.loaderRegistry.getLoader<T, K>(type);
  }

  // Obecné on/off/emit pro flexibilitu
  public on(eventType: GameEventType, listener: EventListener): void {
    this.eventEmitter.on(eventType, listener);
  }
  public off(eventType: GameEventType, listener: EventListener): void {
    this.eventEmitter.off(eventType, listener);
  }
  public emit(eventType: GameEventType, data?: any): void {
    this.eventEmitter.emit(eventType, data);
  }

  // --- Gettery pro managery ---
  public getState(): GameState {
    return this.stateManager.getState();
  }
  public getCurrentScene(): Scene | null {
    return this.sceneManager.getCurrentScene();
  }
  public getCurrentSceneKey(): SceneKey | null {
    return this.sceneManager.getCurrentSceneKey();
  }
  public getVersion(): string {
    return this.version;
  }
  public isGameRunning(): boolean {
    return this.isRunning;
  }
  public getStateManager(): GameStateManager {
    return this.stateManager;
  }
  public getSceneManager(): SceneManager {
    return this.sceneManager;
  }
  public getEffectManager(): EffectManager {
    return this.effectManager;
  }
  public getPluginManager(): PluginManager {
    return this.pluginManager;
  }
  public getLoaderRegistry(): LoaderRegistry {
    return this.loaderRegistry;
  }
  public getSaveManager(): SaveManager {
    return this.saveManager;
  }

  // --- Metody pro pluginy a ukládání ---
  public async registerPlugin(plugin: Plugin): Promise<boolean> {
    return await this.pluginManager.registerPlugin(plugin);
  }
  public async unregisterPlugin(pluginName: string): Promise<boolean> {
    return await this.pluginManager.unregisterPlugin(pluginName);
  }
  public getPlugin<T extends Plugin>(pluginName: string): T | undefined {
    return this.pluginManager.getPlugin<T>(pluginName);
  }
  public async saveGame(saveId: string, options = {}): Promise<boolean> {
    return await this.saveManager.save(saveId, options);
  }
  public async loadGame(saveId: string): Promise<boolean> {
    return await this.saveManager.load(saveId);
  }
  public async restart(
    options: {
      initialState?: Partial<GameState>;
      initialSceneKey?: SceneKey;
    } = {}
  ): Promise<boolean> {
    if (this.isRunning) {
      this.end('restart');
    }
    this.stateManager.resetState(options.initialState);
    const initialSceneKey =
      options.initialSceneKey || this.sceneManager.getCurrentSceneKey() || 'start';
    return await this.start(initialSceneKey);
  }
}
</file>

<file path="packages/core/src/engine/types.ts">
import { Scene, SceneKey } from '../scene';
import { GameState, GameStateManagerEvents, StateManagerPersistenceEvents } from '../state';
import { Effect } from '../effect';
import { Plugin, PluginEventMap } from '../plugin';
import { SaveManager, SaveStorage, SaveEventMap } from '../save';
import { GenericContentLoader } from '../content';
import { EventEmitter } from '../event';

/** Možnosti konfigurace herního enginu */
export interface GameEngineOptions {
  sceneLoader: GenericContentLoader<Scene>;
  initialState?: Partial<GameState>;
  plugins?: Plugin[];
  saveManager?: SaveManager;
  engineVersion?: string;
  eventEmitter?: EventEmitter;
  saveStorage?: SaveStorage;
  allowPluginOverride?: boolean; // Příklad
  storagePrefix?: string; // Příklad
  [key: string]: any;
}

/** Události emitované *přímo* herním enginem (core události) */
export enum GameEngineCoreEvents { // Přejmenováno pro odlišení
  GAME_STARTED = 'game:started',
  GAME_ENDED = 'game:ended',
  SCENE_CHANGED = 'scene:changed', // Scéna se změnila (z pohledu enginu)
  EFFECT_APPLIED = 'effect:applied', // Efekt byl aplikován (z pohledu enginu)
  ERROR = 'engine:error', // Obecná chyba enginu
  // STATE_CHANGED se nyní emituje z GameStateManageru
}

// --- Typy dat pro Core události ---

/** Data předávaná při události startu hry */
export interface GameStartedEventData {
  sceneKey: SceneKey;
  transitionData?: any;
}

/** Data předávaná při události konce hry */
export interface GameEndedEventData {
  reason?: string;
  [key: string]: any;
}

/** Data předávaná při události změny scény */
export interface SceneChangedEventData {
  scene: Scene;
  sceneKey: SceneKey;
  previousScene?: Scene;
  previousSceneKey?: SceneKey;
  transitionData?: any;
}

/** Data předávaná při události aplikace efektu */
export interface EffectAppliedEventData {
  effect: Effect | { type: 'batch'; effects: Effect[] }; // Zahrnuje i batch pro applyEffects
  previousState: GameState;
  newState: GameState;
}

/** Data předávaná při události chyby enginu */
export interface EngineErrorEventData {
  message: string;
  error?: Error | unknown;
  context?: string; // Kde chyba nastala
}

// --- Mapa pro Core události ---
export type EngineCoreEventMap = {
  [GameEngineCoreEvents.GAME_STARTED]: GameStartedEventData;
  [GameEngineCoreEvents.GAME_ENDED]: GameEndedEventData;
  [GameEngineCoreEvents.SCENE_CHANGED]: SceneChangedEventData;
  [GameEngineCoreEvents.EFFECT_APPLIED]: EffectAppliedEventData;
  [GameEngineCoreEvents.ERROR]: EngineErrorEventData;
};

/**
 * Sjednocená mapa VŠECH událostí, které mohou procházet přes engine emitter.
 * Zahrnuje core události, události pluginů, ukládání a stavu.
 * Používá se pro typování hlavního `TypedEventEmitter` v GameEngine.
 * Použití `<any>` pro generické typy stavu je zde kompromis,
 * pokud nechceme mít GameEngine závislý na konkrétním typu T stavu.
 */
export type EngineEventMap = EngineCoreEventMap &
  PluginEventMap &
  SaveEventMap &
  GameStateManagerEvents<any> & // Události runtime stavu
  StateManagerPersistenceEvents<any>; // Události persistence stavu

// Přejmenování enum pro konzistenci (můžeš použít i původní GameEngineEvents, pokud chceš)
export const GameEngineEvents = GameEngineCoreEvents;
</file>

<file path="packages/core/src/plugin/types.ts">
import { GameEngine } from '../engine/GameEngine';

/** Základní rozhraní pro plugin */
export interface Plugin {
  name: string;
  initialize: (engine: GameEngine) => Promise<void> | void;
  destroy?: () => Promise<void> | void;
}

/** Možnosti konfigurace pluginu */
export interface PluginOptions {
  [key: string]: any;
}

/** Možnosti pro registry pluginů */
export interface PluginRegistryOptions {
  autoActivate?: boolean;
  allowOverride?: boolean;
}

/** Události emitované systémem pluginů */
export enum PluginEvents {
  REGISTERED = 'plugin:registered',
  UNREGISTERED = 'plugin:unregistered',
  INITIALIZED = 'plugin:initialized',
  ERROR = 'plugin:error',
}

/** Data předávaná při události registrace pluginu */
export interface PluginRegisteredEventData {
  name: string;
  plugin: Plugin;
}

/** Data předávaná při události odregistrace pluginu */
export interface PluginUnregisteredEventData {
  name: string;
}

/** Data předávaná při události inicializace pluginu */
export interface PluginInitializedEventData {
  name: string;
  plugin: Plugin;
}

/** Data předávaná při události chyby pluginu */
export interface PluginErrorEventData {
  name: string;
  plugin: Plugin;
  error: Error | unknown; // Použij 'unknown' pro lepší typování chyb
  phase: 'initialize' | 'destroy' | string; // Fáze může být i jiná
}

/** Mapa událostí pro systém pluginů */
export type PluginEventMap = {
  [PluginEvents.REGISTERED]: PluginRegisteredEventData;
  [PluginEvents.UNREGISTERED]: PluginUnregisteredEventData;
  [PluginEvents.INITIALIZED]: PluginInitializedEventData;
  [PluginEvents.ERROR]: PluginErrorEventData;
};
</file>

<file path="README.md">
# TextGame Engine

A modular, flexible framework for building interactive narrative experiences and text-based adventure games.

## 🎮 Overview

TextGame Engine is a lightweight but powerful framework designed to simplify the creation of text-based games, interactive fiction, and narrative experiences. It provides the core tools necessary for building engaging stories with branching paths, player choices, state management, and a plugin system for extended functionality.

## 📝 License

This project is licensed under the MIT License - see the LICENSE file for details.
</file>

<file path="packages/core/src/plugin/AbstractPlugin.ts">
import { GameEngine } from '../engine/GameEngine';
import { Plugin, PluginOptions } from './types';
import { GenericContentLoader } from '../content/GenericContentLoader';
import { Effect, EffectProcessor } from '../effect/types';
import { GameState } from '../state/types'; // GameState zůstává ze state/types
import { GameEventType, EventListener } from '../event/types'; // Opravený import
import { SceneKey, SceneTransitionOptions } from '../scene/types'; // Přidán import SceneTransitionOptions

/**
 * Abstraktní základní třída pro pluginy
 */
export abstract class AbstractPlugin<Options extends PluginOptions = PluginOptions>
  implements Plugin
{
  public readonly name: string;
  protected options: Options;
  protected engine: GameEngine | null = null;
  protected loaders: Map<string, GenericContentLoader<any>> = new Map();
  protected registeredEffects: Set<string> = new Set();
  private eventListeners: Map<GameEventType, Set<EventListener>> = new Map();

  constructor(name: string, options: Options) {
    this.name = name;
    this.options = options;
    this.setupLoaders();
  }

  protected setupLoaders(): void {
    // Přepište v potomkovi pro registraci specifických loaderů
  }

  public async initialize(engine: GameEngine): Promise<void> {
    this.engine = engine;

    this.loaders.forEach((loader, type) => {
      engine.getLoaderRegistry().registerLoader(type, loader);
    });

    await this.registerContent();
    this.registerEventHandlers();
    this.setupEffectProcessors(); // <-- Přejmenovaná metoda
    await this.onInitialize();
  }

  protected async registerContent(): Promise<void> {
    // Přepište v potomkovi pro registraci specifického obsahu
  }

  protected registerEventHandlers(): void {
    // Přepište v potomkovi pro registraci specifických posluchačů událostí
  }

  /**
   * Nastavuje (setup) procesory efektů specifické pro plugin.
   * Přepište tuto metodu pro registraci procesorů specifických pro plugin.
   * Uvnitř této metody můžete volat `this.registerEffectProcessors(...)` s mapou procesorů.
   */
  protected setupEffectProcessors(): void {
    // <-- PŘEJMENOVANÁ HOOK METODA
    // Přepište v potomkovi pro registraci specifických procesorů efektů
    // Příklad v potomkovi:
    // const myProcessors = { 'myEffect': (effect, state) => { ... } };
    // this.registerEffectProcessors(myProcessors);
  }

  protected async onInitialize(): Promise<void> {
    // Přepište v potomkovi pro logiku specifickou pro plugin
  }

  public async destroy(): Promise<void> {
    if (this.engine) {
      this.unregisterEventHandlers();
      this.unregisterEffectProcessors();
      await this.onDestroy();

      this.loaders.forEach((_, type) => {
        this.engine?.getLoaderRegistry().removeLoader(type);
      });
      this.engine = null;
    }
  }

  protected unregisterEventHandlers(): void {
    if (this.engine) {
      this.eventListeners.forEach((listeners, eventType) => {
        listeners.forEach(listener => {
          // Použijeme obecný emitter pro odregistraci
          this.engine?.getGenericEventEmitter().off(eventType, listener);
        });
      });
      this.eventListeners.clear();
    }
  }

  protected unregisterEffectProcessors(): void {
    if (this.engine) {
      this.engine.getEffectManager().unregisterNamespace(this.name);
      this.registeredEffects.clear();
    }
  }

  protected async onDestroy(): Promise<void> {
    // Přepište v potomkovi pro logiku čištění specifickou pro plugin
  }

  protected getState(): GameState | undefined {
    return this.engine?.getState();
  }

  protected getLoader<T extends object, K extends string = string>(
    type: string
  ): GenericContentLoader<T, K> | undefined {
    return this.engine?.getLoaderRegistry().getLoader<T, K>(type);
  }

  private namespaceEffectType(effectType: string): string {
    // Jednoduchý check, zda už namespace obsahuje - pro případ volání s již namespacovaným typem
    return effectType.includes(':') ? effectType : `${this.name}:${effectType}`;
  }

  protected registerEffectProcessor(effectType: string, processor: EffectProcessor): void {
    if (this.engine) {
      const namespacedType = this.namespaceEffectType(effectType);
      // Registrace přes EffectManager s namespacovaným typem
      this.engine.getEffectManager().registerEffectProcessor(namespacedType, processor);
      this.registeredEffects.add(namespacedType); // Sledujeme namespacovaný typ
    }
  }

  /**
   * Registruje více procesorů efektů najednou s automatickým namespacingem.
   * Tuto metodu volejte z `setupEffectProcessors` nebo `onInitialize`.
   *
   * @param processors Objekt mapující typy efektů na procesory
   */
  protected registerEffectProcessors(processors: Record<string, EffectProcessor>): void {
    // <-- HELPER METODA ZŮSTÁVÁ
    if (!this.engine) return;

    const namespacedProcessors: Record<string, EffectProcessor> = {};
    for (const [type, processor] of Object.entries(processors)) {
      const namespacedType = this.namespaceEffectType(type);
      namespacedProcessors[namespacedType] = processor;
      this.registeredEffects.add(namespacedType);
    }
    // Registrace přes EffectManager
    this.engine.getEffectManager().registerEffectProcessors(namespacedProcessors);
  }

  protected emitNamespacedEvent(eventType: string, data?: any): void {
    if (this.engine) {
      const namespacedType = eventType.includes(':') ? eventType : `${this.name}:${eventType}`;
      // Použijeme obecný emit enginu
      this.engine.emit(namespacedType, data);
    }
  }

  protected registerEventListener(eventType: GameEventType, listener: EventListener): void {
    if (this.engine) {
      // Registrace přes obecný emitter enginu
      this.engine.getGenericEventEmitter().on(eventType, listener);
      if (!this.eventListeners.has(eventType)) {
        this.eventListeners.set(eventType, new Set());
      }
      this.eventListeners.get(eventType)!.add(listener);
    }
  }

  protected unregisterEventListener(eventType: GameEventType, listener: EventListener): void {
    if (this.engine) {
      // Odregistrace přes obecný emitter enginu
      this.engine.getGenericEventEmitter().off(eventType, listener);
      const listeners = this.eventListeners.get(eventType);
      if (listeners) {
        listeners.delete(listener);
        if (listeners.size === 0) {
          this.eventListeners.delete(eventType);
        }
      }
    }
  }

  protected async transitionToScene(
    sceneKey: SceneKey,
    options?: SceneTransitionOptions // Použij importovaný typ
  ): Promise<boolean> {
    if (!this.engine) return false;
    return await this.engine.transitionToScene(sceneKey, options);
  }

  protected applyEffect(effect: Effect): void {
    if (!this.engine) return;
    this.engine.applyEffect(effect);
  }

  protected applyEffects(effects: Effect[]): void {
    if (!this.engine) return;
    this.engine.applyEffects(effects);
  }
}
</file>

<file path="packages/core/src/save/SaveManager.ts">
import {
  SaveData,
  SaveMetadata,
  SaveOptions,
  SaveStorage,
  AutoSaveOptions,
  SaveEvents,
  SaveEventMap, // Import mapy událostí
  GameSavedEventData,
  GameLoadedEventData,
  GameDeletedEventData,
  AllSavesClearedEventData,
  StorageChangedEventData,
  AutoSaveEnabledEventData,
  AutoSaveDisabledEventData,
} from './types';
import { GameEngine } from '../engine/GameEngine';
// EventEmitter a TypedEventEmitter už by neměly být potřeba přímo zde
// import { EventEmitter } from '../event/EventEmitter';
// import { TypedEventEmitter } from '../event/TypedEventEmmitter';
import { SceneKey } from '../scene/types';
import { GameStateManager } from '../state/GameStateManager';
import { StateConverter } from '../state/persistence/StateConverter';
import { StateMigrationService } from '../state/persistence/StateMigrationService';
import { PersistedState, StateManagerPersistenceEvents } from '../state/persistence/types';

const CURRENT_SAVE_DATA_FORMAT_VERSION = 1;

/**
 * Správce ukládání a načítání her
 * @template T Typ proměnných ve stavu hry
 */
export class SaveManager<T extends Record<string, unknown> = Record<string, unknown>> {
  private engine: GameEngine;
  private storage: SaveStorage;
  private readonly saveDataFormatVersion: number;
  private readonly engineVersion: string;
  private autoSaveTimer: ReturnType<typeof setInterval> | null = null; // Použij správný typ
  private autoSaveOptions: AutoSaveOptions | null = null;
  private autoSaveCounter: number = 0;
  private gameStartTime: number;
  private totalPlayTime: number = 0;
  private readonly quickSaveId: string = 'quicksave';
  private stateConverter: typeof StateConverter; // Statické reference
  private stateMigrationService: typeof StateMigrationService; // Statické reference

  constructor(
    engine: GameEngine,
    options: {
      storage: SaveStorage;
      engineVersion?: string;
      saveDataFormatVersion?: number;
      // eventEmitter?: EventEmitter; // Už není potřeba předávat emitter
      stateConverter?: typeof StateConverter;
      stateMigrationService?: typeof StateMigrationService;
    }
  ) {
    this.engine = engine;
    this.storage = options.storage;
    this.engineVersion =
      options.engineVersion ||
      (typeof engine.getVersion === 'function' ? engine.getVersion() : '0.1.0');
    this.saveDataFormatVersion = options.saveDataFormatVersion || CURRENT_SAVE_DATA_FORMAT_VERSION;
    this.gameStartTime = Date.now();
    this.stateConverter = options.stateConverter || StateConverter;
    this.stateMigrationService = options.stateMigrationService || StateMigrationService;
    this.setupEventListeners();
  }

  private setupEventListeners(): void {
    // Naslouchání na core události z enginu
    this.engine.getCoreEventEmitter().on('gameStarted', () => {
      console.log('SaveManager: Game started event received. Resetting play time.');
      this.gameStartTime = Date.now();
      this.totalPlayTime = 0;
    });

    // Naslouchání na save události (emitované SaveManagerem samotným přes engine)
    this.engine.getSaveEventEmitter().on(SaveEvents.GAME_LOADED, data => {
      // Typ dat je z SaveEventMap
      if (data.success) {
        console.log(
          'SaveManager: Game loaded event received. Setting play time from metadata and resetting start time.'
        );
        this.gameStartTime = Date.now();
      }
    });
  }

  public async save(saveId: string, options: SaveOptions = {}): Promise<boolean> {
    // Odstraněna kontrola `typeof saveId !== 'string'`
    if (!saveId) {
      console.error('SaveManager: Invalid save ID provided (empty string).', saveId);
      const errorData: GameSavedEventData = { saveId, success: false, error: 'invalid id' };
      this.engine.getSaveEventEmitter().emit(SaveEvents.GAME_SAVED, errorData);
      return false;
    }

    this.updatePlayTime();
    const gameStateManager = this.engine.getStateManager<T>();
    const currentState = gameStateManager.getState();
    const persistentKeys = gameStateManager.getPersistentKeys();

    const metadata: SaveMetadata = {
      id: saveId, // ID by mělo být nastaveno zde, ne přepsáno z options níže
      name: options.name || this.generateDefaultSaveName(),
      createdAt: Date.now(),
      updatedAt: Date.now(),
      playTime: this.totalPlayTime,
      engineVersion: this.engineVersion,
      // Opravené názvy verzí podle SaveMetadata
      saveDataFormatVersion: this.saveDataFormatVersion,
      stateFormatVersion: this.stateMigrationService.getCurrentStateFormatVersion(),
      currentSceneKey: this.engine.getCurrentSceneKey(),
      // Zkopírujeme POUZE bezpečné vlastnosti z options
      thumbnail: options.thumbnail,
      // Můžete přidat další povolené klíče z options
      ...(options.customData && { customData: options.customData }), // Příklad pro vlastní data
    };

    let serializedState: string;
    try {
      // Získání typovaného emitteru pro persistenci z enginu
      const persistenceEmitter = this.engine.getPersistenceEventEmitter<T>();
      serializedState = this.stateConverter.serialize(
        currentState,
        persistentKeys,
        { includeMetadata: true, replacer: options.replacer },
        gameStateManager.getOnBeforeSerializeCallback(),
        persistenceEmitter // <-- Předání bez přetypování
      );
    } catch (error) {
      console.error(`SaveManager: Failed to serialize game state for save id '${saveId}':`, error);
      const errorData: GameSavedEventData = { saveId, metadata, success: false, error };
      this.engine.getSaveEventEmitter().emit(SaveEvents.GAME_SAVED, errorData);
      return false;
    }

    const saveData: SaveData = { metadata, state: serializedState };

    try {
      const success = await this.storage.save(saveId, saveData);
      const eventData: GameSavedEventData = {
        saveId,
        metadata,
        success,
        error: success ? undefined : 'storage failed',
      };
      this.engine.getSaveEventEmitter().emit(SaveEvents.GAME_SAVED, eventData);
      return success;
    } catch (error) {
      console.error(`SaveManager: Failed to save game to storage for id '${saveId}':`, error);
      const errorData: GameSavedEventData = { saveId, metadata, success: false, error };
      this.engine.getSaveEventEmitter().emit(SaveEvents.GAME_SAVED, errorData);
      return false;
    }
  }

  public async load(saveId: string): Promise<boolean> {
    if (!saveId) {
      // Pouze kontrola na prázdný řetězec
      console.error('SaveManager: Invalid save ID provided for loading.', saveId);
      const errorData: GameLoadedEventData = { saveId, success: false, error: 'invalid id' };
      this.engine.getSaveEventEmitter().emit(SaveEvents.GAME_LOADED, errorData);
      return false;
    }

    let saveData: SaveData | null;
    try {
      saveData = await this.storage.load(saveId);
    } catch (error) {
      console.error(`SaveManager: Failed to load data from storage for id '${saveId}':`, error);
      const errorData: GameLoadedEventData = { saveId, success: false, error };
      this.engine.getSaveEventEmitter().emit(SaveEvents.GAME_LOADED, errorData);
      return false;
    }

    if (!saveData) {
      console.error(`SaveManager: Save with id '${saveId}' not found in storage.`);
      const errorData: GameLoadedEventData = { saveId, success: false, error: 'not found' };
      this.engine.getSaveEventEmitter().emit(SaveEvents.GAME_LOADED, errorData);
      return false;
    }

    // Validace a migrace SaveData formátu
    let migratedSaveData = this.migrateSaveDataFormatIfNeeded(saveData);
    if (!migratedSaveData) {
      console.error(`SaveManager: Failed to migrate SaveData format for id '${saveId}'.`);
      const errorData: GameLoadedEventData = {
        saveId,
        success: false,
        error: 'SaveData format migration failed',
      };
      this.engine.getSaveEventEmitter().emit(SaveEvents.GAME_LOADED, errorData);
      return false;
    }
    saveData = migratedSaveData;

    try {
      const gameStateManager = this.engine.getStateManager<T>();
      // Získání typovaného emitteru pro persistenci z enginu
      const persistenceEmitter = this.engine.getPersistenceEventEmitter<T>();

      const migratedPersistedState = this.stateConverter.deserialize<T>(
        saveData.state,
        {},
        undefined, // Callback se volá v GameStateManageru
        persistenceEmitter // <-- Předání bez přetypování
      );

      // GameStateManager.applyPersistentState nyní volá onAfterDeserialize callback
      gameStateManager.applyPersistentState(migratedPersistedState, 'loadGame');

      this.totalPlayTime = saveData.metadata.playTime || 0;
      // this.gameStartTime = Date.now(); // Toto se děje v listeneru

      const currentSceneKey = saveData.metadata.currentSceneKey;
      if (currentSceneKey) {
        // Použijeme engine pro přechod, ne voláme metodu SceneManageru přímo
        await this.engine.transitionToScene(currentSceneKey as SceneKey, {
          // data: saveData.metadata.customData // Příklad předání custom dat
        });
      } else {
        console.warn(
          `SaveManager: Save data for id '${saveId}' does not contain current scene key.`
        );
      }

      console.log(`SaveManager: Game loaded successfully with id '${saveId}'.`);
      const eventData: GameLoadedEventData = { saveId, metadata: saveData.metadata, success: true };
      this.engine.getSaveEventEmitter().emit(SaveEvents.GAME_LOADED, eventData);
      return true;
    } catch (error) {
      console.error(
        `SaveManager: Failed to process and apply loaded state for id '${saveId}':`,
        error
      );
      const errorData: GameLoadedEventData = { saveId, success: false, error };
      this.engine.getSaveEventEmitter().emit(SaveEvents.GAME_LOADED, errorData);
      return false;
    }
  }

  public async getSaves(): Promise<Record<string, SaveMetadata>> {
    try {
      return await this.storage.list();
    } catch (error) {
      console.error('SaveManager: Failed to list saves from storage:', error);
      return {};
    }
  }

  public async deleteSave(saveId: string): Promise<boolean> {
    if (!saveId) {
      console.error('SaveManager: Invalid save ID provided for deletion.', saveId);
      const errorData: GameDeletedEventData = { saveId, success: false, error: 'invalid id' };
      this.engine.getSaveEventEmitter().emit(SaveEvents.GAME_DELETED, errorData);
      return false;
    }
    try {
      const success = await this.storage.delete(saveId);
      const eventData: GameDeletedEventData = {
        saveId,
        success,
        error: success ? undefined : 'storage failed or not found',
      };
      this.engine.getSaveEventEmitter().emit(SaveEvents.GAME_DELETED, eventData);
      return success;
    } catch (error) {
      console.error(`SaveManager: Failed to delete game with id '${saveId}' from storage:`, error);
      const errorData: GameDeletedEventData = { saveId, success: false, error };
      this.engine.getSaveEventEmitter().emit(SaveEvents.GAME_DELETED, errorData);
      return false;
    }
  }

  public async quickSave(): Promise<boolean> {
    console.log('SaveManager: Performing quick save...');
    return await this.save(this.quickSaveId, {
      name: 'Rychlé uložení',
      isQuickSave: true, // Příklad custom data v metadatech
    });
  }

  public async quickLoad(): Promise<boolean> {
    console.log('SaveManager: Attempting quick load...');
    try {
      const exists = await this.storage.exists(this.quickSaveId);
      if (!exists) {
        console.warn('SaveManager: No quicksave found to load.');
        // Neemitujeme GAME_LOADED error zde, load() to udělá, pokud je voláno
        return false;
      }
      return await this.load(this.quickSaveId);
    } catch (error) {
      console.error('SaveManager: Failed to check existence or load quicksave:', error);
      // Emit error? load() by měl emitovat chybu, pokud selže
      return false;
    }
  }

  public enableAutoSave(options: AutoSaveOptions = {}): void {
    this.disableAutoSave();
    const interval = options.interval || 5 * 60 * 1000;
    const slots = options.slots || 3;
    if (interval <= 0 || slots <= 0 || !Number.isInteger(slots)) {
      console.error('SaveManager: Invalid auto-save interval or slots.');
      return;
    }

    this.autoSaveOptions = {
      interval,
      slots,
      prefix: options.prefix || 'auto',
      beforeSave: options.beforeSave,
      afterSave: options.afterSave,
    };

    this.autoSaveTimer = setInterval(() => {
      this.performAutoSave().catch(error => {
        console.error('SaveManager: Uncaught error during auto-save execution:', error);
      });
    }, this.autoSaveOptions.interval);

    console.log(`SaveManager: Auto-save enabled with interval ${interval}ms and ${slots} slots.`);
    const eventData: AutoSaveEnabledEventData = { options: this.autoSaveOptions };
    this.engine.getSaveEventEmitter().emit(SaveEvents.AUTO_SAVE_ENABLED, eventData);
  }

  public disableAutoSave(): void {
    if (this.autoSaveTimer !== null) {
      clearInterval(this.autoSaveTimer);
      this.autoSaveTimer = null;
      this.autoSaveOptions = null;
      this.autoSaveCounter = 0;
      console.log('SaveManager: Auto-save disabled.');
      const eventData: AutoSaveDisabledEventData = {};
      this.engine.getSaveEventEmitter().emit(SaveEvents.AUTO_SAVE_DISABLED, eventData);
    }
  }

  private async performAutoSave(): Promise<boolean> {
    if (!this.autoSaveOptions || this.autoSaveTimer === null) return false;

    if (this.autoSaveOptions.beforeSave) {
      try {
        const shouldSave = await Promise.resolve(this.autoSaveOptions.beforeSave());
        if (!shouldSave) {
          console.log('SaveManager: Auto-save skipped by beforeSave callback.');
          return false;
        }
      } catch (error) {
        console.error('SaveManager: Error in auto-save beforeSave callback:', error);
        return false;
      }
    }

    const autoSaveSlotIndex = this.autoSaveCounter % this.autoSaveOptions.slots;
    this.autoSaveCounter++;
    const saveId = `${this.autoSaveOptions.prefix}_${autoSaveSlotIndex}`;
    const saveName = `Automatické uložení ${autoSaveSlotIndex + 1}`;

    console.log(
      `SaveManager: Performing auto-save to slot ${autoSaveSlotIndex + 1} (id: ${saveId}).`
    );
    const success = await this.save(saveId, {
      name: saveName,
      isAutoSave: true, // Příklad custom data
      autoSaveSlot: autoSaveSlotIndex + 1, // Příklad custom data
    });

    if (success && this.autoSaveOptions.afterSave) {
      try {
        await Promise.resolve(this.autoSaveOptions.afterSave(saveId));
      } catch (error) {
        console.error('SaveManager: Error in auto-save afterSave callback:', error);
      }
    }
    return success;
  }

  private generateDefaultSaveName(): string {
    const now = new Date();
    const dateOptions: Intl.DateTimeFormatOptions = {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
    };
    const timeOptions: Intl.DateTimeFormatOptions = {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
    };
    const dateStr = now.toLocaleDateString(undefined, dateOptions);
    const timeStr = now.toLocaleTimeString(undefined, timeOptions);
    const sceneTitle = this.engine.getCurrentScene()?.title || 'Neznámá scéna';
    return `${sceneTitle} - ${dateStr} ${timeStr}`;
  }

  private updatePlayTime(): void {
    const now = Date.now();
    if (this.gameStartTime) {
      // Přidána kontrola pro jistotu
      this.totalPlayTime += now - this.gameStartTime;
    }
    this.gameStartTime = now;
  }

  /**
   * Migruje formát SaveData objektu (metadata atd.), NE formát stavu.
   * @param saveData Data k migraci.
   * @returns Migrovaná data nebo null při selhání.
   */
  private migrateSaveDataFormatIfNeeded(saveData: SaveData): SaveData | null {
    let currentSaveData = { ...saveData }; // Pracujeme s kopií

    if (!currentSaveData.metadata) {
      console.error('SaveManager: Cannot migrate SaveData missing metadata.');
      return null;
    }

    // Získání nebo inicializace verze SaveData formátu
    let currentFormatVersion =
      typeof currentSaveData.metadata.saveDataFormatVersion === 'number'
        ? currentSaveData.metadata.saveDataFormatVersion
        : 0; // Předpokládáme verzi 0, pokud chybí

    // Pokud je verze nižší než aktuální cílová verze SaveData formátu
    if (currentFormatVersion < this.saveDataFormatVersion) {
      console.log(
        `SaveManager: Migrating SaveData format for id '${currentSaveData.metadata.id}' from version ${currentFormatVersion} to ${this.saveDataFormatVersion}.`
      );

      // Migrace z 0 na 1 (Příklad: přejmenování saveVersion na stateFormatVersion, přidání saveDataFormatVersion)
      if (currentFormatVersion === 0 && this.saveDataFormatVersion >= 1) {
        // Přejmenování/přesun 'saveVersion' (pokud existovala a znamenala verzi stavu) na 'stateFormatVersion'
        if (
          typeof (currentSaveData.metadata as any).saveVersion === 'number' &&
          typeof currentSaveData.metadata.stateFormatVersion !== 'number'
        ) {
          currentSaveData.metadata.stateFormatVersion = (
            currentSaveData.metadata as any
          ).saveVersion;
          console.log(
            `SaveManager: Migrated old 'saveVersion' field to 'stateFormatVersion' in SaveData metadata.`
          );
        }
        delete (currentSaveData.metadata as any).saveVersion; // Odstranění starého pole

        // Nastavení saveDataFormatVersion na 1
        currentSaveData.metadata.saveDataFormatVersion = 1;
        currentFormatVersion = 1; // Aktualizace pro další případné migrace
        console.log(`SaveManager: Applied SaveData format migration from 0 to 1.`);
      }

      // Zde přidat další migrační kroky pro SaveData formát (např. 1 -> 2)
      // if (currentFormatVersion === 1 && this.saveDataFormatVersion >= 2) {
      //     // ... logika migrace SaveData formátu 1 -> 2 ...
      //     currentSaveData.metadata.saveDataFormatVersion = 2;
      //     currentFormatVersion = 2;
      //     console.log(`SaveManager: Applied SaveData format migration from 1 to 2.`);
      // }

      // Kontrola, zda migrace dosáhla cílové verze
      if (currentFormatVersion !== this.saveDataFormatVersion) {
        console.warn(
          `SaveManager: Could not fully migrate SaveData format to target version ${this.saveDataFormatVersion}. Current version after migration: ${currentFormatVersion}.`
        );
        // Můžete se rozhodnout vrátit null nebo částečně migrovaná data
      }
    }

    // Zajistíme, že stateFormatVersion existuje (pro stará uložení bez něj)
    if (typeof currentSaveData.metadata.stateFormatVersion !== 'number') {
      console.warn(
        `SaveManager: SaveData metadata for id '${currentSaveData.metadata.id}' missing 'stateFormatVersion'. Assuming version 0.`
      );
      currentSaveData.metadata.stateFormatVersion = 0;
    }

    return currentSaveData;
  }

  public getPlayTime(): number {
    return this.totalPlayTime + (Date.now() - (this.gameStartTime || Date.now())); // Přidána fallback hodnota pro gameStartTime
  }

  public formatPlayTime(timeMs?: number): string {
    // Použijeme utilitu z utils
    const time = timeMs !== undefined ? timeMs : this.getPlayTime();
    // return formatPlayTimeUtil(time); // Předpokládá existenci formatPlayTimeUtil v utils
    // Dočasná implementace:
    const seconds = Math.floor((time / 1000) % 60);
    const minutes = Math.floor((time / (1000 * 60)) % 60);
    const hours = Math.floor(time / (1000 * 60 * 60));
    return [
      hours.toString().padStart(2, '0'),
      minutes.toString().padStart(2, '0'),
      seconds.toString().padStart(2, '0'),
    ].join(':');
  }

  public async clearAllSaves(): Promise<boolean> {
    console.log('SaveManager: Attempting to clear all saves...');
    try {
      let success = false;
      if (typeof this.storage.clearAll === 'function') {
        success = await this.storage.clearAll();
      } else {
        console.warn(
          'SaveManager: Storage does not implement clearAll. Deleting saves individually.'
        );
        const saves = await this.getSaves();
        const saveIds = Object.keys(saves);
        if (saveIds.length === 0) {
          success = true; // Nic ke smazání
        } else {
          const results = await Promise.all(saveIds.map(id => this.deleteSave(id)));
          success = results.every(result => result);
        }
      }

      console.log(`SaveManager: Clear all saves ${success ? 'successful' : 'failed'}.`);
      const eventData: AllSavesClearedEventData = {
        success,
        error: success ? undefined : 'clear failed',
      };
      this.engine.getSaveEventEmitter().emit(SaveEvents.ALL_SAVES_CLEARED, eventData);
      return success;
    } catch (error) {
      console.error('SaveManager: Failed to clear all saves:', error);
      const eventData: AllSavesClearedEventData = { success: false, error };
      this.engine.getSaveEventEmitter().emit(SaveEvents.ALL_SAVES_CLEARED, eventData);
      return false;
    }
  }

  public getStorage(): SaveStorage {
    return this.storage;
  }

  public setStorage(storage: SaveStorage): void {
    this.storage = storage;
    console.log('SaveManager: Storage changed.');
    const eventData: StorageChangedEventData = { storage };
    this.engine.getSaveEventEmitter().emit(SaveEvents.STORAGE_CHANGED, eventData);
  }

  public getSaveDataFormatVersion(): number {
    return this.saveDataFormatVersion;
  }

  public getStateFormatVersion(): number {
    return this.stateMigrationService.getCurrentStateFormatVersion();
  }
}
</file>

<file path="packages/core/src/utils/index.ts">
// Reexport utilit pro immer
export * from './immer';

// Reexport utilit pro UUID
export * from './uuid';

// Reexport utilit pro práci s objekty
export * from './object';

// Reexport utilities pro vytvoření enginu
export * from '../engine/utils';

// Reexport utility pro SaveManager
export * from '../save/utils';
</file>

<file path="packages/core/package.json">
{
  "name": "@pabitel/core",
  "version": "0.1.0",
  "description": "A minimalist framework for building text-based games and interactive narratives",
  "license": "MIT",
  "main": "dist/index.js",
  "module": "dist/index.esm.js",
  "types": "dist/index.d.ts",
  "files": [
    "dist"
  ],
  "exports": {
    ".": {
      "import": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.esm.js"
      },
      "require": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.js"
      },
      "development": "./src/index.ts"
    },
    "./package.json": "./package.json"
  },
  "scripts": {
    "build": "tsc && rollup -c",
    "dev": "tsc --watch",
    "test": "jest",
    "lint": "eslint src --ext .ts",
    "lint:fix": "eslint src --ext .ts --fix",
    "format": "prettier --write \"src/**/*.ts\"",
    "format:check": "prettier --check \"src/**/*.ts\"",
    "prepublishOnly": "npm run lint && npm run test && npm run build"
  },
  "devDependencies": {
    "@eslint/js": "^9.23.0",
    "@rollup/plugin-commonjs": "^28.0.3",
    "@rollup/plugin-node-resolve": "^16.0.1",
    "@types/jest": "^29.5.14",
    "@types/lodash": "^4.17.16",
    "@types/uuid": "^10.0.0",
    "@typescript-eslint/eslint-plugin": "^8.29.0",
    "@typescript-eslint/parser": "^8.29.0",
    "eslint": "^9",
    "eslint-config-prettier": "^10",
    "eslint-plugin-prettier": "^5",
    "jest": "^29.7.0",
    "prettier": "^3",
    "rollup": "^4",
    "rollup-plugin-typescript2": "^0.36.0",
    "ts-jest": "^29.3.1",
    "typescript": "^5.8.2"
  },
  "author": "Jakub Hájek",
  "repository": {
    "type": "git",
    "url": "https://github.com/jimmyhayek/textgame.git"
  },
  "keywords": [
    "text-game",
    "interactive-fiction",
    "game-engine",
    "narrative",
    "text-adventure"
  ],
  "dependencies": {
    "immer": "^10.1.1",
    "lodash": "^4.17.21",
    "uuid": "^11.1.0"
  }
}
</file>

<file path="packages/core/src/index.ts">
export * from './event';

export { GameEngine, createGameEngine } from './engine';
export { GameEngineOptions, GameEngineEvents } from './engine/types';

export * from './scene';
export * from './state';
export * from './content';
export * from './effect';
export * from './plugin';
export * from './save';
export * from './utils';
</file>

</files>
