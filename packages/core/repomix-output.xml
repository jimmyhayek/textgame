This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
src/
  content/
    GenericContentLoader.ts
    index.ts
    LoaderRegistry.ts
    types.ts
    utils.ts
  effect/
    EffectManager.ts
    index.ts
    processors.ts
    types.ts
    utils.ts
  engine/
    GameEngine.ts
    index.ts
    types.ts
    utils.ts
  event/
    EventEmitter.ts
    index.ts
    TypedEventEmmiter.ts
    types.ts
    utils.ts
  loaders/
    GenericContentLoader.ts
    index.ts
    LoaderRegistry.ts
  plugin/
    AbstractPlugin.ts
    index.ts
    PluginManager.ts
    types.ts
    utils.ts
  save/
    index.ts
    MemoryStorage.ts
    SaveManager.ts
    types.ts
    utils.ts
  scene/
    index.ts
    SceneManager.ts
    types.ts
    utils.ts
  state/
    index.ts
    StateManager.ts
    types.ts
    utils.ts
  utils/
    immer.ts
    index.ts
    object.ts
    uuid.ts
  index.ts
test/
  integration/
    GameEngine.integration.test.ts
  unit/
    SaveManager.test.ts
.prettierignore
.prettierrc.js
eslint.config.mjs
jest.config.js
LICENSE
package.json
README.md
rollup.config.js
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/content/GenericContentLoader.ts">
import { produce } from '../utils/immer';
import { ContentRegistry, ContentLoaderOptions } from './types';

/**
 * Generický loader pro herní obsah s podporou lazy-loadingu
 * @template T Typ načítaného obsahu
 * @template K Typ identifikátoru obsahu (obvykle string)
 */
export class GenericContentLoader<T extends object, K extends string = string> {
    /** Cache načteného obsahu */
    private loadedContent: Map<string, T> = new Map();

    /** Promise pro obsah, který se právě načítá */
    private loadingPromises: Map<string, Promise<T>> = new Map();

    /** Registry definic obsahu s podporou lazy-loadingu */
    private registry: ContentRegistry<T, K> = {} as ContentRegistry<T, K>;

    /**
     * Vytvoří nový content loader
     * @param options Konfigurační možnosti loaderu
     */
    constructor(options: ContentLoaderOptions<T, K> = {}) {
        const { initialRegistry = {} as ContentRegistry<T, K> } = options;
        this.registry = { ...initialRegistry };
    }

    /**
     * Registruje definice obsahu do loaderu
     * @param registry Registry s definicemi nebo funkcemi pro lazy-loading
     */
    public registerContent(registry: ContentRegistry<T, K>): void {
        this.registry = produce(this.registry, (draft) => {
            Object.assign(draft, registry);
        });
    }

    /**
     * Registruje všechen obsah z registry
     * @param registry Registry s definicemi nebo funkcemi pro lazy-loading
     */
    public registerAll(registry: ContentRegistry<T, K>): void {
        this.registerContent(registry);
    }

    /**
     * Načte obsah podle klíče, podporuje jak okamžitý, tak lazy-loaded obsah
     * @param key Klíč obsahu
     * @returns Promise, který se vyřeší načteným obsahem
     * @throws Error pokud obsah s daným klíčem není v registry
     */
    public async loadContent(key: string): Promise<T> {
        // Vrátit z cache, pokud již je načten
        if (this.loadedContent.has(key)) {
            return this.loadedContent.get(key)!;
        }

        // Vrátit existující promise, pokud se již načítá
        if (this.loadingPromises.has(key)) {
            return this.loadingPromises.get(key)!;
        }

        const contentDefOrImport = this.registry[key];

        if (!contentDefOrImport) {
            throw new Error(`Content with key "${key}" not found in registry`);
        }

        let loadPromise: Promise<T>;

        if (typeof contentDefOrImport === 'function') {
            // Zpracování lazy-loaded obsahu
            const loadFunction = contentDefOrImport as () => Promise<T | { default: T }>;
            loadPromise = loadFunction().then((module): T => {
                // Kontrola, zda máme default export (ES module) nebo přímý obsah
                const content = this.isMo
</file>

<file path="src/content/index.ts">
// Export typů
export * from './types';

// Export hlavních tříd
export { GenericContentLoader } from './GenericContentLoader';
export { LoaderRegistry } from './LoaderRegistry';

// Export utilit
export {
    createContentLoader,
    defineContent,
    mergeContentRegistries,
    generateContentKey,
    extractContentKeys,
    mapContentRegistry
} from './utils';
</file>

<file path="src/content/LoaderRegistry.ts">
import { GenericContentLoader } from './GenericContentLoader';

/**
 * Registry pro správu multiple content loaderů
 * Poskytuje centrální bod pro registraci a přístup k loaderům pro různé typy obsahu
 */
export class LoaderRegistry {
    /** Mapa loaderů organizovaná podle typu */
    private loaders: Map<string, GenericContentLoader<any, any>> = new Map();

    /**
     * Registruje loader pro specifický typ obsahu
     * @param type Identifikátor typu obsahu
     * @param loader Instance loaderu pro daný typ obsahu
     * @returns Instance registru pro řetězení
     */
    public registerLoader<T extends object, K extends string = string>(
        type: string,
        loader: GenericContentLoader<T, K>
    ): LoaderRegistry {
        this.loaders.set(type, loader);
        return this;
    }

    /**
     * Získá loader pro specifický typ obsahu
     * @template T Typ obsahu
     * @template K Typ klíče obsahu
     * @param type Identifikátor typu obsahu
     * @returns Instance loaderu pro daný typ obsahu nebo undefined pokud nenalezen
     */
    public getLoader<T extends object, K extends string = string>(
        type: string
    ): GenericContentLoader<T, K> | undefined {
        return this.loaders.get(type) as GenericContentLoader<T, K> | undefined;
    }

    /**
     * Kontroluje, zda existuje loader pro specifický typ obsahu
     * @param type Identifikátor typu obsahu
     * @returns True pokud loader existuje, false jinak
     */
    public hasLoader(type: string): boolean {
        return this.loaders.has(type);
    }

    /**
     * Získá všechny registrované typy obsahu
     * @returns Pole identifikátorů typů obsahu
     */
    public getContentTypes(): string[] {
        return Array.from(this.loaders.keys());
    }

    /**
     * Odstraní loader pro specifický typ obsahu
     * @param type Identifikátor typu obsahu
     * @returns True pokud byl loader odstraněn, false pokud neexistoval
     */
    public removeLoader(type: string): boolean {
        return this.loaders.delete(type);
    }

    /**
     * Načte obsah specifického typu podle klíče
     * @template T Typ obsahu
     * @param type Identifikátor typu obsahu
     * @param key Klíč obsahu
     * @returns Promise s načteným obsahem
     * @throws Error pokud typ obsahu není registrován nebo obsah neexistuje
     */
    public async loadContent<T extends object>(type: string, key: string): Promise<T> {
        const loader = this.getLoader<T>(type);
        if (!loader) {
            throw new Error(`No loader registered for content type '${type}'`);
        }

        return await loader.loa
</file>

<file path="src/content/types.ts">
/**
 * Obecné rozhraní pro definici obsahu
 * @template T Typ obsahu
 */
export interface ContentDefinition<T> {
    /** Identifikátor typu obsahu */
    type: string;
    /** Definice obsahu */
    content: T;
}

/**
 * Funkce pro načtení obsahu podle ID
 * @template T Typ obsahu
 * @template ID Typ identifikátoru obsahu
 */
export type ContentLoader<T, ID = string> = (id: ID) => Promise<T>;

/**
 * Funkce pro kontrolu existence obsahu
 * @template ID Typ identifikátoru obsahu
 */
export type ContentChecker<ID = string> = (id: ID) => boolean;

/**
 * Registry obsahu s podporou lazy-loadingu
 * @template T Typ obsahu
 * @template K Typ klíče obsahu
 */
export type ContentRegistry<T extends object, K extends string = string> = {
    [key: string]: T | (() => Promise<T | { default: T }>);
};

/**
 * Možnosti pro vytvoření content loaderu
 * @template T Typ obsahu
 * @template K Typ klíče obsahu
 */
export interface ContentLoaderOptions<T extends object, K extends string = string> {
    /** Počáteční registry obsahu */
    initialRegistry?: ContentRegistry<T, K>;
}

/**
 * Událost načtení obsahu
 */
export interface ContentLoadedEvent<T> {
    /** Typ obsahu */
    type: string;
    /** Klíč obsahu */
    key: string;
    /** Načtený obsah */
    content: T;
}

/**
 * Událost registrace obsahu
 */
export interface ContentRegisteredEvent {
    /** Typ obsahu */
    type: string;
    /** Počet registrovaných položek */
    count: number;
    /** Klíče registrovaných položek */
    keys: string[];
}
</file>

<file path="src/content/utils.ts">
import { ContentRegistry, ContentDefinition } from './types';
import { GenericContentLoader } from './GenericContentLoader';

/**
 * Vytvoří novou instanci content loaderu pro daný typ obsahu
 * @template T Typ obsahu
 * @template K Typ klíče obsahu
 * @param registry Volitelný počáteční registry obsahu
 * @returns Nová instance content loaderu
 */
export function createContentLoader<T extends object, K extends string = string>(
    registry?: ContentRegistry<T, K>
): GenericContentLoader<T, K> {
    return new GenericContentLoader<T, K>({
        initialRegistry: registry
    });
}

/**
 * Vytvoří definici obsahu pro registraci s engine
 * @template T Typ obsahu
 * @param type Identifikátor typu obsahu
 * @param content Registry obsahu
 * @returns Definice obsahu připravená k registraci
 */
export function defineContent<T extends ContentRegistry<any, any>>(
    type: string,
    content: T
): ContentDefinition<T> {
    return { type, content };
}

/**
 * Spojí více registrů obsahu do jednoho
 * @template T Typ obsahu
 * @template K Typ klíče obsahu
 * @param registries Pole registrů obsahu
 * @returns Spojený registry obsahu
 */
export function mergeContentRegistries<T extends object, K extends string = string>(
    ...registries: ContentRegistry<T, K>[]
): ContentRegistry<T, K> {
    return Object.assign({}, ...registries);
}

/**
 * Generuje normalizovaný klíč obsahu
 * @param parts Části klíče, které budou spojeny lomítkem
 * @returns Normalizovaný klíč obsahu
 */
export function generateContentKey(...parts: string[]): string {
    // Odstranění prázdných částí
    const filteredParts = parts.filter(part => part.trim() !== '');

    // Spojení částí lomítkem a normalizace lomítek
    return filteredParts
        .join('/')
        .replace(/\/+/g, '/') // Nahrazení více lomítek za jedno
        .replace(/^\/|\/$/g, ''); // Odstranění lomítek na začátku a konci
}

/**
 * Extrahuje klíče obsahu z registry
 * @param registry Registry obsahu
 * @returns Pole klíčů obsahu
 */
export function extractContentKeys<T extends object, K extends string = string>(
    registry: ContentRegistry<T, K>
): string[] {
    return Object.keys(registry);
}

/**
 * Transformuje registry obsahu pomocí mapovací funkce
 * @template T Původní typ obsahu
 * @template U Nový typ obsahu
 * @template K Typ klíče obsahu
 * @param registry Původní registry obsahu
 * @param mapFn Funkce pro transformaci každé položky
 * @returns Transformovaný registry obsahu
 */
export function mapContentRegistry<T extends object, U extends object, K extends string = string>(
    registry: ContentRegistry<T, K>,
    mapFn: (content: T, key: string) => U
): ContentRegistry<U, K> {
    const result: ContentRegistry<U, K> = {} as ContentRegistry<U, K>;

    for (const [key, value] of Object.entries(registry)) {
        if (typeof value === 'function') {
            // Pro lazy-loaded obsah
            result[key] = async () => {
                const loadedContent = await (value as Function)();
                if ('default' in loadedContent) {
                    return { default: mapFn(loadedContent.default, key) };
                }
                return mapFn(loadedContent as T, key);
            };
        } else {
            // Pro okamžitý obsah
            result[key] = mapFn(value as T, key);
        }
    }

    return result;
}
</file>

<file path="src/effect/EffectManager.ts">
import { GameState } from '../state/types';
import { Effect, EffectProcessor, EffectType, BuiltInEffectType } from './types';
import { produce } from '../utils/immer';
import { createDefaultEffectProcessors } from './processors';

const NAMESPACE_SEPARATOR = ':';

/**
 * Manažer efektů pro zpracování herních efektů
 */
export class EffectManager {
  /**
   * Mapa procesorů efektů podle typu
   */
  private effectProcessors: Map<string, EffectProcessor> = new Map();

  /**
   * Záložní procesor pro neznámé typy efektů
   */
  private fallbackProcessor: EffectProcessor | null = null;

  /**
   * Vytvoří novou instanci EffectManager
   *
   * @param options Možnosti konfigurace
   */
  constructor(options: { registerDefaultEffects?: boolean } = {}) {
    const { registerDefaultEffects = true } = options;

    if (registerDefaultEffects) {
      this.registerDefaultEffects();
    }
  }

  /**
   * Zpracuje jeden efekt s využitím příslušného procesoru
   *
   * @param effect Efekt ke zpracování
   * @param draftState Návrh herního stavu pro modifikaci
   * @private
   */
  private processSingleEffect(effect: Effect, draftState: GameState): void {
    const processor = this.effectProcessors.get(effect.type);

    if (processor) {
      processor(effect, draftState);
    } else if (this.fallbackProcessor) {
      this.fallbackProcessor(effect, draftState);
    } else {
      console.warn(`No processor registered for effect type '${effect.type}'`);
    }
  }

  /**
   * Registruje výchozí efektové procesory
   * @private
   */
  private registerDefaultEffects(): void {
    const defaultProcessors = createDefaultEffectProcessors();

    // Registrujeme všechny výchozí procesory
    this.registerEffectProcessors(defaultProcessors);
  }

  /**
   * Odregistruje výchozí efektové procesory
   */
  public unregisterDefaultEffects(): void {
    Object.values(BuiltInEffectType).forEach(type => {
      this.effectProcessors.delete(type);
    });
  }

  /**
   * Sestaví kompletní klíč procesoru včetně jmenného prostoru
   *
   * @param effectType Typ efektu
   * @param namespace Jmenný prostor (volitelný)
   * @returns Kompletní klíč procesoru
   * @private
   */
  private getFullEffectType(effectType: EffectType, namespace?: string): string {
    if (!namespace) {
      return effectType.toString();
    }
    return `${namespace}${NAMESPACE_SEPARATOR}${effectType}`;
  }

  /**
   * Registruje procesor pro daný typ efektu
   *
   * @param effectType Typ efektu
   * @param processor Funkce pro zpracování efektu
   * @param namespace Jmenný prostor (volitelný)
   */
  public registerEffectProcessor(effectType: EffectType, processor: EffectProcessor, namespace?: string): void {
    const fullType = this.getFullEffectType(effectType, namespace);
    this.effectProcessors.set(fullType, processor);
  }

  /**
   * Odregistruje procesor pro daný typ efektu
   *
   * @param effectType Typ efektu
   * @param namespace Jmenný prostor (volitelný)
   * @returns True pokud byl procesor úspěšně odregistrován
   */
  public unregisterEffectProcessor(effectType: EffectType, namespace?: string): boolean {
    const fullType = this.getFullEffectType(effectType, namespace);
    return this.effectProcessors.delete(fullType);
  }

  /**
   * Registruje více procesorů najednou
   *
   * @param processors Objekt mapující typy efektů na procesory
   * @param namespace Jmenný prostor (volitelný)
   */
  public registerEffectProcessors(processors: Record<string, EffectProcessor>, namespace?: string): void {
    for (const [type, processor] of Object.entries(processors)) {
      this.registerEffectProcessor(type as EffectType, processor, namespace);
    }
  }

  /**
   * Odregistruje všechny procesory patřící pod daný jmenný prostor
   *
   * @param namespace Jmenný prostor
   * @returns Počet odregistrovaných procesorů
   */
  public unregisterNamespace(namespace: string): number {
    const prefix = `${namespace}${NAMESPACE_SEPARATOR}`;
    let count = 0;

    for (const key of this.effectProcessors.keys()) {
      if (key.startsWith(prefix)) {
        this.effectProcessors.delete(key);
        count++;
      }
    }

    return count;
  }

  /**
   * Nastaví záložní procesor pro neznámé typy efektů
   *
   * @param processor Záložní procesor nebo null pro deaktivaci
   */
  public setFallbackProcessor(processor: EffectProcessor | null): void {
    this.fallbackProcessor = processor;
  }

  /**
   * Aplikuje efekt na herní stav
   *
   * @param effect Efekt k aplikaci
   * @param state Herní stav
   * @returns Nový herní stav
   */
  public applyEffect(effect: Effect, state: GameState): GameState {
    return produce(state, (draftState: GameState) => {
      this.processSingleEffect(effect, draftState);
    });
  }

  /**
   * Aplikuje více efektů na herní stav
   *
   * @param effects Pole efektů k aplikaci
   * @param state Herní stav
   * @returns Nový herní stav
   */
  public applyEffects(effects: Effect[], state: GameState): GameState {
    if (effects.length === 0) {
      return state;
    }

    return produce(state, (draftState: GameState) => {
      for (const effect of effects) {
        this.processSingleEffect(effect, draftState);
      }
    });
  }

  /**
   * Zkontroluje, zda existuje procesor pro daný typ efektu
   *
   * @param effectType Typ efektu
   * @param namespace Jmenný prostor (volitelný)
   * @returns True pokud procesor existuje
   */
  public hasProcessor(effectType: EffectType, namespace?: string): boolean {
    const fullType = this.getFullEffectType(effectType, namespace);
    return this.effectProcessors.has(fullType);
  }

  /**
   * Vrátí seznam registrovaných typů efektů
   *
   * @returns Pole typů efektů
   */
  public getRegisteredEffectTypes(): string[] {
    return Array.from(this.effectProcessors.keys());
  }
}
</file>

<file path="src/effect/index.ts">
// Export typů
export * from './types';

// Export hlavních tříd
export { EffectManager } from './EffectManager';

// Export procesorů
export { createDefaultEffectProcessors } from './processors';

// Export utilit
export {
    createSetEffect,
    createIncrementEffect,
    createDecrementEffect,
    createToggleEffect,
    createPushEffect,
    createRemoveEffect,
    createBatchEffect,
    createSequenceEffect,
    createConditionalEffect,
    createRepeatEffect,
    toBatchEffect,
    toSequenceEffect,
    isEffectOfType,
    isEffectFromNamespace
} from './utils';
</file>

<file path="src/effect/processors.ts">
import {
    EffectProcessor,
    BuiltInEffectType,
    BatchEffect,
    SequenceEffect,
    ConditionalEffect,
    RepeatEffect,
} from './types';
import { GameState } from '../state/types';
import { produce } from '../utils/immer';
import get from 'lodash/get';
import set from 'lodash/set';

type ProcessorRegistry = Record<string, EffectProcessor>;

/**
 * Pomocná funkce pro zpracování efektu
 * (Lokální ekvivalent processSingleEffect z EffectManager)
 * @private
 */
function processSingleEffect(
    effect: any,
    draftState: GameState,
    processors: ProcessorRegistry
): void {
    const processor = processors[effect.type];

    if (processor) {
        processor(effect, draftState);
    } else {
        console.warn(`No processor registered for effect type '${effect.type}'`);
    }
}

/**
 * Vytvoří registry procesorů výchozích efektů
 *
 * @returns Objekt mapující typy efektů na jejich procesory
 */
export function createDefaultEffectProcessors(): ProcessorRegistry {
    const processors: ProcessorRegistry = {};

    // Základní operace s proměnnými
    processors[BuiltInEffectType.set] = (effect, draftState) => {
        const { variable, value, path } = effect;

        if (path) {
            set(draftState, path, value);
        } else {
            draftState.variables[variable] = value;
        }
    };

    processors[BuiltInEffectType.increment] = (effect, draftState) => {
        const { variable, value = 1, path } = effect;

        if (path) {
            const currentValue = get(draftState, path, 0);
            const newValue = typeof currentValue !== 'number' ? value : currentValue + value;
            set(draftState, path, newValue);
        } else {
            if (typeof draftState.variables[variable] !== 'number') {
                draftState.variables[variable] = 0;
            }
            draftState.variables[variable] += value;
        }
    };

    processors[BuiltInEffectType.decrement] = (effect, draftState) => {
        const { variable, value = 1, path } = effect;

        if (path) {
            const currentValue = get(draftState, path, 0);
            const newValue = typeof currentValue !== 'number' ? -value : currentValue - value;
            set(draftState, path, newValue);
        } else {
            if (typeof draftState.variables[variable] !== 'number') {
                draftState.variables[variable] = 0;
            }
            draftState.variables[variable] -= value;
        }
    };

    processors[BuiltInEffectType.multiply] = (effect, draftState) => {
        const { variable, value, path } = effect;

        if (path) {
            const currentValue = get(draftState, path, 0);
            const newValue = typeof currentValue !== 'number' ? 0 : currentValue * value;
            set(draftState, path, newValue);
        } else {
            if (typeof draftState.variables[variable] !== 'number') {
                draftState.variables[variable] = 0;
            }
            draftState.variables[variable] *= value;
        }
    };

    processors[BuiltInEffectType.divide] = (effect, draftState) => {
        const { variable, value, path } = effect;

        if (value === 0) {
            throw new Error('Cannot divide by zero');
        }

        if (path) {
            const currentValue = get(draftState, path, 0);
            const newValue = typeof currentValue !== 'number' ? 0 : currentValue / value;
            set(draftState, path, newValue);
        } else {
            if (typeof draftState.variables[variable] !== 'number') {
                draftState.variables[variable] = 0;
            }
            draftState.variables[variable] /= value;
        }
    };

    processors[BuiltInEffectType.toggle] = (effect, draftState) => {
        const { variable, path } = effect;

        if (path) {
            const currentValue = get(draftState, path, false);
            set(draftState, path, !currentValue);
        } else {
            draftState.variables[variable] = !draftState.variables[variable];
        }
    };

    // Operace s poli
    processors[BuiltInEffectType.push] = (effect, draftState) => {
        const { array, value, path } = effect;

        if (path) {
            const currentArray = get(draftState, path, []);
            if (!Array.isArray(currentArray)) {
                set(draftState, path, [value]);
            } else {
                currentArray.push(value);
            }
        } else {
            if (!Array.isArray(draftState.variables[array])) {
                draftState.variables[array] = [];
            }
            draftState.variables[array].push(value);
        }
    };

    processors[BuiltInEffectType.remove] = (effect, draftState) => {
        const { array, value, byIndex = false, path } = effect;

        const removeByIndexOrValue = (arr: any[], val: any, useIndex: boolean) => {
            if (useIndex) {
                if (val >= 0 && val < arr.length) {
                    arr.splice(val, 1);
                }
            } else if (typeof val === 'object') {
                // Pro objektové hodnoty hledáme podle equality funkce, pokud je poskytnuta
                const equalityFn = effect.equalityFn || ((a: any, b: any) => a === b);
                const index = arr.findIndex(item => equalityFn(item, val));
                if (index !== -1) {
                    arr.splice(index, 1);
                }
            } else {
                const index = arr.indexOf(val);
                if (index !== -1) {
                    arr.splice(index, 1);
                }
            }
        };

        if (path) {
            const currentArray = get(draftState, path, []);
            if (Array.isArray(currentArray)) {
                removeByIndexOrValue(currentArray, value, byIndex);
            }
        } else {
            if (Array.isArray(draftState.variables[array])) {
                removeByIndexOrValue(draftState.variables[array], value, byIndex);
            }
        }
    };

    // Kompozitní efekty
    processors[BuiltInEffectType.batch] = (effect, draftState) => {
        const batchEffect = effect as BatchEffect;

        if (!batchEffect.effects || !Array.isArray(batchEffect.effects)) {
            throw new Error('Batch effect requires an array of effects');
        }

        for (const subEffect of batchEffect.effects) {
            processSingleEffect(subEffect, draftState, processors);
        }
    };

    processors[BuiltInEffectType.sequence] = (effect, draftState) => {
        const sequenceEffect = effect as SequenceEffect;

        if (!sequenceEffect.effects || !Array.isArray(sequenceEffect.effects)) {
            throw new Error('Sequence effect requires an array of effects');
        }

        for (const subEffect of sequenceEffect.effects) {
            processSingleEffect(subEffect, draftState, processors);
        }
    };

    processors[BuiltInEffectType.conditional] = (effect, draftState) => {
        const conditionalEffect = effect as ConditionalEffect;

        if (!conditionalEffect.condition || typeof conditionalEffect.condition !== 'function') {
            throw new Error('Conditional effect requires a condition function');
        }

        if (!conditionalEffect.thenEffects || !Array.isArray(conditionalEffect.thenEffects)) {
            throw new Error('Conditional effect requires thenEffects array');
        }

        // Pro vyhodnocení podmínky použijeme immutable kopii stavu
        const immutableState = produce(draftState, () => {});
        const conditionResult = conditionalEffect.condition(immutableState);

        if (conditionResult) {
            // Aplikujeme 'then' efekty
            for (const subEffect of conditionalEffect.thenEffects) {
                processSingleEffect(subEffect, draftState, processors);
            }
        } else if (conditionalEffect.elseEffects && Array.isArray(conditionalEffect.elseEffects)) {
            // Aplikujeme 'else' efekty, pokud existují
            for (const subEffect of conditionalEffect.elseEffects) {
                processSingleEffect(subEffect, draftState, processors);
            }
        }
    };

    processors[BuiltInEffectType.repeat] = (effect, draftState) => {
        const repeatEffect = effect as RepeatEffect;

        if (!repeatEffect.effect) {
            throw new Error('Repeat effect requires an effect to repeat');
        }

        let count: number;

        if (typeof repeatEffect.count === 'function') {
            // Pro vyhodnocení počtu opakování použijeme immutable kopii stavu
            const immutableState = produce(draftState, () => {});
            count = repeatEffect.count(immutableState);
        } else {
            count = repeatEffect.count;
        }

        if (!Number.isInteger(count) || count < 0) {
            throw new Error('Repeat count must be a non-negative integer');
        }

        for (let i = 0; i < count; i++) {
            processSingleEffect(repeatEffect.effect, draftState, processors);
        }
    };

    return processors;
}
</file>

<file path="src/effect/types.ts">
import { GameState } from '../state/types';

/**
 * Výčet typů vestavěných efektů
 */
export enum BuiltInEffectType {
  set = 'set',
  increment = 'increment',
  decrement = 'decrement',
  multiply = 'multiply',
  divide = 'divide',
  toggle = 'toggle',

  // Efekty pro pole
  push = 'push',
  remove = 'remove',

  // Kompozitní efekty
  batch = 'batch',
  sequence = 'sequence',
  conditional = 'conditional',
  repeat = 'repeat'
}

/**
 * Typ pro identifikaci efektu (může být vestavěný nebo vlastní)
 */
export type EffectType = BuiltInEffectType | string;

/**
 * Základní rozhraní pro všechny efekty
 */
export interface Effect {
  /**
   * Typ efektu
   */
  type: EffectType;

  /**
   * Indexová signatura pro další vlastnosti
   */
  [key: string]: any;
}

/**
 * Funkce pro zpracování efektu
 */
export type EffectProcessor = (effect: Effect, draftState: GameState) => void;

/**
 * Rozhraní pro efekt z pluginu
 */
export interface PluginEffect extends Effect {
  /**
   * Jmenný prostor pluginu
   */
  namespace: string;
}

// Rozhraní pro kompozitní efekty

/**
 * Efekt pro aplikaci více efektů najednou
 */
export interface BatchEffect extends Effect {
  type: BuiltInEffectType.batch;
  /**
   * Pole efektů k aplikaci
   */
  effects: Effect[];
}

/**
 * Efekt pro sekvenční aplikaci efektů
 */
export interface SequenceEffect extends Effect {
  type: BuiltInEffectType.sequence;
  /**
   * Pole efektů k sekvenční aplikaci
   */
  effects: Effect[];
}

/**
 * Efekt pro podmíněnou aplikaci efektů
 */
export interface ConditionalEffect extends Effect {
  type: BuiltInEffectType.conditional;
  /**
   * Podmínka, která určuje, zda se efekty aplikují
   */
  condition: (state: GameState) => boolean;
  /**
   * Efekty aplikované, pokud je podmínka splněna
   */
  thenEffects: Effect[];
  /**
   * Efekty aplikované, pokud podmínka není splněna
   */
  elseEffects?: Effect[];
}

/**
 * Efekt pro opakování jiného efektu
 */
export interface RepeatEffect extends Effect {
  type: BuiltInEffectType.repeat;
  /**
   * Počet opakování nebo funkce, která vrátí počet opakování
   */
  count: number | ((state: GameState) => number);
  /**
   * Efekt, který se bude opakovat
   */
  effect: Effect;
}

// Rozhraní pro efekty proměnných

/**
 * Základní efekt pro operace s proměnnými
 */
export interface VariableEffect extends Effect {
  /**
   * Název proměnné
   */
  variable: string;
  /**
   * Volitelná cesta k vlastnosti (pro nested properties)
   */
  path?: string;
}

/**
 * Efekt pro nastavení hodnoty proměnné
 */
export interface SetVariableEffect extends VariableEffect {
  type: BuiltInEffectType.set;
  /**
   * Hodnota k nastavení
   */
  value: any;
}

/**
 * Efekt pro zvýšení hodnoty proměnné
 */
export interface IncrementVariableEffect extends VariableEffect {
  type: BuiltInEffectType.increment;
  /**
   * Hodnota k přičtení (výchozí: 1)
   */
  value?: number;
}

/**
 * Efekt pro snížení hodnoty proměnné
 */
export interface DecrementVariableEffect extends VariableEffect {
  type: BuiltInEffectType.decrement;
  /**
   * Hodnota k odečtení (výchozí: 1)
   */
  value?: number;
}

/**
 * Efekt pro násobení hodnoty proměnné
 */
export interface MultiplyVariableEffect extends VariableEffect {
  type: BuiltInEffectType.multiply;
  /**
   * Hodnota, kterou se proměnná vynásobí
   */
  value: number;
}

/**
 * Efekt pro dělení hodnoty proměnné
 */
export interface DivideVariableEffect extends VariableEffect {
  type: BuiltInEffectType.divide;
  /**
   * Hodnota, kterou se proměnná vydělí
   */
  value: number;
}

/**
 * Efekt pro přepnutí hodnoty proměnné (boolean toggle)
 */
export interface ToggleVariableEffect extends VariableEffect {
  type: BuiltInEffectType.toggle;
}

// Rozhraní pro efekty na polích

/**
 * Základní efekt pro operace s poli
 */
export interface ArrayEffect extends Effect {
  /**
   * Název pole
   */
  array: string;
  /**
   * Volitelná cesta k vlastnosti (pro nested properties)
   */
  path?: string;
}

/**
 * Efekt pro přidání hodnoty do pole
 */
export interface PushToArrayEffect extends ArrayEffect {
  type: BuiltInEffectType.push;
  /**
   * Hodnota k přidání do pole
   */
  value: any;
}

/**
 * Efekt pro odstranění hodnoty z pole
 */
export interface RemoveFromArrayEffect extends ArrayEffect {
  type: BuiltInEffectType.remove;
  /**
   * Hodnota k odstranění
   */
  value: any;
  /**
   * Zda se má odstranit podle indexu nebo hodnoty
   */
  byIndex?: boolean;
  /**
   * Volitelná funkce pro porovnání objektů
   */
  equalityFn?: (a: any, b: any) => boolean;
}
</file>

<file path="src/effect/utils.ts">
import {
  Effect,
  BatchEffect,
  SequenceEffect,
  ConditionalEffect,
  RepeatEffect,
  SetVariableEffect,
  IncrementVariableEffect,
  DecrementVariableEffect,
  ToggleVariableEffect,
  PushToArrayEffect,
  RemoveFromArrayEffect,
  BuiltInEffectType
} from './types';
import { GameState } from '../state/types';

/**
 * Vytvoří efekt pro nastavení hodnoty proměnné
 */
export function createSetEffect(variable: string, value: any, path?: string): SetVariableEffect {
  return {
    type: BuiltInEffectType.set,
    variable,
    value,
    path
  };
}

/**
 * Vytvoří efekt pro zvýšení hodnoty proměnné
 */
export function createIncrementEffect(variable: string, value = 1, path?: string): IncrementVariableEffect {
  return {
    type: BuiltInEffectType.increment,
    variable,
    value,
    path
  };
}

/**
 * Vytvoří efekt pro snížení hodnoty proměnné
 */
export function createDecrementEffect(variable: string, value = 1, path?: string): DecrementVariableEffect {
  return {
    type: BuiltInEffectType.decrement,
    variable,
    value,
    path
  };
}

/**
 * Vytvoří efekt pro přepnutí boolean hodnoty proměnné
 */
export function createToggleEffect(variable: string, path?: string): ToggleVariableEffect {
  return {
    type: BuiltInEffectType.toggle,
    variable,
    path
  };
}

/**
 * Vytvoří efekt pro přidání hodnoty do pole
 */
export function createPushEffect(array: string, value: any, path?: string): PushToArrayEffect {
  return {
    type: BuiltInEffectType.push,
    array,
    value,
    path
  };
}

/**
 * Vytvoří efekt pro odstranění hodnoty z pole
 */
export function createRemoveEffect(
    array: string,
    value: any,
    options: { byIndex?: boolean; path?: string; equalityFn?: (a: any, b: any) => boolean } = {}
): RemoveFromArrayEffect {
  return {
    type: BuiltInEffectType.remove,
    array,
    value,
    ...options
  };
}

/**
 * Vytvoří efekt pro dávkové provedení více efektů najednou
 */
export function createBatchEffect(effects: Effect[]): BatchEffect {
  return {
    type: BuiltInEffectType.batch,
    effects
  };
}

/**
 * Vytvoří efekt pro sekvenční provedení více efektů
 */
export function createSequenceEffect(effects: Effect[]): SequenceEffect {
  return {
    type: BuiltInEffectType.sequence,
    effects
  };
}

/**
 * Vytvoří efekt pro podmíněné provedení efektů
 */
export function createConditionalEffect(
    condition: (state: GameState) => boolean,
    thenEffects: Effect[],
    elseEffects?: Effect[]
): ConditionalEffect {
  return {
    type: BuiltInEffectType.conditional,
    condition,
    thenEffects,
    elseEffects
  };
}

/**
 * Vytvoří efekt pro opakované provedení jiného efektu
 */
export function createRepeatEffect(
    effect: Effect,
    count: number | ((state: GameState) => number)
): RepeatEffect {
  return {
    type: BuiltInEffectType.repeat,
    count,
    effect
  };
}

/**
 * Převede neuspořádaný seznam efektů na batch efekt
 */
export function toBatchEffect(effects: Effect[]): BatchEffect {
  return createBatchEffect(effects);
}

/**
 * Převede neuspořádaný seznam efektů na sequence efekt
 */
export function toSequenceEffect(effects: Effect[]): SequenceEffect {
  return createSequenceEffect(effects);
}

/**
 * Zkontroluje, zda je efekt určitého typu
 */
export function isEffectOfType<T extends Effect>(effect: Effect, type: BuiltInEffectType | string): effect is T {
  return effect.type === type;
}

/**
 * Zkontroluje, zda je efekt z určitého jmenného prostoru
 */
export function isEffectFromNamespace(effect: Effect, namespace: string): boolean {
  return 'namespace' in effect && (effect as any).namespace === namespace;
}
</file>

<file path="src/engine/GameEngine.ts">
import {
    GameEngineOptions,
    GameEngineEvents,
    GameStartedEventData,
    GameEndedEventData,
    SceneChangedEventData,
    EffectAppliedEventData
} from './types';
import { GameState } from '../state/types';
import { Scene, SceneKey, SceneTransitionOptions } from '../scene/types';
import { Effect } from '../effect/types';
import { EventEmitter } from '../event';
import { StateManager } from '../state';
import { SceneManager } from '../scene/SceneManager';
import { EffectManager } from '../effect/EffectManager';
import { PluginManager } from '../plugin/PluginManager';
import { GenericContentLoader } from '../content/GenericContentLoader';
import { LoaderRegistry } from '../content/LoaderRegistry';
import { SaveManager } from '../save/SaveManager';
import { ContentDefinition } from '../content/types';
import { Plugin } from '../plugin/types';
import { createSaveManager } from '../save/utils';
import { GameEventType, EventListener } from '../event/types';

/**
 * Hlavní třída herního enginu
 *
 * Koordinuje všechny komponenty enginu, spravuje stav hry a přechody
 * mezi scénami, a poskytuje rozhraní pro interakci s herním světem.
 */
export class GameEngine {
    /** Verze enginu */
    private readonly version: string;

    /** Event emitter pro události */
    private readonly eventEmitter: EventEmitter;

    /** Správce stavu */
    private readonly stateManager: StateManager;

    /** Správce scén */
    private readonly sceneManager: SceneManager;

    /** Správce efektů */
    private readonly effectManager: EffectManager;

    /** Správce pluginů */
    private readonly pluginManager: PluginManager;

    /** Registr loaderů obsahu */
    private readonly loaderRegistry: LoaderRegistry;

    /** Správce ukládání a načítání */
    private readonly saveManager: SaveManager;

    /** Příznak, zda je hra spuštěna */
    private isRunning: boolean = false;

    /**
     * Vytvoří novou instanci herního enginu
     *
     * @param options Možnosti konfigurace
     */
    constructor(options: GameEngineOptions) {
        const {
            sceneLoader,
            initialState = {},
            plugins = [],
            engineVersion = '0.1.0'
        } = options;

        this.version = engineVersion;

        // Vytvoření nebo převzetí event emitteru
        this.eventEmitter = options.eventEmitter || new EventEmitter();

        // Vytvoření správce stavu
        this.stateManager = new StateManager({
            initialState
        });

        // Vytvoření registru loaderů obsahu
        this.loaderRegistry = new LoaderRegistry();

        // Vytvoření správce efektů
        this.effectManager = new EffectManager();

        // Registrace loaderu scén
        this.loaderRegistry.registerLoader('scenes', sceneLoader);

        // Vytvoření správce scén
        this.sceneManager = new SceneManager(sceneLoader);

        // Vytvoření správce pluginů
        this.pluginManager = new PluginManager(this, this.eventEmitter, {
            autoActivate: true
        });

        // Vytvoření nebo převzetí správce ukládání
        if (options.saveManager) {
            this.saveManager = options.saveManager;
        } else {
            this.saveManager = createSaveManager(this, {
                storage: options.saveStorage,
                engineVersion: this.version
            });
        }

        // Inicializace pluginů
        this.initializePlugins(plugins)
    }

    /**
     * Inicializuje pluginy
     *
     * @param plugins Pole pluginů k inicializaci
     * @private
     */
    private async initializePlugins(plugins: Plugin[]): Promise<void> {
        for (const plugin of plugins) {
            await this.pluginManager.registerPlugin(plugin);
        }
    }

    /**
     * Spustí hru od zadané scény
     *
     * @param initialSceneKey Klíč počáteční scény
     * @param options Volitelné možnosti přechodu
     * @returns Promise, který se vyřeší, když je hra spuštěna
     */
    public async start(initialSceneKey: SceneKey, options?: SceneTransitionOptions): Promise<boolean> {
        // Aplikace efektů, pokud existují
        if (options?.effects && options.effects.length > 0) {
            this.applyEffects(options.effects);
        }

        // Přechod na počáteční scénu
        const success = await this.sceneManager.transitionToScene(
            initialSceneKey,
            this.stateManager.getState(),
            this
        );

        if (success) {
            this.isRunning = true;

            // Emitování události startu hry
            this.eventEmitter.emit(GameEngineEvents.GAME_STARTED, {
                sceneKey: initialSceneKey,
                transitionData: options?.data
            } as GameStartedEventData);

            // Emitování události změny scény
            this.eventEmitter.emit(GameEngineEvents.SCENE_CHANGED, {
                scene: this.sceneManager.getCurrentScene(),
                sceneKey: initialSceneKey,
                transitionData: options?.data
            } as SceneChangedEventData);
        } else {
            console.error(`Failed to start game at scene '${initialSceneKey}'`);
        }

        return success;
    }

    /**
     * Ukončí běžící hru
     *
     * @param reason Volitelný důvod ukončení
     * @param data Volitelná dodatečná data
     */
    public end(reason?: string, data: Record<string, any> = {}): void {
        if (!this.isRunning) {
            return;
        }

        this.isRunning = false;

        // Emitování události konce hry
        this.eventEmitter.emit(GameEngineEvents.GAME_ENDED, {
            reason,
            ...data
        } as GameEndedEventData);
    }

    /**
     * Přesune hru na novou scénu
     *
     * @param sceneKey Klíč cílové scény
     * @param options Volitelné možnosti přechodu
     * @returns Promise, který se vyřeší, když je přechod dokončen
     */
    public async transitionToScene(
        sceneKey: SceneKey,
        options?: SceneTransitionOptions
    ): Promise<boolean> {
        if (!this.isRunning) {
            console.warn('Cannot transition: game is not running. Call start() first.');
            return false;
        }

        const previousSceneKey = this.sceneManager.getCurrentSceneKey();
        const previousScene = this.sceneManager.getCurrentScene();

        // Aplikace efektů, pokud existují
        if (options?.effects && options.effects.length > 0) {
            this.applyEffects(options.effects);
        }

        // Provedení přechodu
        const success = await this.sceneManager.transitionToScene(
            sceneKey,
            this.stateManager.getState(),
            this
        );

        if (success) {
            // Emitování události změny scény
            this.eventEmitter.emit(GameEngineEvents.SCENE_CHANGED, {
                scene: this.sceneManager.getCurrentScene(),
                sceneKey,
                previousScene,
                previousSceneKey,
                transitionData: options?.data
            } as SceneChangedEventData);
        }

        return success;
    }

    /**
     * Aplikuje efekty na herní stav
     *
     * @param effects Efekty k aplikaci
     */
    public applyEffects(effects: Effect[]): void {
        if (!effects || effects.length === 0) return;

        const currentState = this.stateManager.getState();
        const newState = this.effectManager.applyEffects(effects, currentState);

        this.stateManager.setState(newState);

        // Emitování události změny stavu
        this.eventEmitter.emit(GameEngineEvents.STATE_CHANGED, newState);

        // Emitování události aplikace efektů
        this.eventEmitter.emit(GameEngineEvents.EFFECT_APPLIED, {
            effect: effects.length === 1 ? effects[0] : { type: 'batch', effects },
            previousState: currentState,
            newState
        } as EffectAppliedEventData);
    }

    /**
     * Aplikuje jeden efekt na herní stav
     *
     * @param effect Efekt k aplikaci
     */
    public applyEffect(effect: Effect): void {
        if (!effect) return;

        const currentState = this.stateManager.getState();
        const newState = this.effectManager.applyEffect(effect, currentState);

        this.stateManager.setState(newState);

        // Emitování události změny stavu
        this.eventEmitter.emit(GameEngineEvents.STATE_CHANGED, newState);

        // Emitování události aplikace efektu
        this.eventEmitter.emit(GameEngineEvents.EFFECT_APPLIED, {
            effect,
            previousState: currentState,
            newState
        } as EffectAppliedEventData);
    }

    /**
     * Registruje obsah s příslušným loaderem
     *
     * @param contentDefinition Definice obsahu
     * @returns True, pokud byla registrace úspěšná
     */
    public registerContent<T extends object>(
        contentDefinition: ContentDefinition<T>
    ): boolean {
        const { type, content } = contentDefinition;
        const loader = this.loaderRegistry.getLoader(type);

        if (!loader) {
            console.warn(`No loader registered for content type '${type}'`);
            return false;
        }

        loader.registerContent(content);
        return true;
    }

    /**
     * Získá loader obsahu podle typu
     *
     * @param type Typ obsahu
     * @returns Loader pro daný typ obsahu nebo undefined
     */
    public getLoader<T extends object, K extends string = string>(
        type: string
    ): GenericContentLoader<T, K> | undefined {
        return this.loaderRegistry.getLoader<T, K>(type);
    }

    /**
     * Registruje posluchače události
     *
     * @param eventType Typ události
     * @param listener Funkce, která bude volána při události
     */
    public on(eventType: GameEventType, listener: EventListener): void {
        this.eventEmitter.on(eventType, listener);
    }

    /**
     * Odregistruje posluchače události
     *
     * @param eventType Typ události
     * @param listener Funkce, která byla zaregistrována
     */
    public off(eventType: GameEventType, listener: EventListener): void {
        this.eventEmitter.off(eventType, listener);
    }

    /**
     * Emituje událost
     *
     * @param eventType Typ události
     * @param data Volitelná data události
     */
    public emit(eventType: GameEventType, data?: any): void {
        this.eventEmitter.emit(eventType, data);
    }

    /**
     * Vrátí aktuální herní stav
     *
     * @returns Aktuální herní stav
     */
    public getState(): GameState {
        return this.stateManager.getState();
    }

    /**
     * Vrátí aktuální scénu
     *
     * @returns Aktuální scéna nebo null
     */
    public getCurrentScene(): Scene | null {
        return this.sceneManager.getCurrentScene();
    }

    /**
     * Vrátí klíč aktuální scény
     *
     * @returns Klíč aktuální scény nebo null
     */
    public getCurrentSceneKey(): SceneKey | null {
        return this.sceneManager.getCurrentSceneKey();
    }

    /**
     * Vrátí verzi enginu
     *
     * @returns Verze enginu
     */
    public getVersion(): string {
        return this.version;
    }

    /**
     * Kontroluje, zda je hra spuštěna
     *
     * @returns True, pokud je hra spuštěna
     */
    public isGameRunning(): boolean {
        return this.isRunning;
    }

    /**
     * Vrátí správce stavu
     *
     * @returns Správce stavu
     */
    public getStateManager(): StateManager {
        return this.stateManager;
    }

    /**
     * Vrátí správce scén
     *
     * @returns Správce scén
     */
    public getSceneManager(): SceneManager {
        return this.sceneManager;
    }

    /**
     * Vrátí správce efektů
     *
     * @returns Správce efektů
     */
    public getEffectManager(): EffectManager {
        return this.effectManager;
    }

    /**
     * Vrátí správce pluginů
     *
     * @returns Správce pluginů
     */
    public getPluginManager(): PluginManager {
        return this.pluginManager;
    }

    /**
     * Vrátí registr loaderů obsahu
     *
     * @returns Registr loaderů obsahu
     */
    public getLoaderRegistry(): LoaderRegistry {
        return this.loaderRegistry;
    }

    /**
     * Vrátí správce ukládání
     *
     * @returns Správce ukládání
     */
    public getSaveManager(): SaveManager {
        return this.saveManager;
    }


    /**
     * Vrátí event emitter
     *
     * @returns Event emitter
     */
    public getEventEmitter(): EventEmitter {
        return this.eventEmitter;
    }

    /**
     * Registruje plugin
     *
     * @param plugin Plugin k registraci
     * @returns Promise, který se vyřeší na true, pokud byl plugin úspěšně registrován
     */
    public async registerPlugin(plugin: Plugin): Promise<boolean> {
        return await this.pluginManager.registerPlugin(plugin);
    }

    /**
     * Odregistruje plugin
     *
     * @param pluginName Název pluginu
     * @returns Promise, který se vyřeší na true, pokud byl plugin úspěšně odregistrován
     */
    public async unregisterPlugin(pluginName: string): Promise<boolean> {
        return await this.pluginManager.unregisterPlugin(pluginName);
    }

    /**
     * Získá plugin podle názvu
     *
     * @param pluginName Název pluginu
     * @returns Plugin nebo undefined
     */
    public getPlugin<T extends Plugin>(pluginName: string): T | undefined {
        return this.pluginManager.getPlugin<T>(pluginName);
    }

    /**
     * Uloží aktuální stav hry
     *
     * @param saveId ID uložené hry
     * @param options Volitelné možnosti
     * @returns Promise, který se vyřeší na true, pokud bylo uložení úspěšné
     */
    public async saveGame(saveId: string, options = {}): Promise<boolean> {
        return await this.saveManager.save(saveId, options);
    }

    /**
     * Načte uloženou hru
     *
     * @param saveId ID uložené hry
     * @returns Promise, který se vyřeší na true, pokud bylo načtení úspěšné
     */
    public async loadGame(saveId: string): Promise<boolean> {
        return await this.saveManager.load(saveId);
    }

    /**
     * Restartuje engine s novým stavem
     *
     * @param options Volitelné možnosti restartu
     * @returns Promise, který se vyřeší, když je restart dokončen
     */
    public async restart(options: {
        initialState?: Partial<GameState>;
        initialSceneKey?: SceneKey;
    } = {}): Promise<boolean> {
        // Ukončíme aktuální hru, pokud běží
        if (this.isRunning) {
            this.end('restart');
        }

        // Resetujeme stav
        if (options.initialState) {
            this.stateManager.resetState(options.initialState);
        } else {
            this.stateManager.resetState();
        }

        // Určíme počáteční scénu
        const initialSceneKey = options.initialSceneKey || this.getCurrentSceneKey() || 'start';

        // Spustíme hru znovu
        return await this.start(initialSceneKey);
    }
}
</file>

<file path="src/engine/index.ts">
// Export typů
export * from './types';

// Export hlavních tříd
export { GameEngine } from './GameEngine';

// Export utilit
export {
    createGameEngine,
    createSimpleGameEngine,
    createDebugGameEngine,
    preloadAllScenes
} from './utils';
</file>

<file path="src/engine/types.ts">
import { Scene } from '../scene/types';
import { StateManager } from '../state/StateManager';
import { EffectManager } from '../effect/EffectManager';
import { PluginManager } from '../plugin/PluginManager';
import { LoaderRegistry } from '../content/LoaderRegistry';
import { EventEmitter } from '../event/EventEmitter';
import { SaveManager } from '../save/SaveManager';
import { EntityManager } from '../entity/EntityManager';
import { GameState } from '../state/types';
import { SaveStorage } from '../save/types';
import { GenericContentLoader } from '../content/GenericContentLoader';
import { Plugin } from '../plugin/types';
import { SceneKey, SceneTransitionOptions } from '../scene/types';
import { Effect } from '../effect/types';

/**
 * Možnosti konfigurace herního enginu
 */
export interface GameEngineOptions {
    /** Loader scén pro načítání herního obsahu */
    sceneLoader: GenericContentLoader<Scene>;

    /** Počáteční stav hry, který bude sloučen s výchozím prázdným stavem */
    initialState?: Partial<GameState>;

    /** Pluginy, které budou registrovány s enginem */
    plugins?: Plugin[];

    /** SaveManager pro ukládání a načítání her (volitelné) */
    saveManager?: SaveManager;

    /** Verze enginu pro ukládání her (volitelné) */
    engineVersion?: string;

    /** Event emitter pro události enginu (volitelné) */
    eventEmitter?: EventEmitter;

    /** Úložiště pro ukládání her (volitelné) */
    saveStorage?: SaveStorage;

    /** Další konfigurační možnosti specifické pro implementaci */
    [key: string]: any;
}

/**
 * Události emitované herním enginem
 */
export enum GameEngineEvents {
    /** Hra byla zahájena */
    GAME_STARTED = 'gameStarted',

    /** Hra byla ukončena */
    GAME_ENDED = 'gameEnded',

    /** Došlo ke změně scény */
    SCENE_CHANGED = 'sceneChanged',

    /** Došlo ke změně stavu */
    STATE_CHANGED = 'stateChanged',

    /** Byl aplikován efekt na stav */
    EFFECT_APPLIED = 'effectApplied',

    /** Došlo k chybě v enginu */
    ERROR = 'engineError'
}

/**
 * Data předávaná při události startu hry
 */
export interface GameStartedEventData {
    /** Klíč počáteční scény */
    sceneKey: SceneKey;

    /** Volitelná data předaná při startu */
    transitionData?: any;
}

/**
 * Data předávaná při události konce hry
 */
export interface GameEndedEventData {
    /** Důvod ukončení hry */
    reason?: string;

    /** Další data o ukončení */
    [key: string]: any;
}

/**
 * Data předávaná při události změny scény
 */
export interface SceneChangedEventData {
    /** Nová scéna */
    scene: Scene;

    /** Klíč nové scény */
    sceneKey: SceneKey;

    /** Předchozí scéna */
    previousScene?: Scene;

    /** Klíč předchozí scény */
    previousSceneKey?: SceneKey;

    /** Volitelná data předaná při přechodu */
    transitionData?: any;
}

/**
 * Data předávaná při události aplikace efektu
 */
export interface EffectAppliedEventData {
    /** Aplikovaný efekt */
    effect: Effect;

    /** Stav před aplikací efektu */
    previousState: GameState;

    /** Stav po aplikaci efektu */
    newState: GameState;
}
</file>

<file path="src/engine/utils.ts">
import { GameEngine } from './GameEngine';
import { GameEngineOptions } from './types';
import { Scene } from '../scene/types';
import { GenericContentLoader } from '../content/GenericContentLoader';
import { ContentDefinition } from '../content/types';
import { Plugin } from '../plugin/types';
import { GameState } from '../state/types';

/**
 * Možnosti pro vytvoření herního enginu
 */
export interface CreateGameEngineOptions {
    /**
     * Definice obsahu k registraci
     */
    content?: ContentDefinition<any>[];

    /**
     * Pluginy k registraci
     */
    plugins?: Plugin[];

    /**
     * Počáteční stav hry
     */
    initialState?: Partial<GameState>;

    /**
     * Vlastní content loader pro scény
     */
    sceneLoader?: GenericContentLoader<Scene>;

    /**
     * Další možnosti konfigurace enginu
     */
    engineOptions?: Partial<GameEngineOptions>;
}

/**
 * Vytvoří nový herní engine s danou konfigurací
 *
 * @param options Možnosti pro vytvoření enginu
 * @returns Nová instance herního enginu
 */
export function createGameEngine(options: CreateGameEngineOptions = {}): GameEngine {
    const {
        content = [],
        plugins = [],
        initialState = {},
        sceneLoader = new GenericContentLoader<Scene>(),
        engineOptions = {}
    } = options;

    // Vytvoření enginu
    const engine = new GameEngine({
        sceneLoader,
        initialState,
        plugins,
        ...engineOptions
    });

    // Registrace obsahu
    for (const contentDef of content) {
        engine.registerContent(contentDef);
    }

    return engine;
}
</file>

<file path="src/event/EventEmitter.ts">
import { GameEventType, EventListener, EventEmitterOptions } from './types';

/**
 * EventEmitter implementuje návrhový vzor Observer
 * Umožňuje registraci posluchačů událostí a emitování událostí
 */
export class EventEmitter {
    /**
     * Mapa posluchačů událostí
     * Klíč je typ události, hodnota je množina posluchačů
     */
    private listeners: Map<GameEventType, Set<EventListener>> = new Map();

    /**
     * Mapa jednorázových posluchačů událostí
     * Posluchači jsou automaticky odstraněni po prvním zavolání
     */
    private onceListeners: Map<GameEventType, Set<EventListener>> = new Map();

    /**
     * Maximální počet posluchačů na jeden typ události
     */
    private maxListeners: number;

    /**
     * Zda zachytávat chyby v posluchačích
     */
    private catchErrors: boolean;

    /**
     * Vytvoří nový EventEmitter
     *
     * @param options Možnosti konfigurace EventEmitter
     */
    constructor(options: EventEmitterOptions = {}) {
        const { catchErrors = true, maxListeners = 10 } = options;
        this.catchErrors = catchErrors;
        this.maxListeners = maxListeners;
    }

    /**
     * Registruje posluchače pro daný typ události
     *
     * @param eventType Typ události
     * @param listener Funkce posluchače
     */
    public on(eventType: GameEventType, listener: EventListener): void {
        if (!this.listeners.has(eventType)) {
            this.listeners.set(eventType, new Set());
        }

        const eventListeners = this.listeners.get(eventType)!;
        eventListeners.add(listener);

        // Kontrola počtu posluchačů
        if (eventListeners.size > this.maxListeners) {
            console.warn(`Possible EventEmitter memory leak detected. ${eventListeners.size} listeners added for event type '${eventType}'`);
        }
    }

    /**
     * Registruje jednorázového posluchače pro daný typ události
     * Posluchač bude automaticky odstraněn po prvním zavolání
     *
     * @param eventType Typ události
     * @param listener Funkce posluchače
     */
    public once(eventType: GameEventType, listener: EventListener): void {
        if (!this.onceListeners.has(eventType)) {
            this.onceListeners.set(eventType, new Set());
        }

        const eventListeners = this.onceListeners.get(eventType)!;
        eventListeners.add(listener);
    }

    /**
     * Odregistruje posluchače pro daný typ události
     *
     * @param eventType Typ události
     * @param listener Funkce posluchače
     */
    public off(eventType: GameEventType, listener: EventListener): void {
        // Kontrola běžných posluchačů
        const eventListeners = this.listeners.get(eventType);
        if (eventListeners) {
            eventListeners.delete(listener);
            if (eventListeners.size === 0) {
                this.listeners.delete(eventType);
            }
        }

        // Kontrola jednorázových posluchačů
        const onceEventListeners = this.onceListeners.get(eventType);
        if (onceEventListeners) {
            onceEventListeners.delete(listener);
            if (onceEventListeners.size === 0) {
                this.onceListeners.delete(eventType);
            }
        }
    }

    /**
     * Emituje událost daného typu s volitelným datovým objektem
     *
     * @param eventType Typ události
     * @param data Volitelná data předaná posluchačům
     */
    public emit(eventType: GameEventType, data?: any): void {
        // Zavolání běžných posluchačů
        const eventListeners = this.listeners.get(eventType);
        if (eventListeners) {
            this.callListeners(eventListeners, data);
        }

        // Zavolání a odstranění jednorázových posluchačů
        const onceEventListeners = this.onceListeners.get(eventType);
        if (onceEventListeners && onceEventListeners.size > 0) {
            this.callListeners(onceEventListeners, data);
            this.onceListeners.delete(eventType);
        }
    }

    /**
     * Volá všechny posluchače v dané množině s danými daty
     *
     * @param listeners Množina posluchačů
     * @param data Data k předání posluchačům
     * @private
     */
    private callListeners(listeners: Set<EventListener>, data: any): void {
        for (const listener of listeners) {
            try {
                listener(data);
            } catch (error) {
                if (!this.catchErrors) {
                    throw error;
                }
                console.error(`Error in event listener:`, error);
            }
        }
    }

    /**
     * Odstraní všechny posluchače pro daný typ události
     * Pokud není typ události specifikován, odstraní všechny posluchače
     *
     * @param eventType Volitelný typ události
     */
    public removeAllListeners(eventType?: GameEventType): void {
        if (eventType) {
            this.listeners.delete(eventType);
            this.onceListeners.delete(eventType);
        } else {
            this.listeners.clear();
            this.onceListeners.clear();
        }
    }

    /**
     * Vrátí seznam všech registrovaných typů událostí
     *
     * @returns Pole typů událostí
     */
    public getEventTypes(): GameEventType[] {
        const types = new Set([
            ...this.listeners.keys(),
            ...this.onceListeners.keys()
        ]);
        return Array.from(types);
    }

    /**
     * Vrátí počet posluchačů pro daný typ události
     *
     * @param eventType Typ události
     * @returns Počet posluchačů
     */
    public listenerCount(eventType: GameEventType): number {
        let count = 0;

        const eventListeners = this.listeners.get(eventType);
        if (eventListeners) {
            count += eventListeners.size;
        }

        const onceEventListeners = this.onceListeners.get(eventType);
        if (onceEventListeners) {
            count += onceEventListeners.size;
        }

        return count;
    }

    /**
     * Nastaví maximální počet posluchačů na jeden typ události
     *
     * @param n Maximální počet posluchačů
     */
    public setMaxListeners(n: number): void {
        this.maxListeners = n;
    }

    /**
     * Získá maximální počet posluchačů na jeden typ události
     *
     * @returns Maximální počet posluchačů
     */
    public getMaxListeners(): number {
        return this.maxListeners;
    }
}
</file>

<file path="src/event/index.ts">
// Export typů
export * from './types';

// Export hlavních tříd
export { EventEmitter } from './EventEmitter';

// Export utilit
export {
    combineListeners,
    createFilteredListener,
    createCountLimitedListener,
    createDebouncedListener,
    createThrottledListener,
    createAsyncListener
} from './utils';
</file>

<file path="src/event/TypedEventEmmiter.ts">
import { EventEmitter } from './EventEmitter';

/**
 * Typově bezpečný EventEmitter
 * @template T Mapa typů eventů na jejich datové typy
 */
export class TypedEventEmitter<T extends Record<string, any>> {
    private emitter: EventEmitter;

    constructor(emitter?: EventEmitter) {
        this.emitter = emitter || new EventEmitter();
    }

    /**
     * Registruje posluchače pro daný typ události
     * @param event Typ události
     * @param listener Funkce volaná při události
     */
    public on<K extends keyof T>(event: K, listener: (data: T[K]) => void): void {
        this.emitter.on(event as string, listener);
    }

    /**
     * Registruje jednorázového posluchače pro daný typ události
     * @param event Typ události
     * @param listener Funkce volaná při události
     */
    public once<K extends keyof T>(event: K, listener: (data: T[K]) => void): void {
        this.emitter.once(event as string, listener);
    }

    /**
     * Odregistruje posluchače pro daný typ události
     * @param event Typ události
     * @param listener Funkce volaná při události
     */
    public off<K extends keyof T>(event: K, listener: (data: T[K]) => void): void {
        this.emitter.off(event as string, listener);
    }

    /**
     * Emituje událost daného typu
     * @param event Typ události
     * @param data Data události
     */
    public emit<K extends keyof T>(event: K, data: T[K]): void {
        this.emitter.emit(event as string, data);
    }

    /**
     * Vrátí počet posluchačů pro daný typ události
     * @param event Typ události
     */
    public listenerCount<K extends keyof T>(event: K): number {
        return this.emitter.listenerCount(event as string);
    }

    /**
     * Odstraní všechny posluchače pro daný typ události
     * @param event Volitelný typ události
     */
    public removeAllListeners<K extends keyof T>(event?: K): void {
        this.emitter.removeAllListeners(event as string | undefined);
    }

    /**
     * Nastaví maximální počet posluchačů na jeden typ události
     * @param n Maximální počet posluchačů
     */
    public setMaxListeners(n: number): void {
        this.emitter.setMaxListeners(n);
    }

    /**
     * Získá podkladový EventEmitter
     * @returns EventEmitter
     */
    public getUnderlyingEmitter(): EventEmitter {
        return this.emitter;
    }
}
</file>

<file path="src/event/types.ts">
/**
 * Typ pro identifikátor události
 * Může být buď z předem definovaných typů, nebo vlastní řetězec
 */
export type GameEventType =
    | 'sceneChanged'
    | 'stateChanged'
    | 'gameStarted'
    | 'gameEnded'
    | 'effectApplied'
    | string;

/**
 * Typ pro callback funkci posluchače události
 */
export type EventListener = (data: any) => void;

/**
 * Data předávaná při události změny scény
 */
export interface SceneChangedEventData {
    /**
     * Nová scéna
     */
    scene: any;

    /**
     * Volitelná data předaná při přechodu
     */
    transitionData?: any;
}

/**
 * Data předávaná při události startu hry
 */
export interface GameStartedEventData {
    /**
     * Klíč počáteční scény
     */
    sceneKey: string;

    /**
     * Volitelná data předaná při startu
     */
    transitionData?: any;
}

/**
 * Data předávaná při události konce hry
 */
export interface GameEndedEventData {
    /**
     * Důvod ukončení hry
     */
    reason?: string;

    /**
     * Konečné skóre nebo jiné metriky
     */
    stats?: Record<string, any>;
}

/**
 * Data předávaná při události aplikace efektu
 */
export interface EffectAppliedEventData {
    /**
     * Aplikovaný efekt
     */
    effect: any;

    /**
     * Stav po aplikaci efektu
     */
    state: any;
}

/**
 * Data předávaná při události změny stavu
 */
export interface StateChangedEventData {
    /**
     * Nový stav
     */
    state: any;

    /**
     * Změny oproti předchozímu stavu
     */
    changes?: Record<string, any>;
}

/**
 * Možnosti pro konfiguraci EventEmitter
 */
export interface EventEmitterOptions {
    /**
     * Zachytávat chyby v posluchačích událostí
     * Pokud true, chyby v posluchačích neukončí zpracování ostatních posluchačů
     * Výchozí: true
     */
    catchErrors?: boolean;

    /**
     * Maximální počet posluchačů na jeden typ události
     * Pokud je překročen, zobrazí se varování (pomáhá odhalit memory leaky)
     * Výchozí: 10
     */
    maxListeners?: number;
}
</file>

<file path="src/event/utils.ts">
import { EventEmitter } from './EventEmitter';
import { GameEventType, EventListener } from './types';

/**
 * Vytvoří funkci, která spojí více posluchačů do jednoho
 *
 * @param listeners Pole posluchačů k spojení
 * @returns Funkce, která volá všechny zadané posluchače
 */
export function combineListeners(listeners: EventListener[]): EventListener {
    return (data: any) => {
        for (const listener of listeners) {
            listener(data);
        }
    };
}

/**
 * Vytvoří předfiltrovaného posluchače, který se volá pouze pokud data splňují podmínku
 *
 * @param listener Původní posluchač
 * @param filter Funkce, která určuje, zda se posluchač zavolá
 * @returns Nový posluchač s filtrem
 */
export function createFilteredListener(
    listener: EventListener,
    filter: (data: any) => boolean
): EventListener {
    return (data: any) => {
        if (filter(data)) {
            listener(data);
        }
    };
}

/**
 * Vytvoří posluchače, který se automaticky odregistruje po N voláních
 *
 * @param emitter Instance EventEmitter
 * @param eventType Typ události
 * @param listener Původní posluchač
 * @param count Počet volání před odregistrací
 * @returns Nový posluchač, který se sám odregistruje
 */
export function createCountLimitedListener(
    emitter: EventEmitter,
    eventType: GameEventType,
    listener: EventListener,
    count: number
): EventListener {
    let callCount = 0;

    const wrappedListener: EventListener = (data: any) => {
        listener(data);
        callCount++;

        if (callCount >= count) {
            emitter.off(eventType, wrappedListener);
        }
    };

    return wrappedListener;
}

/**
 * Vytvoří debounced verzi posluchače, která se volá maximálně jednou za daný interval
 *
 * @param listener Původní posluchač
 * @param wait Čekací doba v milisekundách
 * @returns Debounced posluchač
 */
export function createDebouncedListener(
    listener: EventListener,
    wait: number
): EventListener {
    let timeout: any = null;

    return (data: any) => {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
            listener(data);
        }, wait);
    };
}

/**
 * Vytvoří throttled verzi posluchače, která se volá maximálně jednou za daný interval
 *
 * @param listener Původní posluchač
 * @param limit Minimální interval mezi voláními v milisekundách
 * @returns Throttled posluchač
 */
export function createThrottledListener(
    listener: EventListener,
    limit: number
): EventListener {
    let waiting = false;
    let lastData: any = null;

    return (data: any) => {
        if (!waiting) {
            listener(data);
            waiting = true;
            setTimeout(() => {
                waiting = false;
                if (lastData !== null) {
                    const currentData = lastData;
                    lastData = null;
                    listener(currentData);
                }
            }, limit);
        } else {
            lastData = data;
        }
    };
}

/**
 * Zabalí posluchače událostí tak, aby se vykonával asynchronně
 *
 * @param listener Původní posluchač
 * @returns Asynchronní posluchač
 */
export function createAsyncListener(listener: EventListener): EventListener {
    return (data: any) => {
        setTimeout(() => {
            listener(data);
        }, 0);
    };
}
</file>

<file path="src/loaders/GenericContentLoader.ts">
import { produce } from '../utils/immer';

/**
 * Interface pro definování content registry s lazy-loading podporou
 * @template T Typ načítaného obsahu
 * @template K Typ identifikátoru obsahu (obvykle string)
 */
export interface ContentRegistry<T, K extends string = string> {
  [key: string]: T | (() => Promise<T | { default: T }>);
}

/**
 * Konfigurační možnosti pro content loader
 * @template T Typ načítaného obsahu
 * @template K Typ identifikátoru obsahu (obvykle string)
 */
export interface ContentLoaderOptions<T extends object, K extends string = string> {
  /** Počáteční registry obsahu */
  initialRegistry?: ContentRegistry<T, K>;
}

/**
 * Generický loader pro herní obsah s podporou lazy-loadingu
 * @template T Typ načítaného obsahu
 * @template K Typ identifikátoru obsahu (obvykle string)
 */
export class GenericContentLoader<T extends object, K extends string = string> {
  /** Cache načteného obsahu */
  private loadedContent: Map<string, T> = new Map();

  /** Promise pro obsah, který se právě načítá */
  private loadingPromises: Map<string, Promise<T>> = new Map();

  /** Registry definic obsahu s podporou lazy-loadingu */
  private registry: ContentRegistry<T, K> = {} as ContentRegistry<T, K>;

  /**
   * Vytvoří nový content loader
   * @param options Konfigurační možnosti loaderu
   */
  constructor(options: ContentLoaderOptions<T, K> = {}) {
    const { initialRegistry = {} as ContentRegistry<T, K> } = options;
    this.registry = { ...initialRegistry };
  }

  /**
   * Registruje definice obsahu do loaderu
   * @param registry Registry s definicemi nebo funkcemi pro lazy-loading
   */
  public registerContent(registry: ContentRegistry<T, K>): void {
    this.registry = produce(this.registry, (draft) => {
      Object.assign(draft, registry);
    });
  }

  /**
   * Registruje všechen obsah z registry
   * @param registry Registry s definicemi nebo funkcemi pro lazy-loading
   */
  public registerAll(registry: ContentRegistry<T, K>): void {
    this.registerContent(registry);
  }

  /**
   * Načte obsah podle klíče, podporuje jak okamžitý, tak lazy-loaded obsah
   * @param key Klíč obsahu
   * @returns Promise, který se vyřeší načteným obsahem
   * @throws Error pokud obsah s daným klíčem není v registry
   */
  public async loadContent(key: string): Promise<T> {
    // Vrátit z cache, pokud již je načten
    if (this.loadedContent.has(key)) {
      return this.loadedContent.get(key)!;
    }

    // Vrátit existující promise, pokud se již načítá
    if (this.loadingPromises.has(key)) {
      return this.loadingPromises.get(key)!;
    }

    const contentDefOrImport = this.registry[key];

    if (!contentDefOrImport) {
      throw new Error(`Content with key "${key}" not found in registry`);
    }

    let loadPromise: Promise<T>;

    if (typeof contentDefOrImport === 'function') {
      // Zpracování lazy-loaded obsahu
      const loadFunction = contentDefOrImport as () => Promise<T | { default: T }>;
      loadPromise = loadFunction().then((module): T => {
        // Kontrola, zda máme default export (ES module) nebo přímý obsah
        const content = this.isModuleWithDefault(module) ? module.default : module;

        // Přidáme _key do načteného obsahu
        const enhancedContent = typeof content === 'object' && content !== null
            ? { ...content, _key: key }
            : content;

        this.loadedContent.set(key, enhancedContent);
        return enhancedContent;
      });
    } else {
      // Zpracování přímého obsahu
      const content = typeof contentDefOrImport === 'object' && contentDefOrImport !== null
          ? { ...contentDefOrImport, _key: key }
          : contentDefOrImport;

      loadPromise = Promise.resolve(content);
      this.loadedContent.set(key, content);
    }

    this.loadingPromises.set(key, loadPromise);
    return loadPromise;
  }

  /**
   * Kontroluje, zda obsah s daným klíčem existuje v registry
   * @param key Klíč obsahu
   * @returns True pokud obsah existuje, false jinak
   */
  public hasContent(key: string): boolean {
    return key in this.registry;
  }

  /**
   * Získá všechny klíče obsahu registrované v loaderu
   * @returns Pole klíčů obsahu
   */
  public getContentKeys(): string[] {
    return Object.keys(this.registry);
  }

  /**
   * Předem načte obsah podle klíčů
   * @param keys Volitelné pole klíčů obsahu k načtení, načte veškerý obsah pokud není uvedeno
   * @returns Promise, který se vyřeší, když je veškerý obsah načten
   */
  public async preloadContent(keys?: string[]): Promise<void> {
    const keysToLoad: string[] = keys || this.getContentKeys();
    await Promise.all(keysToLoad.map(key => this.loadContent(key)));
  }

  /**
   * Získá podkladový registry obsahu
   * @returns Aktuální registry obsahu
   */
  public getRegistry(): ContentRegistry<T, K> {
    return this.registry;
  }

  /**
   * Vyčistí cache a načte veškerý obsah znovu při příštím požadavku
   */
  public clearCache(): void {
    this.loadedContent.clear();
    this.loadingPromises.clear();
  }

  /**
   * Type guard pro kontrolu, zda objekt má default export
   * @param obj Objekt ke kontrole
   * @returns True pokud objekt má default vlastnost typu T
   * @private
   */
  private isModuleWithDefault(obj: any): obj is { default: T } {
    return obj && typeof obj === 'object' && 'default' in obj;
  }
}
</file>

<file path="src/loaders/index.ts">
// Exportujeme třídy
export { GenericContentLoader } from './GenericContentLoader';
export { LoaderRegistry } from './LoaderRegistry';

// Exportujeme typy s přejmenováním
export type {
    ContentLoaderOptions as GenericContentLoaderOptions
} from './GenericContentLoader';
</file>

<file path="src/loaders/LoaderRegistry.ts">
import { GenericContentLoader } from './GenericContentLoader';

/**
 * Registry for managing multiple content loaders
 * Provides a central point for registering and accessing loaders for different content types
 */
export class LoaderRegistry {
    /** Map of loaders organized by type */
    private loaders: Map<string, GenericContentLoader<any, any>> = new Map();

    /**
     * Registers a loader for a specific content type
     * @param type Content type identifier
     * @param loader Loader instance for the content type
     * @returns This registry instance for chaining
     */
    public registerLoader<T extends object, K extends string = string>(
        type: string,
        loader: GenericContentLoader<T, K>
    ): LoaderRegistry {
        this.loaders.set(type, loader);
        return this;
    }

    /**
     * Gets a loader for a specific content type
     * @template T Content type
     * @template K Content ID type
     * @param type Content type identifier
     * @returns Loader instance for the content type or undefined if not found
     */
    public getLoader<T extends object, K extends string = string>(
        type: string
    ): GenericContentLoader<T, K> | undefined {
        return this.loaders.get(type) as GenericContentLoader<T, K> | undefined;
    }

    /**
     * Checks if a loader for a specific content type exists
     * @param type Content type identifier
     * @returns True if loader exists, false otherwise
     */
    public hasLoader(type: string): boolean {
        return this.loaders.has(type);
    }

    /**
     * Gets all registered content types
     * @returns Array of content type identifiers
     */
    public getContentTypes(): string[] {
        return Array.from(this.loaders.keys());
    }

    /**
     * Removes a loader for a specific content type
     * @param type Content type identifier
     * @returns True if loader was removed, false if it didn't exist
     */
    public removeLoader(type: string): boolean {
        return this.loaders.delete(type);
    }
}
</file>

<file path="src/plugin/AbstractPlugin.ts">
import { GameEngine } from '../engine/GameEngine';
import { Plugin, PluginOptions } from './types';
import { GenericContentLoader } from '../content/GenericContentLoader';
import { Effect, EffectProcessor } from '../effect/types';
import { GameState, GameEventType, EventListener } from '../state/types';
import { SceneKey } from '../scene/types';

/**
 * Abstraktní základní třída pro pluginy
 * Poskytuje společnou funkcionalitu a strukturu pro všechny pluginy
 */
export abstract class AbstractPlugin<Options extends PluginOptions = PluginOptions> implements Plugin {
    /** Název pluginu */
    public readonly name: string;

    /** Možnosti konfigurace pluginu */
    protected options: Options;

    /** Reference na herní engine */
    protected engine: GameEngine | null = null;

    /** Loadery obsahu používané tímto pluginem */
    protected loaders: Map<string, GenericContentLoader<any>> = new Map();

    /** Registrované efekty s jmenným prostorem tohoto pluginu */
    protected registeredEffects: Set<string> = new Set();

    /** Registrované posluchače událostí pro snadnou odregistraci */
    private eventListeners: Map<GameEventType, Set<EventListener>> = new Map();

    /**
     * Vytvoří novou instanci pluginu
     *
     * @param name Název pluginu
     * @param options Možnosti konfigurace pluginu
     */
    constructor(name: string, options: Options) {
        this.name = name;
        this.options = options;
        this.setupLoaders();
    }

    /**
     * Nastaví loadery obsahu používané tímto pluginem
     * Přepište tuto metodu pro inicializaci specifických loaderů pluginu
     */
    protected setupLoaders(): void {
        // Přepište v potomkovi pro registraci specifických loaderů
    }

    /**
     * Inicializuje plugin s herním enginem
     * Tato metoda je nyní asynchronní pro podporu asynchronní inicializace
     *
     * @param engine Instance herního enginu
     */
    public async initialize(engine: GameEngine): Promise<void> {
        this.engine = engine;

        // Registrace všech loaderů v enginu
        this.loaders.forEach((loader, type) => {
            engine.getLoaderRegistry().registerLoader(type, loader);
        });

        // Registrace obsahu
        await this.registerContent();

        // Registrace posluchačů událostí
        this.registerEventHandlers();

        // Registrace procesorů efektů
        this.registerEffectProcessors();

        // Spuštění inicializace specifické pro plugin
        await this.onInitialize();
    }

    /**
     * Registruje obsah v enginu
     * Přepište tuto metodu pro registraci obsahu specifického pro plugin
     * Nyní asynchronní pro podporu lazy loadingu
     */
    protected async registerContent(): Promise<void> {
        // Přepište v potomkovi pro registraci specifického obsahu
    }

    /**
     * Registruje posluchače událostí v enginu
     * Přepište tuto metodu pro registraci posluchačů specifických pro plugin
     */
    protected registerEventHandlers(): void {
        // Přepište v potomkovi pro registraci specifických posluchačů událostí
    }

    /**
     * Registruje procesory efektů v enginu
     * Přepište tuto metodu pro registraci procesorů specifických pro plugin
     */
    protected registerEffectProcessors(): void {
        // Přepište v potomkovi pro registraci specifických procesorů efektů
    }

    /**
     * Volá se během inicializace pluginu
     * Přepište tuto metodu pro logiku inicializace specifické pro plugin
     * Nyní asynchronní pro podporu asynchronní inicializace
     */
    protected async onInitialize(): Promise<void> {
        // Přepište v potomkovi pro logiku specifickou pro plugin
    }

    /**
     * Vyčistí zdroje pluginu
     * Volá se při odregistraci pluginu
     */
    public async destroy(): Promise<void> {
        // Odregistrace všech posluchačů událostí
        if (this.engine) {
            this.unregisterEventHandlers();
            this.unregisterEffectProcessors();

            // Spuštění čištění specifického pro plugin
            await this.onDestroy();

            // Odregistrace loaderů registrovaných tímto pluginem
            this.loaders.forEach((_, type) => {
                this.engine?.getLoaderRegistry().removeLoader(type);
            });

            this.engine = null;
        }
    }

    /**
     * Odregistruje posluchače událostí z enginu
     */
    protected unregisterEventHandlers(): void {
        if (this.engine) {
            // Odregistrace všech sledovaných posluchačů událostí
            this.eventListeners.forEach((listeners, eventType) => {
                listeners.forEach(listener => {
                    this.engine?.getEventEmitter().off(eventType, listener);
                });
            });
            this.eventListeners.clear();
        }
    }

    /**
     * Odregistruje procesory efektů
     */
    protected unregisterEffectProcessors(): void {
        if (this.engine) {
            // Odregistrace všech efektů pomocí jmenného prostoru
            this.engine.getEffectManager().unregisterNamespace(this.name);
            this.registeredEffects.clear();
        }
    }

    /**
     * Volá se během čištění pluginu
     * Přepište tuto metodu pro logiku čištění specifickou pro plugin
     * Nyní asynchronní pro podporu asynchronního čištění
     */
    protected async onDestroy(): Promise<void> {
        // Přepište v potomkovi pro logiku čištění specifickou pro plugin
    }

    /**
     * Získá aktuální herní stav
     *
     * @returns Aktuální herní stav nebo undefined pokud plugin není inicializován
     */
    protected getState(): GameState | undefined {
        return this.engine?.getState();
    }

    /**
     * Získá loader obsahu podle typu
     *
     * @param type Typ obsahu
     * @returns Loader obsahu nebo undefined pokud nenalezen
     */
    protected getLoader<T extends object, K extends string = string>(type: string): GenericContentLoader<T, K> | undefined {
        return this.engine?.getLoaderRegistry().getLoader<T, K>(type);
    }

    /**
     * Přidá namespace prefix k typu efektu, pokud je potřeba
     *
     * @param effectType Typ efektu k prefixování
     * @returns Prefixovaný typ efektu
     */
    private namespaceEffectType(effectType: string): string {
        return effectType.includes(':') ? effectType : `${this.name}:${effectType}`;
    }

    /**
     * Registruje procesor efektu s automatickým prefixem namespace
     *
     * @param effectType Typ efektu
     * @param processor Funkce pro zpracování efektu
     */
    protected registerEffectProcessor(effectType: string, processor: EffectProcessor): void {
        if (this.engine) {
            const namespacedType = this.namespaceEffectType(effectType);
            this.engine.getEffectManager().registerEffectProcessor(namespacedType, processor);
            this.registeredEffects.add(namespacedType);
        }
    }

    /**
     * Registruje více procesorů efektů najednou
     *
     * @param processors Objekt mapující typy efektů na procesory
     */
    protected registerEffectProcessors(processors: Record<string, EffectProcessor>): void {
        if (!this.engine) return;

        // Přidání namespace ke všem typům efektů
        const namespacedProcessors: Record<string, EffectProcessor> = {};

        for (const [type, processor] of Object.entries(processors)) {
            const namespacedType = this.namespaceEffectType(type);
            namespacedProcessors[namespacedType] = processor;
            this.registeredEffects.add(namespacedType);
        }

        this.engine.getEffectManager().registerEffectProcessors(namespacedProcessors);
    }

    /**
     * Emituje událost s prefixem namespace
     *
     * @param eventType Typ události
     * @param data Volitelná data události
     */
    protected emitNamespacedEvent(eventType: string, data?: any): void {
        if (this.engine) {
            const namespacedType = eventType.includes(':') ? eventType : `${this.name}:${eventType}`;
            this.engine.getEventEmitter().emit(namespacedType, data);
        }
    }

    /**
     * Registruje posluchače události a sleduje ho pro automatickou odregistraci
     *
     * @param eventType Typ události
     * @param listener Funkce volaná při události
     */
    protected registerEventListener(eventType: GameEventType, listener: EventListener): void {
        if (this.engine) {
            // Registrace v enginu
            this.engine.getEventEmitter().on(eventType, listener);

            // Sledování pro pozdější odregistraci
            if (!this.eventListeners.has(eventType)) {
                this.eventListeners.set(eventType, new Set());
            }
            this.eventListeners.get(eventType)!.add(listener);
        }
    }

    /**
     * Odregistruje posluchače události
     *
     * @param eventType Typ události
     * @param listener Funkce, která byla registrována
     */
    protected unregisterEventListener(eventType: GameEventType, listener: EventListener): void {
        if (this.engine) {
            // Odregistrace z enginu
            this.engine.getEventEmitter().off(eventType, listener);

            // Odstranění ze sledování
            const listeners = this.eventListeners.get(eventType);
            if (listeners) {
                listeners.delete(listener);
                if (listeners.size === 0) {
                    this.eventListeners.delete(eventType);
                }
            }
        }
    }

    /**
     * Přesune hru do zadané scény pomocí enginu
     * Pohodlná metoda pro použití v pluginech
     *
     * @param sceneKey Klíč cílové scény
     * @param options Volitelné možnosti přechodu
     * @returns Promise který se vyřeší na true, pokud byl přechod úspěšný
     */
    protected async transitionToScene(
        sceneKey: SceneKey,
        options?: {
            effects?: Effect[],
            data?: any
        }
    ): Promise<boolean> {
        if (!this.engine) return false;
        return await this.engine.transitionToScene(sceneKey, options);
    }

    /**
     * Aplikuje efekt na herní stav pomocí enginu
     * Pohodlná metoda pro použití v pluginech
     *
     * @param effect Efekt k aplikaci
     */
    protected applyEffect(effect: Effect): void {
        if (!this.engine) return;
        this.engine.applyEffect(effect);
    }

    /**
     * Aplikuje více efektů na herní stav pomocí enginu
     * Pohodlná metoda pro použití v pluginech
     *
     * @param effects Efekty k aplikaci
     */
    protected applyEffects(effects: Effect[]): void {
        if (!this.engine) return;
        this.engine.applyEffects(effects);
    }
}
</file>

<file path="src/plugin/index.ts">
// Export typů
export * from './types';

// Export hlavních tříd
export { PluginManager } from './PluginManager';
export { AbstractPlugin } from './AbstractPlugin';

// Export konstant
export const CORE_PLUGIN_EVENTS = {
    REGISTERED: 'plugin:registered',
    UNREGISTERED: 'plugin:unregistered',
    INITIALIZED: 'plugin:initialized',
    ERROR: 'plugin:error'
} as const;

// Export utilit
export {
    createPlugin,
    createCompositePlugin,
    createLazyPlugin,
    createConditionalPlugin,
    createVersionedPlugin,
    createDebouncedPlugin
} from './utils';
</file>

<file path="src/plugin/PluginManager.ts">
import { EventEmitter } from '../event/EventEmitter';
import {
  Plugin,
  PluginRegistryOptions,
  PluginEvents,
  PluginRegisteredEventData,
  PluginUnregisteredEventData,
  PluginInitializedEventData,
  PluginErrorEventData
} from './types';
import { GameEngine } from '../engine/GameEngine';

/**
 * Správce pluginů pro herní engine
 *
 * Zodpovídá za registraci, inicializaci a správu pluginů
 * připojených k hernímu enginu.
 */
export class PluginManager {
  /**
   * Reference na herní engine
   */
  private engine: GameEngine;

  /**
   * Mapa registrovaných pluginů podle názvu
   */
  private plugins: Map<string, Plugin> = new Map();

  /**
   * Množina aktivních (inicializovaných) pluginů
   */
  private activePlugins: Set<string> = new Set();

  /**
   * Event emitter pro události pluginů
   */
  private eventEmitter: EventEmitter;

  /**
   * Možnosti konfigurace manažeru pluginů
   */
  private options: PluginRegistryOptions;

  /**
   * Vytvoří novou instanci PluginManager
   *
   * @param engine Reference na herní engine
   * @param eventEmitter Event emitter pro události
   * @param options Možnosti konfigurace
   */
  constructor(
      engine: GameEngine,
      eventEmitter: EventEmitter,
      options: PluginRegistryOptions = {}
  ) {
    this.engine = engine;
    this.eventEmitter = eventEmitter;
    this.options = {
      autoActivate: true,
      allowOverride: false,
      ...options
    };
  }

  /**
   * Registruje plugin v herním enginu
   *
   * @param plugin Plugin k registraci
   * @param activate Zda aktivovat plugin ihned po registraci
   * @returns Promise který se vyřeší na true, pokud byl plugin úspěšně registrován
   */
  public async registerPlugin(
      plugin: Plugin,
      activate?: boolean
  ): Promise<boolean> {
    const shouldActivate = activate ?? this.options.autoActivate;

    // Kontrola, zda plugin s tímto názvem již existuje
    if (this.plugins.has(plugin.name) && !this.options.allowOverride) {
      console.warn(`Plugin with name '${plugin.name}' is already registered.`);
      return false;
    }

    // Registrace pluginu
    this.plugins.set(plugin.name, plugin);

    // Emitování události registrace
    this.eventEmitter.emit(PluginEvents.REGISTERED, {
      name: plugin.name,
      plugin
    } as PluginRegisteredEventData);

    // Aktivace pluginu, pokud je požadováno
    if (shouldActivate) {
      return await this.activatePlugin(plugin.name);
    }

    return true;
  }

  /**
   * Registruje více pluginů najednou
   *
   * @param plugins Pole pluginů k registraci
   * @param activate Zda aktivovat pluginy ihned po registraci
   * @returns Promise který se vyřeší na počet úspěšně registrovaných pluginů
   */
  public async registerPlugins(
      plugins: Plugin[],
      activate?: boolean
  ): Promise<number> {
    let successCount = 0;

    for (const plugin of plugins) {
      const success = await this.registerPlugin(plugin, activate);
      if (success) {
        successCount++;
      }
    }

    return successCount;
  }

  /**
   * Aktivuje registrovaný plugin
   *
   * @param pluginName Název pluginu k aktivaci
   * @returns Promise který se vyřeší na true, pokud byl plugin úspěšně aktivován
   */
  public async activatePlugin(pluginName: string): Promise<boolean> {
    const plugin = this.plugins.get(pluginName);

    if (!plugin) {
      console.warn(`Plugin with name '${pluginName}' is not registered.`);
      return false;
    }

    // Pokud je plugin již aktivní, vrátíme true
    if (this.activePlugins.has(pluginName)) {
      return true;
    }

    // Inicializace pluginu
    try {
      await Promise.resolve(plugin.initialize(this.engine));

      // Označení pluginu jako aktivního
      this.activePlugins.add(pluginName);

      // Emitování události inicializace
      this.eventEmitter.emit(PluginEvents.INITIALIZED, {
        name: pluginName,
        plugin
      } as PluginInitializedEventData);

      console.log(`Plugin '${pluginName}' successfully initialized.`);
      return true;
    } catch (error) {
      // Emitování události chyby
      this.eventEmitter.emit(PluginEvents.ERROR, {
        name: pluginName,
        plugin,
        error,
        phase: 'initialize'
      } as PluginErrorEventData);

      console.error(`Error initializing plugin '${pluginName}':`, error);
      return false;
    }
  }

  /**
   * Deaktivuje aktivní plugin
   *
   * @param pluginName Název pluginu k deaktivaci
   * @returns Promise který se vyřeší na true, pokud byl plugin úspěšně deaktivován
   */
  public async deactivatePlugin(pluginName: string): Promise<boolean> {
    const plugin = this.plugins.get(pluginName);

    if (!plugin) {
      console.warn(`Plugin with name '${pluginName}' is not registered.`);
      return false;
    }

    // Pokud plugin není aktivní, vrátíme true
    if (!this.activePlugins.has(pluginName)) {
      return true;
    }

    // Volání destroy metody pluginu, pokud existuje
    if (plugin.destroy) {
      try {
        await Promise.resolve(plugin.destroy());
      } catch (error) {
        // Emitování události chyby
        this.eventEmitter.emit(PluginEvents.ERROR, {
          name: pluginName,
          plugin,
          error,
          phase: 'destroy'
        } as PluginErrorEventData);

        console.error(`Error destroying plugin '${pluginName}':`, error);
        return false;
      }
    }

    // Odstranění pluginu ze seznamu aktivních
    this.activePlugins.delete(pluginName);

    return true;
  }

  /**
   * Odregistruje plugin z herního enginu
   *
   * @param pluginName Název pluginu k odregistrování
   * @returns Promise který se vyřeší na true, pokud byl plugin úspěšně odregistrován
   */
  public async unregisterPlugin(pluginName: string): Promise<boolean> {
    const plugin = this.plugins.get(pluginName);

    if (!plugin) {
      console.warn(`Plugin with name '${pluginName}' is not registered.`);
      return false;
    }

    // Nejprve deaktivujeme plugin, pokud je aktivní
    if (this.activePlugins.has(pluginName)) {
      const success = await this.deactivatePlugin(pluginName);
      if (!success) {
        return false;
      }
    }

    // Odregistrace pluginu
    this.plugins.delete(pluginName);

    // Emitování události odregistrace
    this.eventEmitter.emit(PluginEvents.UNREGISTERED, {
      name: pluginName
    } as PluginUnregisteredEventData);

    console.log(`Plugin '${pluginName}' successfully unregistered.`);
    return true;
  }

  /**
   * Získá plugin podle názvu
   *
   * @template T Typ očekávaného pluginu
   * @param pluginName Název pluginu
   * @returns Plugin daného typu nebo undefined pokud plugin nebyl nalezen
   */
  public getPlugin<T extends Plugin = Plugin>(pluginName: string): T | undefined {
    return this.plugins.get(pluginName) as T | undefined;
  }

  /**
   * Vrátí názvy všech registrovaných pluginů
   *
   * @returns Pole názvů registrovaných pluginů
   */
  public getPluginNames(): string[] {
    return Array.from(this.plugins.keys());
  }

  /**
   * Vrátí všechny registrované pluginy
   *
   * @returns Pole registrovaných pluginů
   */
  public getAllPlugins(): Plugin[] {
    return Array.from(this.plugins.values());
  }

  /**
   * Vrátí názvy všech aktivních pluginů
   *
   * @returns Pole názvů aktivních pluginů
   */
  public getActivePluginNames(): string[] {
    return Array.from(this.activePlugins);
  }

  /**
   * Vrátí všechny aktivní pluginy
   *
   * @returns Pole aktivních pluginů
   */
  public getActivePlugins(): Plugin[] {
    return Array.from(this.activePlugins).map(name => this.plugins.get(name)!);
  }

  /**
   * Kontroluje, zda je plugin registrován
   *
   * @param pluginName Název pluginu
   * @returns True pokud je plugin registrován, jinak false
   */
  public hasPlugin(pluginName: string): boolean {
    return this.plugins.has(pluginName);
  }

  /**
   * Kontroluje, zda je plugin aktivní
   *
   * @param pluginName Název pluginu
   * @returns True pokud je plugin aktivní, jinak false
   */
  public isPluginActive(pluginName: string): boolean {
    return this.activePlugins.has(pluginName);
  }

  /**
   * Vrátí počet registrovaných pluginů
   *
   * @returns Počet registrovaných pluginů
   */
  public getPluginCount(): number {
    return this.plugins.size;
  }

  /**
   * Vrátí počet aktivních pluginů
   *
   * @returns Počet aktivních pluginů
   */
  public getActivePluginCount(): number {
    return this.activePlugins.size;
  }

  /**
   * Deaktivuje všechny aktivní pluginy
   *
   * @returns Promise který se vyřeší, když jsou všechny pluginy deaktivovány
   */
  public async deactivateAllPlugins(): Promise<void> {
    const activePluginNames = Array.from(this.activePlugins);

    for (const pluginName of activePluginNames) {
      await this.deactivatePlugin(pluginName);
    }
  }

  /**
   * Nastaví novou instanci enginu pro všechny pluginy
   * Použije se například při resetování či restartování enginu
   *
   * @param engine Nová instance herního enginu
   */
  public setEngine(engine: GameEngine): void {
    this.engine = engine;

    // Reinicializace všech aktivních pluginů s novým enginem
    this.resetPlugins();
  }

  /**
   * Resetuje všechny aktivní pluginy
   * Deaktivuje všechny pluginy a znovu je aktivuje
   *
   * @returns Promise který se vyřeší na true, pokud byly všechny pluginy úspěšně resetovány
   */
  public async resetPlugins(): Promise<boolean> {
    const activePluginNames = Array.from(this.activePlugins);

    // Deaktivujeme všechny pluginy
    await this.deactivateAllPlugins();

    // Opět aktivujeme všechny pluginy, které byly aktivní
    let allSuccessful = true;
    for (const pluginName of activePluginNames) {
      const success = await this.activatePlugin(pluginName);
      if (!success) {
        allSuccessful = false;
      }
    }

    return allSuccessful;
  }
}
</file>

<file path="src/plugin/types.ts">
import { GameEngine } from '../engine/GameEngine';

/**
 * Základní rozhraní pro plugin
 */
export interface Plugin {
  /**
   * Jedinečný název pluginu
   */
  name: string;

  /**
   * Inicializuje plugin a připojí jej k enginu
   * @param engine Instance herního enginu
   */
  initialize: (engine: GameEngine) => Promise<void> | void;

  /**
   * Volitelná metoda pro čištění zdrojů při odstranění pluginu
   */
  destroy?: () => Promise<void> | void;
}

/**
 * Možnosti konfigurace pluginu
 */
export interface PluginOptions {
  /**
   * Indexová signatura pro libovolné konfigurační parametry
   */
  [key: string]: any;
}

/**
 * Možnosti pro registry pluginů
 */
export interface PluginRegistryOptions {
  /**
   * Automaticky aktivovat pluginy při registraci
   * Výchozí: true
   */
  autoActivate?: boolean;

  /**
   * Zda povolit přepsání již registrovaného pluginu
   * Výchozí: false
   */
  allowOverride?: boolean;
}

/**
 * Události emitované systémem pluginů
 */
export enum PluginEvents {
  /**
   * Plugin byl registrován
   */
  REGISTERED = 'plugin:registered',

  /**
   * Plugin byl odregistrován
   */
  UNREGISTERED = 'plugin:unregistered',

  /**
   * Plugin byl inicializován
   */
  INITIALIZED = 'plugin:initialized',

  /**
   * Došlo k chybě při inicializaci pluginu
   */
  ERROR = 'plugin:error'
}

/**
 * Data předávaná při události registrace pluginu
 */
export interface PluginRegisteredEventData {
  /**
   * Název registrovaného pluginu
   */
  name: string;

  /**
   * Instance pluginu
   */
  plugin: Plugin;
}

/**
 * Data předávaná při události odregistrace pluginu
 */
export interface PluginUnregisteredEventData {
  /**
   * Název odregistrovaného pluginu
   */
  name: string;
}

/**
 * Data předávaná při události inicializace pluginu
 */
export interface PluginInitializedEventData {
  /**
   * Název inicializovaného pluginu
   */
  name: string;

  /**
   * Instance pluginu
   */
  plugin: Plugin;
}

/**
 * Data předávaná při události chyby pluginu
 */
export interface PluginErrorEventData {
  /**
   * Název pluginu, který způsobil chybu
   */
  name: string;

  /**
   * Instance pluginu
   */
  plugin: Plugin;

  /**
   * Objekt chyby
   */
  error: Error;

  /**
   * Fáze, ve které nastala chyba (např. "initialize", "destroy")
   */
  phase: string;
}
</file>

<file path="src/plugin/utils.ts">
import { Plugin, PluginOptions } from './types';
import { AbstractPlugin } from './AbstractPlugin';
import { GameEngine } from '../engine/GameEngine';

/**
 * Vytvoří jednoduchý plugin pomocí konfigurační funkce
 *
 * @param name Název pluginu
 * @param configureFn Funkce pro konfiguraci pluginu
 * @param options Volitelné možnosti konfigurace
 * @returns Nová instance pluginu
 */
export function createPlugin(
    name: string,
    configureFn: (engine: GameEngine, options: PluginOptions) => void | Promise<void>,
    options: PluginOptions = {}
): Plugin {
    class SimplePlugin extends AbstractPlugin {
        constructor() {
            super(name, options);
        }

        protected async onInitialize(): Promise<void> {
            if (this.engine) {
                await Promise.resolve(configureFn(this.engine, this.options));
            }
        }
    }

    return new SimplePlugin();
}

/**
 * Vytvoří kompozitní plugin z více pluginů
 *
 * @param name Název kompozitního pluginu
 * @param plugins Pole pluginů k zahrnutí
 * @param options Volitelné možnosti konfigurace
 * @returns Nová instance kompozitního pluginu
 */
export function createCompositePlugin(
    name: string,
    plugins: Plugin[],
    options: PluginOptions = {}
): Plugin {
    class CompositePlugin extends AbstractPlugin {
        private childPlugins: Plugin[] = [];

        constructor() {
            super(name, options);
            this.childPlugins = [...plugins];
        }

        protected async onInitialize(): Promise<void> {
            // Inicializace všech podřízených pluginů
            for (const plugin of this.childPlugins) {
                if (this.engine) {
                    await plugin.initialize(this.engine);
                }
            }
        }

        protected async onDestroy(): Promise<void> {
            // Čištění všech podřízených pluginů
            for (const plugin of this.childPlugins) {
                if (plugin.destroy) {
                    await plugin.destroy();
                }
            }
        }
    }

    return new CompositePlugin();
}

/**
 * Vytvoří plugin s možností načtení až při inicializaci (lazy loading)
 *
 * @param name Název pluginu
 * @param pluginFactory Funkce, která vrátí plugin nebo jeho Promise
 * @returns Nová instance lazy-loaded pluginu
 */
export function createLazyPlugin(
    name: string,
    pluginFactory: () => Plugin | Promise<Plugin>
): Plugin {
    class LazyPlugin implements Plugin {
        private innerPlugin: Plugin | null = null;
        public readonly name: string;

        constructor() {
            this.name = name;
        }

        public async initialize(engine: GameEngine): Promise<void> {
            // Načtení pluginu při první inicializaci
            this.innerPlugin = await Promise.resolve(pluginFactory());

            // Inicializace načteného pluginu
            await this.innerPlugin.initialize(engine);
        }

        public async destroy(): Promise<void> {
            // Čištění načteného pluginu
            if (this.innerPlugin && this.innerPlugin.destroy) {
                await this.innerPlugin.destroy();
            }
            this.innerPlugin = null;
        }
    }

    return new LazyPlugin();
}

/**
 * Vytvoří podmíněný plugin, který se inicializuje pouze pokud je splněna podmínka
 *
 * @param plugin Základní plugin
 * @param condition Funkce, která určuje, zda se plugin inicializuje
 * @returns Nová instance podmíněného pluginu
 */
export function createConditionalPlugin(
    plugin: Plugin,
    condition: (engine: GameEngine) => boolean | Promise<boolean>
): Plugin {
    class ConditionalPlugin implements Plugin {
        private initialized = false;
        public readonly name: string;

        constructor() {
            this.name = `conditional:${plugin.name}`;
        }

        public async initialize(engine: GameEngine): Promise<void> {
            // Kontrola podmínky
            const shouldInitialize = await Promise.resolve(condition(engine));

            if (shouldInitialize) {
                await plugin.initialize(engine);
                this.initialized = true;
            }
        }

        public async destroy(): Promise<void> {
            if (this.initialized && plugin.destroy) {
                await plugin.destroy();
                this.initialized = false;
            }
        }
    }

    return new ConditionalPlugin();
}

/**
 * Vytvoří verzovaný plugin s kontrolou kompatibility
 *
 * @param plugin Základní plugin
 * @param version Verze pluginu
 * @param compatibilityCheck Funkce pro kontrolu kompatibility
 * @returns Nová instance verzovaného pluginu
 */
export function createVersionedPlugin(
    plugin: Plugin,
    version: string,
    compatibilityCheck: (engineVersion: string) => boolean
): Plugin {
    class VersionedPlugin implements Plugin {
        public readonly name: string;
        public readonly version: string;

        constructor() {
            this.name = plugin.name;
            this.version = version;
        }

        public async initialize(engine: GameEngine): Promise<void> {
            // Kontrola kompatibility s enginem
            const engineVersion = engine.getVersion();
            if (!compatibilityCheck(engineVersion)) {
                throw new Error(
                    `Plugin '${this.name}' version ${this.version} is not compatible with engine version ${engineVersion}.`
                );
            }

            await plugin.initialize(engine);
        }

        public async destroy(): Promise<void> {
            if (plugin.destroy) {
                await plugin.destroy();
            }
        }
    }

    return new VersionedPlugin();
}

/**
 * Vytvoří debounced verzi pluginu, který odloží inicializaci
 * Užitečné pro optimalizaci při hromadné registraci více pluginů
 *
 * @param plugin Základní plugin
 * @param delay Zpoždění inicializace v ms
 * @returns Nová instance pluginu s odloženou inicializací
 */
export function createDebouncedPlugin(
    plugin: Plugin,
    delay: number = 100
): Plugin {
    class DebouncedPlugin implements Plugin {
        private engine: GameEngine | null = null;
        private initTimeout: any = null;
        private initialized = false;
        public readonly name: string;

        constructor() {
            this.name = `debounced:${plugin.name}`;
        }

        public async initialize(engine: GameEngine): Promise<void> {
            this.engine = engine;

            // Zrušení předchozího timeoutu, pokud existuje
            if (this.initTimeout) {
                clearTimeout(this.initTimeout);
            }

            // Odložení inicializace
            return new Promise<void>((resolve) => {
                this.initTimeout = setTimeout(async () => {
                    await plugin.initialize(engine);
                    this.initialized = true;
                    resolve();
                }, delay);
            });
        }

        public async destroy(): Promise<void> {
            // Zrušení timeoutu, pokud inicializace ještě neproběhla
            if (this.initTimeout) {
                clearTimeout(this.initTimeout);
                this.initTimeout = null;
            }

            if (this.initialized && plugin.destroy) {
                await plugin.destroy();
                this.initialized = false;
            }

            this.engine = null;
        }
    }

    return new DebouncedPlugin();
}
</file>

<file path="src/save/index.ts">
// Export typů
export * from './types';

// Export hlavních tříd
export { SaveManager } from './SaveManager';
export { MemoryStorage } from './MemoryStorage';

// Export utilit
export {
    createSaveManager,
    validateSaveData,
    generateSaveId,
    formatPlayTime,
    exportSaveToFile,
    importSaveFromFile
} from './utils';
</file>

<file path="src/save/MemoryStorage.ts">
import { SaveData, SaveMetadata, SaveStorage } from './types';

/**
 * In-memory implementace SaveStorage
 * Používá se hlavně pro testování nebo pro dočasné ukládání
 */
export class MemoryStorage implements SaveStorage {
    /**
     * Mapa uložených her (ID -> data)
     */
    private saves: Map<string, SaveData> = new Map();

    /**
     * Uloží data do paměti
     *
     * @param id Identifikátor uložené hry
     * @param data Data k uložení
     * @returns Promise rozhodnutý na true
     */
    public async save(id: string, data: SaveData): Promise<boolean> {
        this.saves.set(id, { ...data });
        return true;
    }

    /**
     * Načte data z paměti
     *
     * @param id Identifikátor uložené hry
     * @returns Promise rozhodnutý na data, nebo null pokud neexistují
     */
    public async load(id: string): Promise<SaveData | null> {
        const save = this.saves.get(id);
        return save ? { ...save } : null;
    }

    /**
     * Vrátí seznam všech uložených her
     *
     * @returns Promise rozhodnutý na objekt mapující ID na metadata
     */
    public async list(): Promise<Record<string, SaveMetadata>> {
        const result: Record<string, SaveMetadata> = {};
        for (const [id, data] of this.saves.entries()) {
            result[id] = { ...data.metadata };
        }
        return result;
    }

    /**
     * Smaže uloženou hru
     *
     * @param id Identifikátor uložené hry
     * @returns Promise rozhodnutý na true, pokud byla hra smazána
     */
    public async delete(id: string): Promise<boolean> {
        return this.saves.delete(id);
    }

    /**
     * Zkontroluje, zda existuje uložená hra
     *
     * @param id Identifikátor uložené hry
     * @returns Promise rozhodnutý na true, pokud hra existuje
     */
    public async exists(id: string): Promise<boolean> {
        return this.saves.has(id);
    }

    /**
     * Vymaže všechna uložení
     *
     * @returns Promise rozhodnutý na true
     */
    public async clearAll(): Promise<boolean> {
        this.saves.clear();
        return true;
    }

    /**
     * Vrátí počet uložených her
     *
     * @returns Počet uložených her
     */
    public getCount(): number {
        return this.saves.size;
    }
}
</file>

<file path="src/save/SaveManager.ts">
import {
    SaveData,
    SaveMetadata,
    SaveOptions,
    SaveStorage,
    AutoSaveOptions,
    SaveEvents
} from './types';
import { GameEngine } from '../engine/GameEngine';
import { EventEmitter } from '../event/EventEmitter';
import { SceneKey } from '../scene/types';

// Aktuální verze formátu uložených her
const CURRENT_SAVE_VERSION = 1;

/**
 * Správce ukládání a načítání her
 *
 * Koordinuje proces ukládání a načítání her, včetně správy metadat,
 * verzování a automatického ukládání.
 */
export class SaveManager {
    /**
     * Event emitter pro události SaveManageru
     */
    private eventEmitter: EventEmitter;

    /**
     * Reference na herní engine
     */
    private engine: GameEngine;

    /**
     * Úložiště pro uložené hry
     */
    private storage: SaveStorage;

    /**
     * Aktuální verze enginu
     * Použije se pro metadata uložených her
     */
    private readonly engineVersion: string;

    /**
     * Časovač pro automatické ukládání
     */
    private autoSaveTimer: number | null = null;

    /**
     * Nastavení pro automatické ukládání
     */
    private autoSaveOptions: AutoSaveOptions | null = null;

    /**
     * Počítadlo automatických uložení
     */
    private autoSaveCounter: number = 0;

    /**
     * Čas startu hry pro sledování času hraní
     */
    private gameStartTime: number;

    /**
     * Celkový čas hraní v milisekundách
     */
    private totalPlayTime: number = 0;

    /**
     * ID rychlého uložení
     */
    private readonly quickSaveId: string = 'quicksave';

    /**
     * Vytvoří novou instanci SaveManager
     *
     * @param engine Reference na herní engine
     * @param options Možnosti konfigurace
     */
    constructor(engine: GameEngine, options: {
        storage: SaveStorage;
        engineVersion?: string;
        eventEmitter?: EventEmitter;
    }) {
        this.engine = engine;
        this.storage = options.storage;
        this.engineVersion = options.engineVersion || '0.1.0';
        this.eventEmitter = options.eventEmitter || engine.getEventEmitter();
        this.gameStartTime = Date.now();

        // Sledování událostí enginu
        this.setupEventListeners();
    }

    /**
     * Nastaví event listenery pro sledování herních událostí
     */
    private setupEventListeners(): void {
        // Sledování začátku hry pro reset času
        this.eventEmitter.on('gameStarted', () => {
            this.gameStartTime = Date.now();
        });

        // Zde můžeme přidat další event listenery pro sledování herních událostí
    }

    /**
     * Uloží aktuální stav hry
     *
     * @param saveId Identifikátor uložené hry
     * @param options Další možnosti pro uložení
     * @returns Promise rozhodnutý na true, pokud bylo uložení úspěšné
     */
    public async save(saveId: string, options: SaveOptions = {}): Promise<boolean> {
        // Aktualizace času hraní
        this.updatePlayTime();

        // Vytvoření metadat
        const metadata: SaveMetadata = {
            id: saveId,
            name: options.name || this.generateDefaultSaveName(),
            createdAt: Date.now(),
            updatedAt: Date.now(),
            playTime: this.totalPlayTime,
            engineVersion: this.engineVersion,
            saveVersion: CURRENT_SAVE_VERSION,
            currentSceneKey: this.engine.getCurrentSceneKey(),
            ...options
        };

        // Serializace herního stavu
        const state = this.engine.getStateManager().serialize();

        // Vytvoření dat uložené hry
        const saveData: SaveData = {
            metadata,
            state
        };

        // Uložení dat
        const success = await this.storage.save(saveId, saveData);

        if (success) {
            this.eventEmitter.emit(SaveEvents.GAME_SAVED, { saveId, metadata });
        }

        return success;
    }

    /**
     * Načte uloženou hru
     *
     * @param saveId Identifikátor uložené hry
     * @returns Promise rozhodnutý na true, pokud bylo načtení úspěšné
     */
    public async load(saveId: string): Promise<boolean> {
        // Načtení dat
        const saveData = await this.storage.load(saveId);
        if (!saveData) {
            console.error(`Save with id '${saveId}' not found.`);
            return false;
        }

        try {
            // Kontrola verze a případná migrace
            const migratedData = this.migrateIfNeeded(saveData);

            // Deserializace herního stavu
            this.engine.getStateManager().deserialize(migratedData.state);

            // Nastavení času hraní
            this.totalPlayTime = migratedData.metadata.playTime || 0;
            this.gameStartTime = Date.now();

            // Přechod na uloženou scénu
            const currentSceneKey = migratedData.metadata.currentSceneKey;
            if (currentSceneKey) {
                await this.engine.transitionToScene(currentSceneKey as SceneKey);
            }

            this.eventEmitter.emit(SaveEvents.GAME_LOADED, { saveId, metadata: migratedData.metadata });
            return true;
        } catch (error) {
            console.error(`Failed to load game with id '${saveId}':`, error);
            return false;
        }
    }

    /**
     * Vrátí seznam všech uložených her
     *
     * @returns Promise rozhodnutý na objekt mapující ID na metadata
     */
    public async getSaves(): Promise<Record<string, SaveMetadata>> {
        return await this.storage.list();
    }

    /**
     * Smaže uloženou hru
     *
     * @param saveId Identifikátor uložené hry
     * @returns Promise rozhodnutý na true, pokud bylo smazání úspěšné
     */
    public async deleteSave(saveId: string): Promise<boolean> {
        const success = await this.storage.delete(saveId);

        if (success) {
            this.eventEmitter.emit(SaveEvents.GAME_DELETED, { saveId });
        }

        return success;
    }

    /**
     * Provede rychlé uložení
     *
     * @returns Promise rozhodnutý na true, pokud bylo uložení úspěšné
     */
    public async quickSave(): Promise<boolean> {
        return await this.save(this.quickSaveId, {
            name: 'Rychlé uložení'
        });
    }

    /**
     * Načte rychlé uložení
     *
     * @returns Promise rozhodnutý na true, pokud bylo načtení úspěšné
     */
    public async quickLoad(): Promise<boolean> {
        const exists = await this.storage.exists(this.quickSaveId);
        if (!exists) {
            console.warn('No quicksave found.');
            return false;
        }

        return await this.load(this.quickSaveId);
    }

    /**
     * Aktivuje automatické ukládání
     *
     * @param options Nastavení pro automatické ukládání
     */
    public enableAutoSave(options: AutoSaveOptions = {}): void {
        // Deaktivace existujícího automatického ukládání
        this.disableAutoSave();

        // Výchozí hodnoty
        this.autoSaveOptions = {
            interval: options.interval || 5 * 60 * 1000, // 5 minut
            slots: options.slots || 3,
            prefix: options.prefix || 'auto',
            beforeSave: options.beforeSave,
            afterSave: options.afterSave
        };

        // Spuštění časovače
        this.autoSaveTimer = window.setInterval(() => {
            this.performAutoSave();
        }, this.autoSaveOptions.interval);

        this.eventEmitter.emit(SaveEvents.AUTO_SAVE_ENABLED, { options: this.autoSaveOptions });
    }

    /**
     * Deaktivuje automatické ukládání
     */
    public disableAutoSave(): void {
        if (this.autoSaveTimer !== null) {
            clearInterval(this.autoSaveTimer);
            this.autoSaveTimer = null;
            this.autoSaveOptions = null;
            this.eventEmitter.emit(SaveEvents.AUTO_SAVE_DISABLED, {});
        }
    }

    /**
     * Provede automatické uložení
     *
     * @returns Promise rozhodnutý na true, pokud bylo uložení úspěšné
     * @private
     */
    private async performAutoSave(): Promise<boolean> {
        if (!this.autoSaveOptions) return false;

        // Kontrola podmínky před uložením
        if (this.autoSaveOptions.beforeSave) {
            const shouldSave = await Promise.resolve(this.autoSaveOptions.beforeSave());
            if (!shouldSave) return false;
        }

        // Výpočet ID pro auto-save
        const autoSaveSlot = this.autoSaveCounter % (this.autoSaveOptions.slots || 1);
        this.autoSaveCounter++;

        const saveId = `${this.autoSaveOptions.prefix}_${autoSaveSlot}`;
        const success = await this.save(saveId, {
            name: `Automatické uložení ${autoSaveSlot + 1}`
        });

        // Callback po uložení
        if (success && this.autoSaveOptions.afterSave) {
            await Promise.resolve(this.autoSaveOptions.afterSave(saveId));
        }

        return success;
    }

    /**
     * Generuje výchozí název pro uloženou hru
     *
     * @returns Výchozí název založený na aktuálním datu a čase
     * @private
     */
    private generateDefaultSaveName(): string {
        const now = new Date();
        const dateStr = now.toLocaleDateString();
        const timeStr = now.toLocaleTimeString();
        const sceneName = this.engine.getCurrentScene()?.title || 'Neznámá scéna';

        return `${sceneName} - ${dateStr} ${timeStr}`;
    }

    /**
     * Aktualizuje celkový čas hraní
     *
     * @private
     */
    private updatePlayTime(): void {
        const now = Date.now();
        this.totalPlayTime += now - this.gameStartTime;
        this.gameStartTime = now;
    }

    /**
     * Zkontroluje, zda je potřeba migrace uložené hry a případně ji provede
     *
     * @param saveData Data uložené hry
     * @returns Migrovaná data
     * @private
     */
    private migrateIfNeeded(saveData: SaveData): SaveData {
        // Aktuálně pouze kontrolujeme, že save existuje
        if (!saveData.metadata.saveVersion) {
            // Pro starší verze bez specifikované verze nastavíme verzi 1
            saveData.metadata.saveVersion = 1;
        }

        // V budoucnu zde mohou být migrace mezi verzemi
        // if (saveData.metadata.saveVersion < CURRENT_SAVE_VERSION) {
        //   // Migrace mezi verzemi
        // }

        return saveData;
    }

    /**
     * Vrátí aktuální čas hraní v milisekundách
     *
     * @returns Aktuální čas hraní v milisekundách
     */
    public getPlayTime(): number {
        return this.totalPlayTime + (Date.now() - this.gameStartTime);
    }

    /**
     * Naformátuje čas hraní do čitelné podoby
     *
     * @param timeMs Čas v milisekundách
     * @returns Naformátovaný čas ve formátu "HH:MM:SS"
     */
    public formatPlayTime(timeMs?: number): string {
        const time = timeMs !== undefined ? timeMs : this.getPlayTime();

        const seconds = Math.floor((time / 1000) % 60);
        const minutes = Math.floor((time / (1000 * 60)) % 60);
        const hours = Math.floor(time / (1000 * 60 * 60));

        return [
            hours.toString().padStart(2, '0'),
            minutes.toString().padStart(2, '0'),
            seconds.toString().padStart(2, '0')
        ].join(':');
    }

    /**
     * Vymaže všechna uložení
     *
     * @returns Promise rozhodnutý na true, pokud bylo smazání úspěšné
     */
    public async clearAllSaves(): Promise<boolean> {
        const saves = await this.getSaves();
        const results = await Promise.all(
            Object.keys(saves).map(id => this.deleteSave(id))
        );

        const allSuccessful = results.every(result => result);

        if (allSuccessful) {
            this.eventEmitter.emit(SaveEvents.ALL_SAVES_CLEARED, {});
        }

        return allSuccessful;
    }

    /**
     * Vrátí používané úložiště
     *
     * @returns Úložiště používané tímto SaveManagerem
     */
    public getStorage(): SaveStorage {
        return this.storage;
    }

    /**
     * Nastaví nové úložiště
     *
     * @param storage Nové úložiště
     */
    public setStorage(storage: SaveStorage): void {
        this.storage = storage;
        this.eventEmitter.emit(SaveEvents.STORAGE_CHANGED, { storage });
    }
}
</file>

<file path="src/save/types.ts">
/**
 * Metadata uložené hry
 * Obsahuje informace o uložené hře bez herního stavu samotného
 */
export interface SaveMetadata {
    /**
     * Unikátní identifikátor uložené hry
     */
    id: string;

    /**
     * Název nebo popis uložené hry
     */
    name: string;

    /**
     * Časové razítko vytvoření uložené hry
     */
    createdAt: number;

    /**
     * Časové razítko poslední aktualizace uložené hry
     */
    updatedAt: number;

    /**
     * Celkový čas strávený hrou v milisekundách
     */
    playTime: number;

    /**
     * Verze enginu, ve které byla hra uložena
     */
    engineVersion: string;

    /**
     * Verze formátu uložené hry
     */
    saveVersion: number;

    /**
     * Klíč aktuální scény v době uložení
     */
    currentSceneKey: string | null;

    /**
     * Thumbnail nebo obrázek reprezentující uloženou hru (volitelné)
     */
    thumbnail?: string;

    /**
     * Další vlastnosti specifické pro konkrétní hru nebo implementaci úložiště
     */
    [key: string]: any;
}

/**
 * Reprezentace uložené hry včetně herního stavu
 */
export interface SaveData {
    /**
     * Metadata o uložené hře
     */
    metadata: SaveMetadata;

    /**
     * Serializovaný herní stav
     */
    state: string;

    /**
     * Volitelné dodatečné údaje specifické pro implementaci úložiště
     */
    [key: string]: any;
}

/**
 * Možnosti pro vytvoření nové uložené hry
 */
export interface SaveOptions {
    /**
     * Název nebo popis uložené hry (volitelné)
     * Pokud není uveden, bude použit aktuální datum a čas
     */
    name?: string;

    /**
     * Thumbnail nebo obrázek reprezentující uloženou hru (volitelné)
     */
    thumbnail?: string;

    /**
     * Další možnosti specifické pro implementaci úložiště
     */
    [key: string]: any;
}

/**
 * Nastavení pro automatické ukládání
 */
export interface AutoSaveOptions {
    /**
     * Interval v milisekundách mezi automatickými uloženími
     * Výchozí hodnota je 5 minut
     */
    interval?: number;

    /**
     * Maximální počet automatických uložení
     * Výchozí hodnota je 3
     */
    slots?: number;

    /**
     * Prefix pro názvy automatických uložení
     * Výchozí hodnota je 'auto'
     */
    prefix?: string;

    /**
     * Callback volaný před automatickým uložením
     * Může být použit k rozhodnutí, zda automatické uložení provést
     */
    beforeSave?: () => boolean | Promise<boolean>;

    /**
     * Callback volaný po automatickém uložení
     */
    afterSave?: (saveId: string) => void | Promise<void>;

    /**
     * Další možnosti specifické pro implementaci úložiště
     */
    [key: string]: any;
}

/**
 * Metody pro práci s úložištěm uložených her
 */
export interface SaveStorage {
    /**
     * Uloží data do úložiště
     *
     * @param id Identifikátor uložené hry
     * @param data Data k uložení
     * @returns Promise rozhodnutý na true, pokud bylo uložení úspěšné
     */
    save(id: string, data: SaveData): Promise<boolean>;

    /**
     * Načte data z úložiště
     *
     * @param id Identifikátor uložené hry
     * @returns Promise rozhodnutý na data, nebo null pokud uložená hra neexistuje
     */
    load(id: string): Promise<SaveData | null>;

    /**
     * Vrátí seznam všech uložených her
     *
     * @returns Promise rozhodnutý na objekt mapující ID na metadata
     */
    list(): Promise<Record<string, SaveMetadata>>;

    /**
     * Smaže uloženou hru
     *
     * @param id Identifikátor uložené hry
     * @returns Promise rozhodnutý na true, pokud bylo smazání úspěšné
     */
    delete(id: string): Promise<boolean>;

    /**
     * Zkontroluje, zda existuje uložená hra s daným ID
     *
     * @param id Identifikátor uložené hry
     * @returns Promise rozhodnutý na true, pokud uložená hra existuje
     */
    exists(id: string): Promise<boolean>;
}

/**
 * Typy událostí emitovaných SaveManager
 */
export enum SaveEvents {
    GAME_SAVED = 'save:gameSaved',
    GAME_LOADED = 'save:gameLoaded',
    GAME_DELETED = 'save:gameDeleted',
    AUTO_SAVE_ENABLED = 'save:autoSaveEnabled',
    AUTO_SAVE_DISABLED = 'save:autoSaveDisabled',
    ALL_SAVES_CLEARED = 'save:allSavesCleared',
    STORAGE_CHANGED = 'save:storageChanged'
}
</file>

<file path="src/save/utils.ts">
import { GameEngine } from '../engine/GameEngine';
import { SaveManager } from './SaveManager';
import { SaveStorage, AutoSaveOptions } from './types';
import { MemoryStorage } from './MemoryStorage';
import { LocalStorageProxy } from './LocalStorageProxy';

/**
 * Možnosti pro vytvoření SaveManageru
 */
export interface CreateSaveManagerOptions {
    /**
     * Úložiště pro uložené hry
     */
    storage?: SaveStorage;

    /**
     * Verze enginu
     */
    engineVersion?: string;

    /**
     * Zda automaticky aktivovat automatické ukládání
     */
    enableAutoSave?: boolean;

    /**
     * Interval automatického ukládání v milisekundách
     */
    autoSaveInterval?: number;

    /**
     * Počet slotů pro automatické ukládání
     */
    autoSaveSlots?: number;

    /**
     * Prefix pro klíče v localStorage (pouze pro localStorage úložiště)
     */
    storagePrefix?: string;

    /**
     * Typ úložiště
     * 'memory' - uložení do paměti (pouze pro běh aplikace)
     * 'localStorage' - uložení do localStorage prohlížeče
     * Výchozí: 'localStorage'
     */
    storageType?: 'memory' | 'localStorage';
}

/**
 * Vytvoří SaveManager s předkonfigurovaným nastavením
 *
 * @param engine Instance herního enginu
 * @param options Možnosti pro vytvoření SaveManageru
 * @returns Instance SaveManageru
 */
export function createSaveManager(
    engine: GameEngine,
    options: CreateSaveManagerOptions = {}
): SaveManager {
    // Vytvoření úložiště, pokud není specifikováno
    let storage = options.storage;
    if (!storage) {
        const storageType = options.storageType || 'localStorage';
        if (storageType === 'memory') {
            storage = new MemoryStorage();
        } else {
            storage = new LocalStorageProxy({ prefix: options.storagePrefix });
        }
    }

    // Získání verze enginu z enginu, pokud existuje metoda getVersion
    const engineVersion = options.engineVersion ||
        (typeof engine.getVersion === 'function' ? engine.getVersion() : '0.1.0');

    // Vytvoření SaveManageru
    const saveManager = new SaveManager(engine, {
        storage,
        engineVersion
    });

    // Aktivace automatického ukládání, pokud je požadováno
    if (options.enableAutoSave) {
        const autoSaveOptions: AutoSaveOptions = {};

        if (options.autoSaveInterval) {
            autoSaveOptions.interval = options.autoSaveInterval;
        }

        if (options.autoSaveSlots) {
            autoSaveOptions.slots = options.autoSaveSlots;
        }

        saveManager.enableAutoSave(autoSaveOptions);
    }

    return saveManager;
}

/**
 * Validuje data uložené hry
 *
 * @param saveData Data k validaci
 * @returns True pokud jsou data validní, jinak false
 */
export function validateSaveData(saveData: any): boolean {
    if (!saveData || typeof saveData !== 'object') {
        return false;
    }

    // Kontrola existence a typu požadovaných vlastností
    if (!saveData.metadata || typeof saveData.metadata !== 'object') {
        return false;
    }

    if (typeof saveData.state !== 'string') {
        return false;
    }

    // Kontrola požadovaných polí metadat
    const requiredMetadataFields = ['id', 'name', 'createdAt', 'updatedAt', 'saveVersion'];
    for (const field of requiredMetadataFields) {
        if (!(field in saveData.metadata)) {
            return false;
        }
    }

    return true;
}

/**
 * Vytvoří jedinečné ID pro uloženou hru
 *
 * @param prefix Volitelný prefix
 * @returns Jedinečné ID
 */
export function generateSaveId(prefix: string = 'save'): string {
    const timestamp = Date.now();
    const random = Math.floor(Math.random() * 1000000).toString().padStart(6, '0');
    return `${prefix}_${timestamp}_${random}`;
}

/**
 * Převede čas hraní z milisekund na formátovaný řetězec
 *
 * @param timeMs Čas v milisekundách
 * @param format Formát výstupu ('short', 'medium', 'long')
 * @returns Naformátovaný řetězec
 */
export function formatPlayTime(
    timeMs: number,
    format: 'short' | 'medium' | 'long' = 'medium'
): string {
    const seconds = Math.floor((timeMs / 1000) % 60);
    const minutes = Math.floor((timeMs / (1000 * 60)) % 60);
    const hours = Math.floor(timeMs / (1000 * 60 * 60));
    const days = Math.floor(timeMs / (1000 * 60 * 60 * 24));

    switch (format) {
        case 'short':
            if (hours > 0) {
                return `${hours}h ${minutes}m`;
            } else {
                return `${minutes}m ${seconds}s`;
            }
        case 'long':
            let parts = [];
            if (days > 0) parts.push(`${days} ${days === 1 ? 'den' : 'dnů'}`);
            if (hours > 0) parts.push(`${hours} ${getHoursText(hours)}`);
            if (minutes > 0) parts.push(`${minutes} ${getMinutesText(minutes)}`);
            if (seconds > 0 || parts.length === 0) {
                parts.push(`${seconds} ${getSecondsText(seconds)}`);
            }
            return parts.join(', ');
        case 'medium':
        default:
            return [
                hours.toString().padStart(2, '0'),
                minutes.toString().padStart(2, '0'),
                seconds.toString().padStart(2, '0')
            ].join(':');
    }
}

// Pomocné funkce pro českou lokalizaci
function getHoursText(hours: number): string {
    if (hours === 1) return 'hodina';
    if (hours >= 2 && hours <= 4) return 'hodiny';
    return 'hodin';
}

function getMinutesText(minutes: number): string {
    if (minutes === 1) return 'minuta';
    if (minutes >= 2 && minutes <= 4) return 'minuty';
    return 'minut';
}

function getSecondsText(seconds: number): string {
    if (seconds === 1) return 'sekunda';
    if (seconds >= 2 && seconds <= 4) return 'sekundy';
    return 'sekund';
}

/**
 * Exportuje uloženou hru do souboru
 *
 * @param saveData Data uložené hry
 * @param filename Název souboru
 */
export function exportSaveToFile(saveData: any, filename: string = 'save.json'): void {
    if (typeof window === 'undefined') {
        console.warn('Export to file is only available in browser environment');
        return;
    }

    try {
        const json = JSON.stringify(saveData, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();

        // Uvolnění URL po stažení
        setTimeout(() => {
            URL.revokeObjectURL(url);
        }, 100);
    } catch (error) {
        console.error('Failed to export save file:', error);
    }
}

/**
 * Importuje uloženou hru ze souboru
 *
 * @param file Soubor k importu
 * @returns Promise rozhodnutý na data uložené hry
 */
export function importSaveFromFile(file: File): Promise<any> {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();

        reader.onload = (e) => {
            try {
                const content = e.target?.result as string;
                const saveData = JSON.parse(content);

                if (!validateSaveData(saveData)) {
                    reject(new Error('Invalid save file format'));
                    return;
                }

                resolve(saveData);
            } catch (error) {
                reject(error);
            }
        };

        reader.onerror = () => {
            reject(new Error('Error reading file'));
        };

        reader.readAsText(file);
    });
}
</file>

<file path="src/scene/index.ts">
// Export typů
export * from './types';

// Export hlavních tříd
export { SceneManager } from './SceneManager';

// Export utilit
export {
    getSceneContent,
    isSceneVisited,
    validateScene,
    normalizeSceneKey,
    getParentSceneKey,
    getSceneNameFromKey
} from './utils';
</file>

<file path="src/scene/SceneManager.ts">
import { GameState } from '../state/types';
import { Scene, SceneKey } from './types';
import { GenericContentLoader } from '../content/GenericContentLoader';

/**
 * Spravuje scény a přechody mezi nimi
 */
export class SceneManager {
    /** Klíč aktuální scény */
    private currentSceneKey: SceneKey | null = null;

    /** Reference na objekt aktuální scény */
    private currentScene: Scene | null = null;

    /** Content loader pro scény */
    private sceneLoader: GenericContentLoader<Scene>;

    /**
     * Vytvoří novou instanci SceneManager
     */
    constructor(sceneLoader: GenericContentLoader<Scene>) {
        this.sceneLoader = sceneLoader;
    }

    /**
     * Přechod na novou scénu
     */
    public async transitionToScene(
        sceneKey: SceneKey,
        state: GameState,
        engine: any
    ): Promise<boolean> {
        try {
            const targetScene: Scene = await this.sceneLoader.loadContent(sceneKey);

            if (!targetScene) {
                console.error(`Scene with key '${sceneKey}' not found.`);
                return false;
            }

            // Pokud existuje aktuální scéna, zavolá se její onExit metoda
            if (this.currentScene && this.currentScene.onExit) {
                this.currentScene.onExit(state, engine);
            }

            // Aktualizace aktuální scény
            this.currentSceneKey = sceneKey;
            this.currentScene = targetScene;

            // Aktualizace stavu pro sledování navštívených scén
            if (engine.getStateManager && typeof engine.getStateManager === 'function') {
                engine.getStateManager().updateState((draftState: GameState) => {
                    draftState.visitedScenes.add(sceneKey);
                });
            } else {
                state.visitedScenes.add(sceneKey);
            }

            // Zavolání onEnter metody nové scény
            if (targetScene.onEnter) {
                targetScene.onEnter(state, engine);
            }

            return true;
        } catch (error) {
            console.error(`Error transitioning to scene '${sceneKey}':`, error);
            return false;
        }
    }

    /**
     * Získá aktuální scénu
     */
    public getCurrentScene(): Scene | null {
        return this.currentScene;
    }

    /**
     * Získá klíč aktuální scény
     */
    public getCurrentSceneKey(): SceneKey | null {
        return this.currentSceneKey;
    }

    /**
     * Předem načte scény podle klíčů
     */
    public async preloadScenes(sceneKeys?: SceneKey[]): Promise<void> {
        return this.sceneLoader.preloadContent(sceneKeys);
    }

    /**
     * Získá loader používaný tímto managerem
     */
    public getSceneLoader(): GenericContentLoader<Scene> {
        return this.sceneLoader;
    }
}
</file>

<file path="src/scene/types.ts">
import { GameState } from '../state/types';
import { Effect } from '../effect/types';

/**
 * Typ pro klíč scény
 */
export type SceneKey = string;

/**
 * Reprezentuje scénu ve hře
 */
export interface Scene {
    /**
     * Titulek scény
     */
    title: string;

    /**
     * Obsah scény, může být statický nebo dynamický
     */
    content: string | ((state: GameState) => string);

    /**
     * Handler volaný při vstupu do scény
     */
    onEnter?: (state: GameState, engine: any) => void;

    /**
     * Handler volaný při odchodu ze scény
     */
    onExit?: (state: GameState, engine: any) => void;

    /**
     * Další metadata pro rozšíření funkcionality
     */
    metadata?: Record<string, any>;

    /**
     * Interní property obsahující klíč scény
     * @internal
     */
    _key?: SceneKey;
}

/**
 * Funkce pro načtení scény
 */
export type SceneLoader = () => Promise<{ default: Scene } | Scene>;

/**
 * Registry scén mapující klíče na definice nebo loadery
 */
export type ScenesRegistry = Record<SceneKey, Scene | SceneLoader>;

/**
 * Možnosti pro přechod mezi scénami
 */
export interface SceneTransitionOptions {
    /** Volitelné efekty, které se aplikují před přechodem */
    effects?: Effect[];

    /** Volitelná data pro předání scéně při přechodu */
    data?: any;
}
</file>

<file path="src/scene/utils.ts">
import { Scene, SceneKey, ScenesRegistry } from './types';
import { GameState } from '../state/types';

/**
 * Získá text obsahu scény, řeší dynamický i statický obsah
 */
export function getSceneContent(scene: Scene, state: GameState): string {
    if (typeof scene.content === 'function') {
        return scene.content(state);
    }
    return scene.content;
}

/**
 * Zjistí, zda scéna byla již navštívena
 */
export function isSceneVisited(sceneKey: SceneKey, state: GameState): boolean {
    return state.visitedScenes.has(sceneKey);
}

/**
 * Validuje kompletnost a správnost definice scény
 */
export function validateScene(scene: Scene): boolean {
    if (!scene.title || !scene.content) {
        return false;
    }

    return true;
}

/**
 * Normalizuje klíč scény (např. převod neplatných znaků, normalizace cesty)
 */
export function normalizeSceneKey(key: string): SceneKey {
    return key.trim().replace(/\/{2,}/g, '/').replace(/^\/|\/$/g, '');
}

/**
 * Získá rodičovský klíč scény (např. pro 'forest/clearing' vrátí 'forest')
 */
export function getParentSceneKey(sceneKey: SceneKey): SceneKey | null {
    const lastSlashIndex = sceneKey.lastIndexOf('/');
    if (lastSlashIndex === -1) {
        return null;
    }
    return sceneKey.substring(0, lastSlashIndex);
}

/**
 * Získá název scény z klíče (např. pro 'forest/clearing' vrátí 'clearing')
 */
export function getSceneNameFromKey(sceneKey: SceneKey): string {
    const lastSlashIndex = sceneKey.lastIndexOf('/');
    if (lastSlashIndex === -1) {
        return sceneKey;
    }
    return sceneKey.substring(lastSlashIndex + 1);
}
</file>

<file path="src/state/index.ts">
// Export typů
export * from './types';

// Export hlavních tříd
export { StateManager } from './StateManager';

// Export utilit
export {
    getStatePath,
    setStatePath,
    hasStatePath,
    createStateSnapshot,
    compareStates,
    validateState
} from './utils';
</file>

<file path="src/state/StateManager.ts">
import {
    GameState,
    StateManagerOptions,
    SerializationOptions,
    StateMetadata,
    PERSISTENT_KEYS_KEY, // Not used internally, but good to keep if it's part of the public API contract or documentation
    DEFAULT_PERSISTENT_KEYS,
    StateChangedEvent,
    StateMigrationFn,
    StateManagerEvents,
    PersistedState
} from './types'; // Assuming these types are correctly defined in './types'
import { produce } from '../utils/immer'; // Assuming the path is correct
import { TypedEventEmitter } from '../event/TypedEventEmitter'; // Assuming the path is correct

/**
 * Aktuální verze formátu stavu
 */
const CURRENT_STATE_VERSION = 1;

/**
 * Spravuje herní stav s důrazem na neměnnost
 * Umožňuje serializaci, deserializaci a migraci stavu.
 * @template T Typ proměnných ve stavu
 */
export class StateManager<T extends Record<string, unknown> = Record<string, unknown>> {
    /**
     * Herní stav
     */
    private state: GameState<T>;

    /**
     * Seznam klíčů, které budou persistovány při serializaci
     * Uloženo mimo stav pro zachování neměnnosti a flexibilitu.
     */
    private persistentKeys: string[];

    /**
     * Event emitter pro události StateManageru
     */
    private eventEmitter: TypedEventEmitter<StateManagerEvents<T>>;

    /**
     * Callback volaný před serializací stavu
     */
    private onBeforeSerialize?: (state: GameState<T>) => void;

    /**
     * Callback volaný po deserializaci stavu
     */
    private onAfterDeserialize?: (state: GameState<T>) => void;

    /**
     * Statická mapa migračních funkcí
     * Klíčem je verze stavu *před* migrací (fromVersion).
     */
    private static migrations = new Map<number, StateMigrationFn>();

    /**
     * Vytvoří novou instanci StateManager
     * @param options Možnosti konfigurace
     */
    constructor(options: StateManagerOptions<T> = {}) {
        // Inicializuje stav pomocí createInitialState, které aplikuje defaulty a počáteční stav z options
        this.state = this.createInitialState(options.initialState || {});
        // Inicializuje perzistentní klíče, buď z options nebo výchozí
        this.persistentKeys = options.persistentKeys || DEFAULT_PERSISTENT_KEYS;
        this.eventEmitter = new TypedEventEmitter<StateManagerEvents<T>>();
        this.onBeforeSerialize = options.onBeforeSerialize;
        this.onAfterDeserialize = options.onAfterDeserialize;

        // Zajištění, že základní perzistentní klíče jsou vždy v seznamu při inicializaci
        this.ensureDefaultPersistentKeys();
    }

    /**
     * Zajistí, že výchozí perzistentní klíče (visitedScenes, variables) jsou vždy v seznamu.
     * Voláno v konstruktoru.
     */
    private ensureDefaultPersistentKeys(): void {
        if (!this.persistentKeys.includes('visitedScenes')) {
            this.persistentKeys.push('visitedScenes');
        }
        if (!this.persistentKeys.includes('variables')) {
            this.persistentKeys.push('variables');
        }
        // Případně další klíče, které by měly být *vždy* perzistentní
    }


    /**
     * Vytvoří výchozí herní stav.
     * Používá se při inicializaci nebo resetu.
     * @param initialState Počáteční stav k aplikaci přes defaultní strukturu.
     * @returns Nově vytvořený GameState objekt.
     */
    private createInitialState(initialState: Partial<GameState<T>>): GameState<T> {
        // Základní struktura stavu s výchozími hodnotami pro klíčové vlastnosti
        const baseState: GameState<T> = {
            visitedScenes: new Set<string>(),
            variables: {} as T,
            // Přidejte zde další výchozí hodnoty pro neperzistentní klíče, pokud existují
        };

        // Aplikuje initialState přes základní strukturu.
        // Toto je pro konstruktor/reset, NE pro deserializaci.
        return {
            ...baseState,
            ...initialState, // Může přepsat visitedScenes nebo variables, pokud jsou v initialState
            // Zajistí, že visitedScenes je vždy Set po aplikaci initialState
            visitedScenes: initialState.visitedScenes instanceof Set
                ? initialState.visitedScenes
                : new Set(initialState.visitedScenes)
        } as GameState<T>; // Přetypování pro jistotu, pokud initialState přidá dynamické klíče
    }


    /**
     * Vrátí aktuální herní stav
     * @returns Aktuální neměnný GameState objekt.
     */
    public getState(): GameState<T> {
        return this.state; // Immer zajišťuje, že state je de facto neměnný externě
    }

    /**
     * Aktualizuje herní stav pomocí Immer.
     * Vytvoří novou verzi stavu a emituje událost.
     * @param updater Funkce, která přijme draft stavu a provede změny.
     * @param source Zdroj změny (volitelné, pro účely ladění/sledování).
     */
    public updateState(updater: (state: GameState<T>) => void, source?: string): void {
        const previousState = this.state;

        // Immer produce vytvoří nový, neměnný stav, pokud došlo ke změnám v draftu
        this.state = produce(this.state, (draft: GameState<T>) => {
            updater(draft);
        });

        // Emitování události změny stavu pouze pokud se stav skutečně změnil (Immer produce vrací původní objekt, pokud nebyly změny)
        if (this.state !== previousState) {
            this.emitStateChanged(previousState, this.state, source);
        }
        // Poznámka: Immer může vracet *ten samý* objekt, pokud nedošlo k žádné změně.
        // Porovnání referencí (this.state !== previousState) je správný způsob, jak zjistit, zda se stav "změnil" z pohledu Immer.
    }

    /**
     * Nastaví kompletně nový herní stav.
     * Přímé nahrazení stavu, obchází Immer produce pro tento konkrétní případ.
     * @param newState Nový stav, který se stane aktuálním.
     * @param source Zdroj změny (volitelné).
     */
    public setState(newState: GameState<T>, source?: string): void {
        const previousState = this.state;
        this.state = newState; // Přímé nahrazení

        // Emitování události změny stavu
        this.emitStateChanged(previousState, this.state, source);
    }

    /**
     * Resetuje stav na výchozí hodnoty.
     * Vytvoří nový stav pomocí createInitialState.
     * @param options Částečný stav k nastavení přes výchozí hodnoty po resetu.
     */
    public resetState(options: Partial<GameState<T>> = {}): void {
        const previousState = this.state;
        this.state = this.createInitialState(options); // Vytvoření nového výchozího stavu

        // Emitování události změny stavu
        this.emitStateChanged(previousState, this.state, 'reset');
    }

    /**
     * Serializuje herní stav do JSON řetězce.
     * Vytvoří objekt obsahující pouze perzistentní klíče a metadata.
     * @param options Možnosti serializace (zahrnutí metadat, replacer funkce).
     * @returns JSON řetězec reprezentující perzistentní stav.
     */
    public serialize(options: SerializationOptions = {}): string {
        const { includeMetadata = true, replacer } = options;

        // Volání callbacku před serializací
        if (this.onBeforeSerialize) {
            this.onBeforeSerialize(this.state);
        }

        // Emitování události před serializací
        this.eventEmitter.emit('beforeSerialize', { state: this.state });

        // Vytvoření objektu pro serializaci - bude obsahovat jen perzistentní data
        const serializableState: PersistedState<T> = {} as PersistedState<T>;

        // Přidání pouze perzistentních klíčů ze stavu
        for (const key of this.persistentKeys) {
            // Zajištění, že klíč existuje ve stavu (nebo je visitedScenes/variables)
            // visitedScenes a variables jsou speciální případy, ale jsou zahrnuty v persistentKeys
            if (key === 'visitedScenes') {
                // Speciální zpracování: Set -> Array
                if (this.state.visitedScenes instanceof Set) {
                    serializableState.visitedScenes = Array.from(this.state.visitedScenes);
                } else if (Array.isArray(this.state.visitedScenes)) {
                    // Možná už je to pole z nějakého důvodu? Převede na Set a zpět na pole pro konzistenci
                    serializableState.visitedScenes = Array.from(new Set(this.state.visitedScenes));
                } else {
                    // Pokud to není ani Set, ani Array, serializujeme jako prázdné pole?
                    serializableState.visitedScenes = [];
                }
            } else if (key === 'variables') {
                // Speciální zpracování: variables (typ T)
                // Zde předpokládáme, že T je přímo serializovatelné nebo obsahuje serializovatelné typy
                serializableState.variables = this.state.variables;
            } else if (key in this.state) {
                // Ostatní perzistentní klíče
                (serializableState as any)[key] = this.state[key]; // Použití any kvůli dynamickému přístupu
            }
        }

        // Přidání metadat, pokud je požadováno
        if (includeMetadata) {
            serializableState._metadata = this.createStateMetadata();
        }

        // Vrací JSON řetězec, potenciálně s custom replacerem
        return JSON.stringify(serializableState, replacer);
    }

    /**
     * Vytvoří metadata o stavu pro serializaci.
     * @returns Objekt StateMetadata.
     */
    private createStateMetadata(): StateMetadata {
        return {
            version: CURRENT_STATE_VERSION,
            timestamp: Date.now()
        };
    }

    /**
     * Deserializuje JSON řetězec do herního stavu.
     * Nahradí aktuální stav deserializovaným stavem.
     * @param serializedState Serializovaný stav v JSON formátu.
     * @throws Chyba při selhání parsování JSON nebo migraci.
     */
    public deserialize(serializedState: string): void {
        const previousState = this.state; // Uchování předchozího stavu pro událost

        try {
            // 1. Parsování JSON řetězce
            const parsedState = JSON.parse(serializedState) as PersistedState<unknown>;

            // 2. Migrace stavu na aktuální verzi, pokud je potřeba
            // migrateState vrací nový objekt nebo upravený parsedState
            const migratedState = this.migrateState(parsedState);

            // 3. Vytvoření zcela nového GameState objektu z migrovaných perzistentních dat.
            // Tím se zajistí, že nepřeneseme neperzistentní data z předchozího this.state.

            // Inicializace základní struktury newState s výchozími hodnotami pro klíčové persistentní vlastnosti
            // na základě dat z migratedState.
            const newState: GameState<T> = {
                // visitedScenes: Převede pole zpět na Set. Pokud migratedState.visitedScenes neexistuje, použije prázdné pole,
                // což vytvoří prázdný Set.
                visitedScenes: new Set(migratedState.visitedScenes || []),
                // variables: Použije variables z migratedState. Pokud neexistuje, použije prázdný objekt.
                // Přetypuje na T, předpokládaje, že migrace zajistila správný tvar.
                variables: (migratedState.variables || {}) as T,
                // Ostatní perzistentní klíče budou přidány v následujícím kroku
            } as GameState<T>; // Přetypování na GameState<T>

            // 4. Kopírování dalších perzistentních vlastností z migratedState do newState.
            // Iterujeme přes klíče definované v this.persistentKeys.
            for (const key of this.persistentKeys) {
                // visitedScenes a variables už jsme zpracovali, přeskočíme je
                if (key === 'visitedScenes' || key === 'variables') {
                    continue;
                }

                // Pokud klíč existuje v migrovaném stavu (a není to metadata)
                // zkopírujeme jeho hodnotu do nového stavu.
                if (key in migratedState && key !== '_metadata') {
                    // Přístup přes 'any' je nutný kvůli dynamickým klíčům
                    (newState as any)[key] = (migratedState as any)[key];
                }
            }

            // Poznámka: Metadata (_metadata) by neměla být v persistentKeys, takže se nekopírují do newState.
            // Pokud by se z nějakého důvodu dostala do newState (např. špatná migrace),
            // bylo by dobré je zde explicitně odstranit, ale při správném toku by to nemělo být nutné.
            // if ('_metadata' in newState) {
            //     delete (newState as any)._metadata;
            // }


            // 5. Nastavení nově vytvořeného stavu jako aktuálního stavu StateManageru
            this.state = newState;

            // 6. Volání callbacku po deserializaci
            if (this.onAfterDeserialize) {
                this.onAfterDeserialize(this.state);
            }

            // 7. Emitování události po deserializaci
            this.eventEmitter.emit('afterDeserialize', { state: this.state });

            // 8. Emitování události změny stavu (předchozí stav je ten před deserializací)
            this.emitStateChanged(previousState, this.state, 'deserialize');

        } catch (error) {
            console.error("StateManager: Failed to deserialize state:", error);
            // Volitelně: Zde můžete přidat logiku pro obnovu předchozího stavu
            // nebo vyhození chyby, aby volající věděl, že deserializace selhala.
            // throw error; // Příklad vyhození chyby
        }
    }

    /**
     * Migruje stav na aktuální verzi.
     * Postupně aplikuje migrační funkce od verze stavu až po aktuální verzi.
     * @param state Stav k migraci (očekává PersistedState<unknown> s volitelnými metadaty).
     * @returns Migrovaný stav ve formátu PersistedState<unknown>.
     */
    private migrateState(state: PersistedState<unknown>): PersistedState<unknown> {
        // Vytvoří pracovní kopii stavu pro migraci (Immer produce by se zde dal použít také)
        let migratedState = { ...state }; // Používáme spread, protože migrace může přidávat/mazat klíče

        // Pokud stav nemá metadata, předpokládáme verzi 0
        if (!migratedState._metadata) {
            migratedState._metadata = { version: 0, timestamp: Date.now() };
        }

        let stateVersion = migratedState._metadata.version;

        // Pokud je verze stavu aktuální, není potřeba migrace
        if (stateVersion === CURRENT_STATE_VERSION) {
            return migratedState;
        }

        console.log(`StateManager: Migrating state from version ${stateVersion} to ${CURRENT_STATE_VERSION}`);

        // Postupně aplikujeme migrační funkce
        // Iterujeme od verze stavu (včetně) až po *před* aktuální verzi
        for (let v = stateVersion; v < CURRENT_STATE_VERSION; v++) {
            const migrationFn = StateManager.migrations.get(v); // Hledáme migraci pro verzi 'v' -> 'v+1'

            if (migrationFn) {
                console.log(`StateManager: Applying migration from version ${v} to ${v + 1}`);
                try {
                    // Aplikujeme migrační funkci na aktuální migrovaný stav
                    migratedState = migrationFn(migratedState, v, v + 1);

                    // Emitování události o aplikaci migrace
                    this.eventEmitter.emit('migrationApplied', {
                        fromVersion: v,
                        toVersion: v + 1,
                        state: migratedState as PersistedState<T> // Přetypování pro událost
                    });

                    // Aktualizujeme verzi v metadatech pracovní kopie po úspěšné migraci
                    if (migratedState._metadata) {
                        migratedState._metadata.version = v + 1;
                    }

                } catch (migrationError) {
                    console.error(`StateManager: Migration from version ${v} to ${v + 1} failed:`, migrationError);
                    // Důležité: Pokud migrace selže, měli bychom zvážit, co dělat.
                    // Ponechat stav v nekonzistentním stavu? Zahodit ho? Vyhodit chybu?
                    // Prozatím logujeme chybu a pokračujeme s částečně migrovaným stavem,
                    // což nemusí být bezpečné. V produkční aplikaci by se zde měla řešit strategie obnovy.
                    // throw migrationError; // Možnost vyhodit chybu
                }

            } else {
                console.warn(`StateManager: No migration function found for version ${v} to ${v + 1}. State may be incomplete or incorrect.`);
                // Pokud chybí migrace, stav nemůže být plně migrován.
                // Můžeme zde zastavit proces migrace a vyhodit chybu,
                // nebo pokračovat s varováním, což je méně bezpečné.
            }
        }

        // Konečná verze v metadatech by měla být CURRENT_STATE_VERSION,
        // což už je zajištěno postupným aktualizováním v cyklu.
        // Přesto můžeme pro jistotu zkontrolovat a nastavit:
        if (migratedState._metadata) {
            migratedState._metadata.version = CURRENT_STATE_VERSION;
        }


        console.log(`StateManager: Migration complete. State is now version ${CURRENT_STATE_VERSION}.`);

        return migratedState;
    }

    /**
     * Získá hodnotu proměnné ze stavu.
     * @param name Název proměnné.
     * @param defaultValue Výchozí hodnota, pokud proměnná neexistuje nebo je undefined.
     * @returns Hodnota proměnné nebo defaultValue, pokud je poskytnuto.
     */
    public getVariable<K extends keyof T>(name: K, defaultValue?: T[K]): T[K] | undefined {
        // Použití nullish coalescing (??) pro správné vrácení defaultValue pro null/undefined
        return this.state.variables[name] ?? defaultValue;
    }

    /**
     * Nastaví hodnotu proměnné ve stavu.
     * Používá updateState pro zajištění neměnnosti.
     * @param name Název proměnné.
     * @param value Hodnota k nastavení.
     */
    public setVariable<K extends keyof T>(name: K, value: T[K]): void {
        this.updateState(state => {
            // Immer draft umožňuje přímou modifikaci
            state.variables[name] = value;
        }, 'setVariable');
    }

    /**
     * Zkontroluje, zda proměnná existuje (není undefined/null) ve stavu.
     * @param name Název proměnné.
     * @returns True, pokud proměnná existuje a není undefined nebo null.
     */
    public hasVariable<K extends keyof T>(name: K): boolean {
        // Kontroluje, zda je klíč přítomen A hodnota není undefined nebo null
        // Pokud byste chtěli kontrolovat pouze přítomnost klíče (včetně undefined/null hodnot), použijte `name in this.state.variables`.
        return this.state.variables[name] !== undefined && this.state.variables[name] !== null;
    }

    /**
     * Odebere proměnnou ze stavu.
     * @param name Název proměnné k odebrání.
     */
    public removeVariable<K extends keyof T>(name: K): void {
        this.updateState(state => {
            // Použijte delete pro odstranění klíče
            delete state.variables[name];
        }, 'removeVariable');
    }


    /**
     * Sloučí externí částečný stav s aktuálním stavem.
     * Používá updateState pro vytvoření nového stavu.
     * @param externalState Částečný stav k sloučení.
     */
    public mergeState(externalState: Partial<GameState<T>>): void {
        this.updateState(state => {
            // Sloučení visitedScenes (přidání nových do existujícího Setu)
            if (externalState.visitedScenes) {
                // Zajištění, že externalState.visitedScenes je iterovatelné
                const scenesToAdd = externalState.visitedScenes instanceof Set
                    ? externalState.visitedScenes
                    : Array.isArray(externalState.visitedScenes)
                        ? new Set(externalState.visitedScenes)
                        : []; // Pokud to není ani Set ani Array, nic nepřidáme

                for (const sceneKey of scenesToAdd) {
                    state.visitedScenes.add(sceneKey);
                }
            }

            // Sloučení variables (přepsání existujících a přidání nových)
            if (externalState.variables) {
                // Použití Object.assign nebo spread operátoru na draftu
                Object.assign(state.variables, externalState.variables);
                // state.variables = { ...state.variables, ...externalState.variables }; // Alternativa
            }

            // Sloučení ostatních vlastností (ty, které nejsou visitedScenes nebo variables)
            // Iterujeme přes externalState, abychom věděli, co přidat/přepsat
            for (const key in externalState) {
                // Zajištění, že jde o vlastní vlastnost a není to visitedScenes nebo variables
                if (Object.prototype.hasOwnProperty.call(externalState, key) && key !== 'visitedScenes' && key !== 'variables') {
                    // Přístup přes 'any' je nutný kvůli dynamickým klíčům GameState
                    (state as any)[key] = (externalState as any)[key];
                }
            }
        }, 'mergeState');
    }

    /**
     * Registruje migrační funkci pro konkrétní verzi stavu.
     * @param fromVersion Zdrojová verze (verze před aplikací migrace).
     * @param migrationFn Migrační funkce.
     * @returns Funkce pro odregistraci migrace.
     */
    public static registerMigration(fromVersion: number, migrationFn: StateMigrationFn): () => boolean {
        if (StateManager.migrations.has(fromVersion)) {
            console.warn(`StateManager: Migration for version ${fromVersion} is already registered. Overwriting.`);
        }
        StateManager.migrations.set(fromVersion, migrationFn);
        return () => StateManager.unregisterMigration(fromVersion);
    }

    /**
     * Odregistruje migrační funkci pro konkrétní verzi stavu.
     * @param fromVersion Zdrojová verze.
     * @returns True pokud byla migrace úspěšně odregistrována, jinak False.
     */
    public static unregisterMigration(fromVersion: number): boolean {
        return StateManager.migrations.delete(fromVersion);
    }

    /**
     * Získá aktuální verzi formátu stavu, kterou StateManager používá.
     * @returns Aktuální verze stavu.
     */
    public static getCurrentStateVersion(): number {
        return CURRENT_STATE_VERSION;
    }

    /**
     * Emituje událost změny stavu.
     * @param previousState Předchozí stav (může být null při deserializaci).
     * @param newState Nový aktuální stav.
     * @param source Zdroj změny.
     */
    private emitStateChanged(previousState: GameState<T> | null, newState: GameState<T>, source?: string): void {
        this.eventEmitter.emit('stateChanged', {
            previousState, // Odkaz na předchozí stav (neměnný)
            newState,      // Odkaz na nový stav (neměnný)
            source         // Zdroj změny
        });
    }

    /**
     * Registruje posluchače události StateManageru.
     * @template K Typ klíče události.
     * @param event Typ události.
     * @param listener Funkce volaná při události.
     */
    public on<K extends keyof StateManagerEvents<T>>(
        event: K,
        listener: (data: StateManagerEvents<T>[K]) => void
    ): void {
        this.eventEmitter.on(event, listener);
    }

    /**
     * Odregistruje posluchače události StateManageru.
     * @template K Typ klíče události.
     * @param event Typ události.
     * @param listener Funkce volaná při události.
     */
    public off<K extends keyof StateManagerEvents<T>>(
        event: K,
        listener: (data: StateManagerEvents<T>[K]) => void
    ): void {
        this.eventEmitter.off(event, listener);
    }

    /**
     * Označí scénu jako navštívenou.
     * Přidá klíč scény do Setu visitedScenes.
     * @param sceneKey Klíč scény.
     */
    public markSceneVisited(sceneKey: string): void {
        this.updateState(state => {
            // Add metoda Setu je idempotentní
            state.visitedScenes.add(sceneKey);
        }, 'markSceneVisited');
    }

    /**
     * Zruší označení scény jako navštívené.
     * Odebere klíč scény ze Setu visitedScenes.
     * @param sceneKey Klíč scény.
     */
    public unmarkSceneVisited(sceneKey: string): void {
        this.updateState(state => {
            // Delete metoda Setu nic nedělá, pokud prvek neexistuje
            state.visitedScenes.delete(sceneKey);
        }, 'unmarkSceneVisited');
    }

    /**
     * Vyčistí seznam navštívených scén.
     * Nastaví visitedScenes na prázdný Set.
     */
    public clearVisitedScenes(): void {
        this.updateState(state => {
            state.visitedScenes.clear(); // Clear metoda Setu
        }, 'clearVisitedScenes');
    }

    /**
     * Zkontroluje, zda scéna byla navštívena.
     * @param sceneKey Klíč scény.
     * @returns True, pokud scéna je v Setu visitedScenes.
     */
    public hasVisitedScene(sceneKey: string): boolean {
        return this.state.visitedScenes.has(sceneKey);
    }

    /**
     * Vrátí počet navštívených scén.
     * @returns Počet prvků v Setu visitedScenes.
     */
    public getVisitedScenesCount(): number {
        return this.state.visitedScenes.size;
    }

    /**
     * Nastaví seznam klíčů, které budou persistovány při serializaci.
     * Zajistí, že základní klíče (visitedScenes, variables) jsou vždy zahrnuty.
     * Emituje událost persistentKeysChanged.
     * @param keys Seznam klíčů k nastavení.
     */
    public setPersistentKeys(keys: string[]): void {
        // Vytvoří novou kopii pole pro zajištění neměnnosti pole perzistentních klíčů (externě)
        this.persistentKeys = [...keys];
        // Zajistí, že základní klíče jsou v novém seznamu
        this.ensureDefaultPersistentKeys();

        // Emitování události o změně perzistentních klíčů
        this.eventEmitter.emit('persistentKeysChanged', { keys: this.persistentKeys });
    }

    /**
     * Vrátí seznam klíčů, které budou persistovány při serializaci.
     * @returns Kopie pole perzistentních klíčů.
     */
    public getPersistentKeys(): string[] {
        // Vrací kopii, aby se externí kód nemohl měnit interní pole přímo
        return [...this.persistentKeys];
    }

    /**
     * Přidá klíč do seznamu perzistentních klíčů, pokud tam ještě není.
     * Emituje událost persistentKeysChanged, pokud klíč byl přidán.
     * @param key Klíč k přidání.
     */
    public addPersistentKey(key: string): void {
        if (!this.persistentKeys.includes(key)) {
            this.persistentKeys = [...this.persistentKeys, key]; // Vytvoření nového pole

            // Emitování události o změně perzistentních klíčů
            this.eventEmitter.emit('persistentKeysChanged', { keys: this.persistentKeys });
        }
    }

    /**
     * Odebere klíč ze seznamu perzistentních klíčů, pokud tam je.
     * Základní klíče (visitedScenes, variables) nelze odebrat pomocí této metody.
     * Emituje událost persistentKeysChanged, pokud klíč byl odebrán.
     * @param key Klíč k odebrání.
     */
    public removePersistentKey(key: string): void {
        // Kontrola, zda se nejedná o základní perzistentní klíč
        if (key === 'visitedScenes' || key === 'variables') {
            console.warn(`StateManager: Cannot remove default persistent key "${key}".`);
            return;
        }

        const index = this.persistentKeys.indexOf(key);
        if (index !== -1) {
            this.persistentKeys = [
                ...this.persistentKeys.slice(0, index),
                ...this.persistentKeys.slice(index + 1)
            ]; // Vytvoření nového pole bez odebraného klíče

            // Emitování události o změně perzistentních klíčů
            this.eventEmitter.emit('persistentKeysChanged', { keys: this.persistentKeys });
        }
    }
}
</file>

<file path="src/state/types.ts">
/**
 * Základní herní stav
 * Obsahuje základní strukturu pro ukládání herního stavu
 * @template T Typ pro proměnné, výchozí je prázdný objekt
 */
export interface GameState<T extends Record<string, unknown> = Record<string, unknown>> {
    /**
     * Množina klíčů navštívených scén
     */
    visitedScenes: Set<string>;

    /**
     * Úložiště herních proměnných
     */
    variables: T;

    /**
     * Indexová signatura pro další vlastnosti
     * Umožňuje rozšiřování stavu pluginy a dalšími komponentami
     */
    [key: string]: any;
}

/**
 * Klíč pro perzistentní vlastnosti ve stavu - pouze pro interní použití
 */
export const PERSISTENT_KEYS_KEY = '__persistentKeys';

/**
 * Výchozí perzistentní klíče
 */
export const DEFAULT_PERSISTENT_KEYS = ['visitedScenes', 'variables'];

/**
 * Funkce pro aktualizaci herního stavu
 * Používá se s immer pro bezpečné mutace
 * @template T Typ proměnných ve stavu
 */
export type StateUpdater<T extends Record<string, unknown> = Record<string, unknown>> = (state: GameState<T>) => void;

/**
 * Možnosti pro vytvoření StateManager
 * @template T Typ proměnných ve stavu
 */
export interface StateManagerOptions<T extends Record<string, unknown> = Record<string, unknown>> {
    /**
     * Počáteční stav, který bude sloučen s výchozím prázdným stavem
     */
    initialState?: Partial<GameState<T>>;

    /**
     * Seznam klíčů, které budou persistovány při serializaci
     */
    persistentKeys?: string[];

    /**
     * Callback volaný před serializací stavu
     */
    onBeforeSerialize?: (state: GameState<T>) => void;

    /**
     * Callback volaný po deserializaci stavu
     */
    onAfterDeserialize?: (state: GameState<T>) => void;
}

/**
 * Možnosti pro serializaci stavu
 */
export interface SerializationOptions {
    /**
     * Zda zahrnout metadata o stavu (např. verzi enginu)
     * Výchozí: true
     */
    includeMetadata?: boolean;

    /**
     * Vlastní replacer funkce pro JSON.stringify
     */
    replacer?: (key: string, value: any) => any;

    /**
     * Další volby specifické pro implementaci
     */
    [key: string]: any;
}

/**
 * Metadata o stavu
 */
export interface StateMetadata {
    /**
     * Verze formátu stavu
     */
    version: number;

    /**
     * Časové razítko vytvoření
     */
    timestamp: number;

    /**
     * Další metadata
     */
    [key: string]: any;
}

/**
 * Data předávaná při události změny stavu
 */
export interface StateChangedEvent<T extends Record<string, unknown> = Record<string, unknown>> {
    /**
     * Předchozí stav
     */
    previousState: GameState<T> | null;

    /**
     * Nový stav
     */
    newState: GameState<T>;

    /**
     * Zdroj změny (např. 'effect', 'scene', 'plugin', atd.)
     */
    source?: string;
}

/**
 * Typ pro migrační funkci
 */
export type StateMigrationFn = (state: PersistedState<unknown>, fromVersion: number, toVersion: number) => PersistedState<unknown>;

/**
 * Typ pro persistovanou část stavu (při serializaci/deserializaci)
 */
export interface PersistedState<T extends Record<string, unknown> = Record<string, unknown>> {
    /**
     * Navštívené scény - konvertované na pole pro JSON serializaci
     */
    visitedScenes: string[];

    /**
     * Herní proměnné
     */
    variables: T;

    /**
     * Metadata stavu
     */
    _metadata?: StateMetadata;

    /**
     * Další persistované vlastnosti
     */
    [key: string]: unknown;
}

/**
 * Eventy emitované StateManagerem
 */
export interface StateManagerEvents<T extends Record<string, unknown> = Record<string, unknown>> {
    /**
     * Emitováno při změně stavu
     */
    stateChanged: StateChangedEvent<T>;

    /**
     * Emitováno při změně perzistentních klíčů
     */
    persistentKeysChanged: { keys: string[] };

    /**
     * Emitováno po aplikaci migrace
     */
    migrationApplied: {
        fromVersion: number;
        toVersion: number;
        state: PersistedState<T>;
    };

    /**
     * Emitováno před serializací stavu
     */
    beforeSerialize: { state: GameState<T> };

    /**
     * Emitováno po deserializaci stavu
     */
    afterDeserialize: { state: GameState<T> };
}
</file>

<file path="src/state/utils.ts">
import { GameState, StateMigrationFn, PersistedState } from './types';
import { StateManager } from './StateManager';
import lodashGet from 'lodash/get';
import lodashSet from 'lodash/set';
import lodashHas from 'lodash/has';
import { produce } from '../utils/immer';

/**
 * Získá hodnotu z herního stavu pomocí cesty (dot notation)
 * @template T Typ očekávaného výstupu
 * @param state Herní stav
 * @param path Cesta k hodnotě (např. 'variables.player.health')
 * @param defaultValue Výchozí hodnota, pokud cesta neexistuje
 */
export function getStatePath<T>(state: GameState<any>, path: string, defaultValue?: T): T | undefined {
    return lodashGet(state, path, defaultValue);
}

/**
 * Nastaví hodnotu v herním stavu pomocí cesty (dot notation)
 * @param state Herní stav
 * @param path Cesta k hodnotě (např. 'variables.player.health')
 * @param value Hodnota k nastavení
 * @returns Nový herní stav
 */
export function setStatePath<T extends Record<string, unknown>>(
    state: GameState<T>,
    path: string,
    value: any
): GameState<T> {
    return produce(state, draft => {
        lodashSet(draft, path, value);
    });
}

/**
 * Zkontroluje, zda cesta existuje v herním stavu
 * @param state Herní stav
 * @param path Cesta k kontrole
 * @returns True pokud cesta existuje
 */
export function hasStatePath(state: GameState<any>, path: string): boolean {
    return lodashHas(state, path);
}

/**
 * Vytvoří snapshot stavu (hluboká kopie)
 * @param state Herní stav
 * @returns Kopie stavu
 */
export function createStateSnapshot<T extends Record<string, unknown>>(state: GameState<T>): GameState<T> {
    // Použijeme JSON.parse/stringify pro hluboké klonování
    // Převedeme Set na pole a zpět
    const serialized = JSON.stringify({
        ...state,
        visitedScenes: Array.from(state.visitedScenes)
    });

    const parsed = JSON.parse(serialized);
    return {
        ...parsed,
        visitedScenes: new Set(parsed.visitedScenes)
    };
}

/**
 * Porovná dva stavy a vrátí rozdíly
 * @param oldState Starý stav
 * @param newState Nový stav
 * @returns Objekt s rozdíly
 */
export function compareStates<T extends Record<string, unknown>>(
    oldState: GameState<T>,
    newState: GameState<T>
): Record<string, any> {
    const differences: Record<string, any> = {};

    // Porovnání visitedScenes
    const oldScenes = Array.from(oldState.visitedScenes);
    const newScenes = Array.from(newState.visitedScenes);
    const addedScenes = newScenes.filter(scene => !oldState.visitedScenes.has(scene));
    const removedScenes = oldScenes.filter(scene => !newState.visitedScenes.has(scene));

    if (addedScenes.length > 0 || removedScenes.length > 0) {
        differences.visitedScenes = {
            added: addedScenes,
            removed: removedScenes
        };
    }

    // Porovnání variables
    const oldVars = oldState.variables;
    const newVars = newState.variables;
    const changedVars: Record<string, { old: any; new: any }> = {};

    // Kontrola změněných a přidaných proměnných
    const allKeys = new Set([...Object.keys(oldVars), ...Object.keys(newVars)]);

    for (const key of allKeys) {
        // Hluboké porovnání může být pomalé pro složité objekty
        // Pro jednoduchost používáme JSON.stringify, ale v produkčním kódu
        // by bylo lepší použít specializovanou knihovnu pro hluboké porovnání
        const oldJson = JSON.stringify(oldVars[key]);
        const newJson = JSON.stringify(newVars[key]);

        if (oldJson !== newJson) {
            changedVars[key] = {
                old: oldVars[key],
                new: newVars[key]
            };
        }
    }

    if (Object.keys(changedVars).length > 0) {
        differences.variables = changedVars;
    }

    // Porovnání ostatních vlastností (první úroveň)
    const excludeKeys = ['visitedScenes', 'variables', '_metadata'];

    for (const key in newState) {
        if (!excludeKeys.includes(key)) {
            // Opět používáme JSON.stringify pro jednoduché hluboké porovnání
            const oldJson = JSON.stringify(oldState[key]);
            const newJson = JSON.stringify(newState[key]);

            if (!(key in oldState) || oldJson !== newJson) {
                differences[key] = {
                    old: oldState[key],
                    new: newState[key]
                };
            }
        }
    }

    for (const key in oldState) {
        if (!excludeKeys.includes(key) && !(key in newState)) {
            differences[key] = {
                old: oldState[key],
                new: undefined
            };
        }
    }

    return differences;
}

/**
 * Validuje herní stav
 * @param state Herní stav
 * @returns True pokud je stav validní
 */
export function validateState<T extends Record<string, unknown>>(state: GameState<T>): boolean {
    if (!state) return false;

    // Kontrola základní struktury
    if (!state.variables || typeof state.variables !== 'object') {
        return false;
    }

    // Kontrola visitedScenes
    if (!state.visitedScenes) {
        return false;
    }

    // Pro jistotu zajistíme, že visitedScenes je Set
    if (!(state.visitedScenes instanceof Set)) {
        try {
            // Pokus o konverzi, pokud to není Set (např. po deserializaci)
            if (Array.isArray(state.visitedScenes)) {
                state.visitedScenes = new Set(state.visitedScenes);
            } else {
                return false;
            }
        } catch (e) {
            return false;
        }
    }

    return true;
}

/**
 * Vytvoří migrační funkci pro přejmenování proměnné
 * @param variableName Původní název proměnné
 * @param newVariableName Nový název proměnné
 * @returns Migrační funkce
 */
export function createVariableRenameMigration(
    variableName: string,
    newVariableName: string
): StateMigrationFn {
    return (state, fromVersion, toVersion) => {
        if (state.variables && variableName in state.variables) {
            const newState = { ...state };
            newState.variables = { ...state.variables };
            newState.variables[newVariableName] = newState.variables[variableName];
            delete newState.variables[variableName];

            console.log(`Migrated variable '${variableName}' to '${newVariableName}'`);
            return newState;
        }
        return state;
    };
}

/**
 * Vytvoří migrační funkci pro změnu struktury proměnné
 * @param variableName Název proměnné
 * @param transformFn Funkce pro transformaci hodnoty
 * @returns Migrační funkce
 */
export function createVariableTransformMigration<T, U>(
    variableName: string,
    transformFn: (oldValue: T) => U
): StateMigrationFn {
    return (state, fromVersion, toVersion) => {
        if (state.variables && variableName in state.variables) {
            const newState = { ...state };
            newState.variables = { ...state.variables };
            newState.variables[variableName] = transformFn(newState.variables[variableName] as T);

            console.log(`Transformed variable '${variableName}' during migration from v${fromVersion} to v${toVersion}`);
            return newState;
        }
        return state;
    };
}

/**
 * Kombinuje více migračních funkcí do jedné
 * @param migrations Pole migračních funkcí
 * @returns Kombinovaná migrační funkce
 */
export function combineMigrations(...migrations: StateMigrationFn[]): StateMigrationFn {
    return (state, fromVersion, toVersion) => {
        return migrations.reduce((currentState, migration) => {
            return migration(currentState, fromVersion, toVersion);
        }, state);
    };
}

/**
 * Vytvoří migrační funkci pro přidání nové proměnné s výchozí hodnotou
 * @param variableName Název nové proměnné
 * @param defaultValue Výchozí hodnota
 * @returns Migrační funkce
 */
export function createAddVariableMigration<T>(
    variableName: string,
    defaultValue: T
): StateMigrationFn {
    return (state, fromVersion, toVersion) => {
        if (state.variables && !(variableName in state.variables)) {
            const newState = { ...state };
            newState.variables = { ...state.variables };
            newState.variables[variableName] = defaultValue;

            console.log(`Added new variable '${variableName}' during migration from v${fromVersion} to v${toVersion}`);
            return newState;
        }
        return state;
    };
}

/**
 * Vytvoří migrační funkci pro změnu struktury celého stavu
 * @param transformFn Funkce pro transformaci celého stavu
 * @returns Migrační funkce
 */
export function createStateMigration(
    transformFn: (state: PersistedState<unknown>) => PersistedState<unknown>
): StateMigrationFn {
    return (state, fromVersion, toVersion) => {
        try {
            const newState = transformFn(state);
            console.log(`Applied custom state transformation during migration from v${fromVersion} to v${toVersion}`);
            return newState;
        } catch (error) {
            console.error('Error during state migration:', error);
            return state;
        }
    };
}
</file>

<file path="src/utils/immer.ts">
/**
 * Reexport funkcionality z immer pro použití v aplikaci
 * Centralizuje konfiguraci a poskytuje konzistentní API
 */
import { enableMapSet, enablePatches } from 'immer';

// Aktivace podpory pro Map a Set v immer
enableMapSet();

// Aktivace podpory pro patches (příplaty)
enablePatches();

// Reexport hlavních funkcí
export { produce, current, createDraft, finishDraft } from 'immer';
</file>

<file path="src/utils/index.ts">
// Reexport utilit pro immer
export * from './immer';

// Reexport utilit pro UUID
export * from './uuid';

// Reexport utilit pro práci s objekty
export * from './object';

// Reexport utilities pro vytvoření enginu
export * from '../engine/utils';

// Reexport utility pro SaveManager
export * from '../save/utils';
</file>

<file path="src/utils/object.ts">
/**
 * Hluboká kopie objektu
 *
 * @param obj Objekt ke kopírování
 * @returns Hluboká kopie objektu
 */
export function deepClone<T>(obj: T): T {
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }

    // Převede Set na Array pro klonování a zpět
    if (obj instanceof Set) {
        return new Set(Array.from(obj).map(item => deepClone(item))) as any;
    }

    // Převede Map na Array pro klonování a zpět
    if (obj instanceof Map) {
        return new Map(
            Array.from(obj.entries()).map(([key, value]) => [
                deepClone(key),
                deepClone(value)
            ])
        ) as any;
    }

    // Zpracování Date
    if (obj instanceof Date) {
        return new Date(obj.getTime()) as any;
    }

    // Zpracování RegExp
    if (obj instanceof RegExp) {
        return new RegExp(obj.source, obj.flags) as any;
    }

    // Zpracování Array
    if (Array.isArray(obj)) {
        return obj.map(item => deepClone(item)) as any;
    }

    // Zpracování obyčejného Object
    const clonedObj = {} as T;
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            clonedObj[key] = deepClone(obj[key]);
        }
    }

    return clonedObj;
}

/**
 * Hluboké porovnání dvou objektů
 *
 * @param obj1 První objekt
 * @param obj2 Druhý objekt
 * @returns True pokud jsou objekty hluboce rovny
 */
export function deepEqual(obj1: any, obj2: any): boolean {
    // Kontrola primitivních typů a null/undefined
    if (obj1 === obj2) {
        return true;
    }

    // Kontrola, že oba objekty jsou objekty
    if (typeof obj1 !== 'object' || obj1 === null ||
        typeof obj2 !== 'object' || obj2 === null) {
        return false;
    }

    // Speciální ošetření pro Date
    if (obj1 instanceof Date && obj2 instanceof Date) {
        return obj1.getTime() === obj2.getTime();
    }

    // Speciální ošetření pro RegExp
    if (obj1 instanceof RegExp && obj2 instanceof RegExp) {
        return obj1.toString() === obj2.toString();
    }

    // Speciální ošetření pro Set
    if (obj1 instanceof Set && obj2 instanceof Set) {
        if (obj1.size !== obj2.size) return false;
        for (const item of obj1) {
            let found = false;
            for (const item2 of obj2) {
                if (deepEqual(item, item2)) {
                    found = true;
                    break;
                }
            }
            if (!found) return false;
        }
        return true;
    }

    // Speciální ošetření pro Map
    if (obj1 instanceof Map && obj2 instanceof Map) {
        if (obj1.size !== obj2.size) return false;
        for (const [key, val1] of obj1.entries()) {
            let found = false;
            for (const [key2, val2] of obj2.entries()) {
                if (deepEqual(key, key2) && deepEqual(val1, val2)) {
                    found = true;
                    break;
                }
            }
            if (!found) return false;
        }
        return true;
    }

    // Kontrola, že mají stejný konstruktor (jsou stejného typu)
    if (obj1.constructor !== obj2.constructor) {
        return false;
    }

    // Pro pole kontrolujeme délku a každý prvek
    if (Array.isArray(obj1)) {
        if (obj1.length !== obj2.length) {
            return false;
        }
        for (let i = 0; i < obj1.length; i++) {
            if (!deepEqual(obj1[i], obj2[i])) {
                return false;
            }
        }
        return true;
    }

    // Pro objekty kontrolujeme klíče a hodnoty
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);

    if (keys1.length !== keys2.length) {
        return false;
    }

    for (const key of keys1) {
        if (!Object.prototype.hasOwnProperty.call(obj2, key)) {
            return false;
        }
        if (!deepEqual(obj1[key], obj2[key])) {
            return false;
        }
    }

    return true;
}

/**
 * Bezpečné získání hodnoty z objektu pomocí cesty (dot notation)
 *
 * @param obj Objekt
 * @param path Cesta k vlastnosti (např. 'user.address.street')
 * @param defaultValue Výchozí hodnota, pokud vlastnost neexistuje
 * @returns Hodnota vlastnosti nebo defaultValue
 */
export function getPath<T = any>(obj: any, path: string, defaultValue?: T): T | undefined {
    if (!obj || !path) return defaultValue;

    const keys = path.split('.');
    let result = obj;

    for (const key of keys) {
        if (result === null || result === undefined || typeof result !== 'object') {
            return defaultValue;
        }
        result = result[key];
    }

    return (result === undefined) ? defaultValue : result as T;
}

/**
 * Bezpečné nastavení hodnoty v objektu pomocí cesty (dot notation)
 *
 * @param obj Objekt
 * @param path Cesta k vlastnosti (např. 'user.address.street')
 * @param value Hodnota k nastavení
 * @returns Modifikovaný objekt
 */
export function setPath<T>(obj: T, path: string, value: any): T {
    if (!obj || !path) return obj;

    const keys = path.split('.');
    let current: any = obj;

    for (let i = 0; i < keys.length - 1; i++) {
        const key = keys[i];

        // Vytvoříme nové zanořené objekty, pokud neexistují
        if (current[key] === undefined || current[key] === null || typeof current[key] !== 'object') {
            current[key] = {};
        }

        current = current[key];
    }

    // Nastavíme hodnotu na poslední úrovni
    const lastKey = keys[keys.length - 1];
    current[lastKey] = value;

    return obj;
}
</file>

<file path="src/utils/uuid.ts">
/**
 * Generuje jedinečný identifikátor (UUID v4)
 *
 * @returns Jedinečný identifikátor
 */
export function generateUUID(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
        const r = (Math.random() * 16) | 0;
        const v = c === 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
}

/**
 * Generuje krátký identifikátor (8 znaků)
 *
 * @param prefix Volitelný prefix pro ID
 * @returns Krátký jedinečný identifikátor
 */
export function generateShortId(prefix?: string): string {
    const randomPart = Math.random().toString(36).substring(2, 8);
    return prefix ? `${prefix}_${randomPart}` : randomPart;
}

/**
 * Kontroluje, zda řetězec je validní UUID
 *
 * @param id Řetězec k kontrole
 * @returns True pokud je validní UUID
 */
export function isValidUUID(id: string): boolean {
    const pattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    return pattern.test(id);
}
</file>

<file path="src/index.ts">
export * from './event';

export { GameEngine, createGameEngine, createSimpleGameEngine, createDebugGameEngine, preloadAllScenes } from './engine';
export { GameEngineOptions, GameEngineEvents } from './engine/types';

export * from './scene';
export * from './state';
export * from './content';
export * from './effect';
export * from './plugin';
export * from './save';
export * from './utils';
</file>

<file path="test/integration/GameEngine.integration.test.ts">
import { GameEngine } from '../../src/core/GameEngine';
import { Scene, Choice, GameState } from '../../src/types';
import { defineScene, defineScenes, createSceneLoader } from '../../src/utils/defineContent';

describe('GameEngine Integration', () => {
    let engine: GameEngine;

    // Definujeme testovací scény pomocí nového API
    const forestIntroScene = defineScene({
        title: 'Vstup do lesa',
        content: 'Stojíš na okraji hlubokého lesa.',
        choices: [
            {
                content: 'Prozkoumat les',
                scene: 'forest/clearing'
            },
            {
                content: 'Jít do vesnice',
                scene: 'village/square',
                // Podmínka pro dostupnost volby
                condition: (state: GameState) => state.variables.hasMap === true
            }
        ]
    });

    const forestClearingScene = defineScene({
        title: 'Lesní mýtina',
        content: 'Nacházíš se na malé mýtině uprostřed lesa.',
        choices: [
            {
                content: 'Prohledat mýtinu',
                // Bez scene property - pouze efekt
                effects: [
                    { type: 'SET_VARIABLE', variable: 'hasMap', value: true }
                ]
            },
            {
                content: 'Vrátit se na okraj lesa',
                scene: 'forest/intro'
            }
        ],
        onEnter: jest.fn()
    });

    const villageSquareScene = defineScene({
        title: 'Vesnické náměstí',
        content: 'Stojíš na malém náměstí obklopeném dřevěnými domy.',
        choices: [
            {
                content: 'Vrátit se do lesa',
                scene: 'forest/intro'
            }
        ],
        onEnter: jest.fn()
    });

    beforeEach(() => {
        // Resetujeme všechny mock funkce
        jest.clearAllMocks();

        // Definice scén pomocí nových helper funkcí
        const scenes = defineScenes({
            'forest/intro': forestIntroScene,
            'forest/clearing': forestClearingScene,
            'village/square': villageSquareScene
        });

        // Vytvoření loaderu pomocí nového helper
        const sceneLoader = createSceneLoader(scenes);

        // Vytvoření nové instance enginu s loaderem
        engine = new GameEngine({
            sceneLoader,
            initialState: {
                visitedScenes: new Set<string>(),
                variables: {
                    hasMap: false
                }
            }
        });
    });

    test('should handle game flow with new API', async () => {
        // Sledování událostí
        const eventSpy = jest.fn();
        engine.on('sceneChanged', eventSpy);

        // Start hry s klíčem scény místo ID
        await engine.start('forest/intro');
        expect(eventSpy).toHaveBeenCalledWith(expect.objectContaining({ title: 'Vstup do lesa' }));

        // Kontrola aktuální scény
        expect(engine.getCurrentScene()).toBeTruthy();
        expect(engine.getCurrentScene()?.title).toBe('Vstup do lesa');

        // Kontrola klíče scény - nově používáme getCurrentSceneKey
        expect(engine.getCurrentSceneKey()).toBe('forest/intro');

        // Zkontrolujeme dostupné volby - měla by být jen jedna
        let choices = engine.getAvailableChoices();
        expect(choices.length).toBe(1);
        expect(choices[0].content).toBe('Prozkoumat les');

        // Výběr volby pomocí indexu, ne ID
        await engine.selectChoice(0);
        expect(eventSpy).toHaveBeenCalledWith(expect.objectContaining({ title: 'Lesní mýtina' }));
        expect(forestClearingScene.onEnter).toHaveBeenCalled();

        // Prohledání mýtiny - volba bez přechodu, pouze s efektem
        await engine.selectChoice(0);
        expect(engine.getState().variables.hasMap).toBe(true);

        // Měli bychom zůstat na stejné scéně
        expect(engine.getCurrentSceneKey()).toBe('forest/clearing');

        // Vrátíme se zpět na okraj lesa
        await engine.selectChoice(1);
        expect(eventSpy).toHaveBeenCalledWith(expect.objectContaining({ title: 'Vstup do lesa' }));

        // Teď by měly být dostupné obě volby
        choices = engine.getAvailableChoices();
        expect(choices.length).toBe(2);

        // Kontrola obsahu voleb
        expect(choices[0].content).toBe('Prozkoumat les');
        expect(choices[1].content).toBe('Jít do vesnice');

        // Jdeme do vesnice, která byla dříve nedostupná
        await engine.selectChoice(1);
        expect(eventSpy).toHaveBeenCalledWith(expect.objectContaining({ title: 'Vesnické náměstí' }));
        expect(villageSquareScene.onEnter).toHaveBeenCalled();

        // Kontrola stavu
        const state = engine.getState();
        // Kontrola, že scény jsou sledovány podle klíče, ne ID
        expect(state.visitedScenes.size).toBe(3);
        expect(state.visitedScenes.has('forest/intro')).toBe(true);
        expect(state.visitedScenes.has('forest/clearing')).toBe(true);
        expect(state.visitedScenes.has('village/square')).toBe(true);
    });

    test('should handle choices without scene transition', async () => {
        await engine.start('forest/clearing');

        // Zaznamenáme počet volání sceneChanged
        const sceneChangedSpy = jest.fn();
        engine.on('sceneChanged', sceneChangedSpy);

        // Volíme možnost, která pouze mění stav bez přechodu
        await engine.selectChoice(0);

        // Kontrola, že stav byl změněn
        expect(engine.getState().variables.hasMap).toBe(true);

        // Kontrola, že žádný přechod scény nenastal
        expect(sceneChangedSpy).not.toHaveBeenCalled();
        expect(engine.getCurrentSceneKey()).toBe('forest/clearing');
    });

    test('should handle serialization and deserialization with new keys', async () => {
        await engine.start('forest/intro');
        await engine.selectChoice(0); // Jít do lesa
        await engine.selectChoice(0); // Prohledat mýtinu - nastavujeme hasMap na true

        // Serializujeme stav
        const serializedState = engine.getStateManager().serialize();

        // Vytvoříme novou instanci enginu
        const scenes = defineScenes({
            'forest/intro': forestIntroScene,
            'forest/clearing': forestClearingScene,
            'village/square': villageSquareScene
        });
        const newSceneLoader = createSceneLoader(scenes);
        const newEngine = new GameEngine({
            sceneLoader: newSceneLoader
        });

        // Nastavíme deserializovaný stav
        newEngine.getStateManager().deserialize(serializedState);

        // Zkontrolujeme, že stav byl správně obnoven
        const state = newEngine.getState();
        expect(state.variables.hasMap).toBe(true);
        expect(state.visitedScenes.has('forest/clearing')).toBe(true);

        // Měli bychom být schopni pokračovat ve hře
        await newEngine.start('forest/intro'); // Přejde do poslední známé scény

        // Nyní by měla být dostupná volba jít do vesnice
        const choices = newEngine.getAvailableChoices();
        expect(choices.length).toBe(2);
        expect(choices.some(c => c.content === 'Jít do vesnice')).toBe(true);
    });
});
</file>

<file path="test/unit/SaveManager.test.ts">
import { SaveManager } from '../../src/save/SaveManager';
import { GameEngine } from '../../src/core/GameEngine';
import { SaveStorage, SaveData, SaveMetadata } from '../../src/types/save';
import { Scene, GameState, SceneKey } from '../../src/types';
import { GenericContentLoader } from '../../src/loaders/GenericContentLoader';

// Mock pro SaveStorage
class MockSaveStorage implements SaveStorage {
    private storage: Record<string, SaveData> = {};

    public async save(id: string, data: SaveData): Promise<boolean> {
        this.storage[id] = { ...data };
        return true;
    }

    public async load(id: string): Promise<SaveData | null> {
        return this.storage[id] || null;
    }

    public async list(): Promise<Record<string, SaveMetadata>> {
        const result: Record<string, SaveMetadata> = {};
        for (const [id, data] of Object.entries(this.storage)) {
            result[id] = data.metadata;
        }
        return result;
    }

    public async delete(id: string): Promise<boolean> {
        if (id in this.storage) {
            delete this.storage[id];
            return true;
        }
        return false;
    }

    public async exists(id: string): Promise<boolean> {
        return id in this.storage;
    }

    // Pomocná metoda pro testy
    public getStorage(): Record<string, SaveData> {
        return { ...this.storage };
    }
}

describe('SaveManager', () => {
    let saveManager: SaveManager;
    let engine: GameEngine;
    let mockStorage: MockSaveStorage;
    let sceneLoader: GenericContentLoader<Scene>;

    // Definujeme testovací scény
    const startScene: Scene = {
        title: 'Start',
        content: 'This is the start scene',
        choices: [
            {
                content: 'Go to the forest',
                scene: 'forest'
            }
        ]
    };

    const forestScene: Scene = {
        title: 'Forest',
        content: 'You are in a forest',
        choices: [
            {
                content: 'Go back to start',
                scene: 'start'
            }
        ]
    };

    beforeEach(() => {
        // Vytvoření content loaderu se scénami
        sceneLoader = new GenericContentLoader<Scene>();
        sceneLoader.registerContent({
            'start': startScene,
            'forest': forestScene
        });

        // Vytvoření enginu
        engine = new GameEngine({
            sceneLoader
        });

        // Vytvoření mock úložiště
        mockStorage = new MockSaveStorage();

        // Vytvoření SaveManageru
        saveManager = new SaveManager(engine, {
            storage: mockStorage,
            engineVersion: '0.1.0'
        });
    });

    test('should save and load a game', async () => {
        // Spustíme hru a přejdeme do lesa
        await engine.start('start');
        await engine.selectChoice(0); // Go to the forest

        // Uložíme hru
        const saveId = 'test-save';
        const success = await saveManager.save(saveId, { name: 'Test Save' });
        expect(success).toBe(true);

        // Kontrola, že byla hra uložena
        const savedGames = await saveManager.getSaves();
        expect(Object.keys(savedGames)).toContain(saveId);
        expect(savedGames[saveId].name).toBe('Test Save');
        expect(savedGames[saveId].currentSceneKey).toBe('forest');

        // Přejdeme zpět na start
        await engine.selectChoice(0); // Go back to start
        expect(engine.getCurrentSceneKey()).toBe('start');

        // Načteme uloženou hru
        const loadSuccess = await saveManager.load(saveId);
        expect(loadSuccess).toBe(true);

        // Kontrola, že jsme zpět v lese
        expect(engine.getCurrentSceneKey()).toBe('forest');
    });

    test('should handle quickSave and quickLoad', async () => {
        // Spustíme hru
        await engine.start('start');

        // Provedeme rychlé uložení
        const success = await saveManager.quickSave();
        expect(success).toBe(true);

        // Zkontrolujeme, že quicksave existuje
        const saves = await saveManager.getSaves();
        expect('quicksave' in saves).toBe(true);

        // Přejdeme do lesa
        await engine.selectChoice(0);
        expect(engine.getCurrentSceneKey()).toBe('forest');

        // Načteme rychlé uložení
        const loadSuccess = await saveManager.quickLoad();
        expect(loadSuccess).toBe(true);

        // Zkontrolujeme, že jsme zpět na startu
        expect(engine.getCurrentSceneKey()).toBe('start');
    });

    test('should handle save deletion', async () => {
        // Spustíme hru
        await engine.start('start');

        // Uložíme hru
        const saveId = 'delete-test';
        await saveManager.save(saveId);

        // Zkontrolujeme, že uložení existuje
        expect(await mockStorage.exists(saveId)).toBe(true);

        // Smažeme uložení
        const deleteSuccess = await saveManager.deleteSave(saveId);
        expect(deleteSuccess).toBe(true);

        // Zkontrolujeme, že uložení bylo smazáno
        expect(await mockStorage.exists(saveId)).toBe(false);
    });

    test('should track play time', async () => {
        // Spustíme hru
        await engine.start('start');

        // Počkáme 100ms
        await new Promise(resolve => setTimeout(resolve, 100));

        // Uložíme hru
        const saveId = 'playtime-test';
        await saveManager.save(saveId);

        // Načteme metadata uložené hry
        const saves = await saveManager.getSaves();
        const metadata = saves[saveId];

        // Zkontrolujeme, že čas hraní byl zaznamenán
        expect(metadata.playTime).toBeGreaterThan(0);

        // Zkontrolujeme, že formátování času funguje
        const formattedTime = saveManager.formatPlayTime(metadata.playTime);
        expect(formattedTime).toMatch(/^\d{2}:\d{2}:\d{2}$/);
    });

    // Další testy podle potřeby...
});
</file>

<file path=".prettierignore">
node_modules
dist
coverage
*.md
*.json
</file>

<file path=".prettierrc.js">
module.exports = {
  singleQuote: true,
  trailingComma: 'es5',
  printWidth: 100,
  tabWidth: 2,
  semi: true,
  bracketSpacing: true,
  arrowParens: 'avoid',
  endOfLine: 'lf',
};
</file>

<file path="eslint.config.mjs">
// eslint.config.mjs
import eslintJs from '@eslint/js';
import tseslint from '@typescript-eslint/eslint-plugin';
import tsparser from '@typescript-eslint/parser';
import prettierPlugin from 'eslint-plugin-prettier';

export default [
  eslintJs.configs.recommended,
  {
    ignores: [
      'node_modules/**',
      'dist/**',
      'coverage/**',
      'rollup.config.js',
      'jest.config.js'
    ]
  },
  {
    files: ['**/*.ts'],
    languageOptions: {
      parser: tsparser,
      ecmaVersion: 2020,
      sourceType: 'module',
      globals: {
        // Přidáno pro vyřešení 'console is not defined'
        console: 'readonly',
        // Další globální proměnné, které mohou být potřeba
        process: 'readonly',
        setTimeout: 'readonly',
        clearTimeout: 'readonly',
        Set: 'readonly',
        Map: 'readonly',
        Promise: 'readonly'
      }
    },
    plugins: {
      '@typescript-eslint': tseslint,
      'prettier': prettierPlugin
    },
    rules: {
      'prettier/prettier': 'error',
      'no-console': ['warn', { allow: ['warn', 'error'] }],
      'no-unused-vars': 'off'
    }
  }
];
</file>

<file path="jest.config.js">
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ['**/test/**/*.test.ts'],
  collectCoverage: true,
  coverageDirectory: 'coverage',
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.d.ts',
    '!src/**/index.ts',
    '!src/types/**/*.ts'
  ],
  transform: {
    '^.+\\.tsx?$': [
      'ts-jest',
      {
        tsconfig: 'tsconfig.json',
      },
    ],
  },
};
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Jakub Hájek

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="package.json">
{
  "name": "@pabitel/core",
  "version": "0.1.0",
  "description": "A minimalist framework for building text-based games and interactive narratives",
  "license": "MIT",
  "main": "dist/index.js",
  "module": "dist/index.esm.js",
  "types": "dist/index.d.ts",
  "files": [
    "dist"
  ],
  "exports": {
    ".": {
      "import": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.esm.js"
      },
      "require": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.js"
      },
      "development": "./src/index.ts"
    },
    "./package.json": "./package.json"
  },
  "scripts": {
    "build": "tsc && rollup -c",
    "dev": "tsc --watch",
    "test": "jest",
    "lint": "eslint src --ext .ts",
    "lint:fix": "eslint src --ext .ts --fix",
    "format": "prettier --write \"src/**/*.ts\"",
    "format:check": "prettier --check \"src/**/*.ts\"",
    "prepublishOnly": "npm run lint && npm run test && npm run build"
  },
  "devDependencies": {
    "@eslint/js": "^9.23.0",
    "@rollup/plugin-commonjs": "^28.0.3",
    "@rollup/plugin-node-resolve": "^16.0.1",
    "@types/jest": "^29.5.14",
    "@types/lodash": "^4.17.16",
    "@types/uuid": "^10.0.0",
    "@typescript-eslint/eslint-plugin": "^8.29.0",
    "@typescript-eslint/parser": "^8.29.0",
    "eslint": "^9",
    "eslint-config-prettier": "^10",
    "eslint-plugin-prettier": "^5",
    "jest": "^29.7.0",
    "prettier": "^3",
    "rollup": "^4",
    "rollup-plugin-typescript2": "^0.36.0",
    "ts-jest": "^29.3.1",
    "typescript": "^5.8.2"
  },
  "author": "Jakub Hájek",
  "repository": {
    "type": "git",
    "url": "https://github.com/jimmyhayek/textgame.git"
  },
  "keywords": [
    "text-game",
    "interactive-fiction",
    "game-engine",
    "narrative",
    "text-adventure"
  ],
  "dependencies": {
    "immer": "^10.1.1",
    "lodash": "^4.17.21",
    "uuid": "^11.1.0"
  }
}
</file>

<file path="README.md">
# @pabitel/core

Core engine pro vytváření modulárních, flexibilních a příběhově zaměřených textových her.

## Přehled

Pabitel Core je minimalistický, ale výkonný framework navržený pro tvorbu interaktivních narativů, textových adventur a her založených na volbách. S důrazem na modularitu a typovou bezpečnost poskytuje základní stavební bloky potřebné k vytváření komplexních příběhových zážitků, aniž by diktoval, jak strukturovat obsah vaší hry.

## Klíčové vlastnosti

- **Minimalistické jádro** - Malé, cílené API obsahující pouze nezbytné součásti
- **Modulární design** - Používejte pouze to, co potřebujete, rozšiřujte pomocí pluginů
- **Typová bezpečnost** - Vytvořeno v TypeScriptu pro robustní vývoj
- **Deklarativní obsah** - Definujte herní obsah jednoduchým, deklarativním způsobem
- **Lazy loading** - Načítejte obsah na vyžádání pro optimální výkon
- **Flexibilní struktura** - Organizujte herní obsah jakýmkoliv způsobem
- **Systém pluginů** - Snadno rozšiřujte engine o vlastní funkcionalitu

## Instalace

```bash
# Pomocí yarn
yarn add @pabitel/core

# Pomocí npm
npm install @pabitel/core
```

## Základní použití

Zde je jednoduchý příklad, který ukazuje, jak vytvořit základní hru:

```typescript
import { createGameEngine, defineScene, defineScenes, createSceneLoader } from '@pabitel/core';

// Definice scén
const startScene = defineScene({
    title: 'Začátek',
    content: 'Probudíš se v malé místnosti. Na severu jsou dveře a na východě okno.',
    choices: [
        {
            content: 'Projít dveřmi',
            scene: 'corridor'
        },
        {
            content: 'Podívat se z okna',
            scene: 'window-view'
        }
    ]
});

const corridorScene = defineScene({
    title: 'Temná chodba',
    content: 'Vstoupíš do dlouhé, temné chodby.',
    choices: [
        {
            content: 'Vrátit se do místnosti',
            scene: 'start'
        }
    ]
});

const windowViewScene = defineScene({
    title: 'Pohled z okna',
    content: 'Z okna vidíš krásnou krajinu.',
    choices: [
        {
            content: 'Odstoupit od okna',
            scene: 'start'
        }
    ]
});

// Registrace scén
const scenes = defineScenes({
    'start': startScene,
    'corridor': corridorScene,
    'window-view': windowViewScene
});

// Vytvoření herního enginu
const sceneLoader = createSceneLoader(scenes);
const engine = createGameEngine({
    sceneLoader
});

// Spuštění hry
engine.start('start').then(() => {
    console.log('Hra začala ve scéně:', engine.getCurrentScene()?.title);
    console.log(engine.getCurrentScene()?.content);
    console.log('Dostupné volby:');
    engine.getAvailableChoices().forEach((choice, index) => {
        console.log(`${index}. ${choice.content}`);
    });
});
```

## Základní koncepty

### Scény a volby

Základními stavebními bloky každé hry vytvořené s Pabitel Core jsou scény a volby. Scéna představuje jednu "stránku" nebo "obrazovku" vaší hry, zatímco volby jsou možnosti dostupné hráči.

```typescript
interface Scene {
  title: string;
  content: string | ((state: GameState) => string);
  choices: Choice[];
  onEnter?: (state: GameState, engine: GameEngine) => void;
  onExit?: (state: GameState, engine: GameEngine) => void;
  metadata?: Record<string, any>;
}

interface Choice {
  content: string | ((state: GameState) => string);
  scene?: SceneKey | ((state: GameState) => SceneKey);
  condition?: (state: GameState) => boolean;
  effects?: Effect[];
  metadata?: Record<string, any>;
}
```

### Content Loadery a klíče

Pabitel Core používá systém klíčů založený na cestách pro identifikaci obsahu, podobně jako funguje routování založené na souborech v moderních webových frameworcích. To umožňuje intuitivní organizaci herního obsahu:

```typescript
// Scény jsou identifikovány svými klíči, které mohou být podobné cestám
const scenes = defineScenes({
  'forest/entrance': entranceScene,
  'forest/clearing': clearingScene,
  'village/square': squareScene
});
```

### Herní stav

Herní stav sleduje vše, co se děje ve vaší hře, včetně proměnných, navštívených scén a jakýchkoli dalších dat, která chcete sledovat.

```typescript
interface GameState {
  visitedScenes: Set<string>;
  variables: Record<string, any>;
  [key: string]: any;
}
```

### Efekty

Efekty jsou akce, které mění herní stav. Mohou být spuštěny volbami, scénami nebo jinými herními událostmi.

```typescript
// Definice volby s efekty
{
  content: 'Vzít meč',
  scene: 'cave/entrance',
  effects: [
    { 
      type: 'SET_VARIABLE', 
      variable: 'hasSword', 
      value: true 
    },
    { 
      type: 'INCREMENT_VARIABLE', 
      variable: 'inventory_count', 
      value: 1 
    }
  ]
}
```

### Volby bez přechodů mezi scénami

Volby nemusí vždy vést k nové scéně. Můžete vytvořit volby, které pouze aplikují efekty a zůstanou na aktuální scéně:

```typescript
const forestScene = defineScene({
  title: 'Les',
  content: 'Jsi v hustém lese...',
  choices: [
    {
      content: 'Prohledat okolí',
      // Bez vlastnosti scene - pouze efekty
      effects: [
        { type: 'SET_VARIABLE', variable: 'foundMap', value: true }
      ]
    },
    {
      content: 'Pokračovat hlouběji',
      scene: 'forest/clearing'
    }
  ]
});
```

### Pluginy

Systém pluginů umožňuje rozšířit engine o vlastní funkcionalitu. Pluginy mohou přidávat nové typy obsahu, efekty nebo jiné funkce.

```typescript
import { AbstractPlugin } from '@pabitel/core';

// Vytvoření vlastního pluginu
class InventoryPlugin extends AbstractPlugin {
    constructor() {
        super('inventory', {});
    }

    protected override setupLoaders() {
        // Nastavení content loaderů pro předměty
        const itemLoader = new GenericContentLoader();
        this.loaders.set('items', itemLoader);
    }

    protected override registerEffectProcessors() {
        this.engine?.registerEffectProcessor('ADD_ITEM', (effect, state) => {
            if (!state.inventory) {
                state.inventory = [];
            }
            state.inventory.push(effect.item);
        });
    }
}

// Použití pluginu
const inventoryPlugin = new InventoryPlugin();
const engine = createGameEngine({
    sceneLoader,
    plugins: [inventoryPlugin]
});
```

## Dostupné pluginy

Framework obsahuje několik oficiálních pluginů pro rozšíření základní funkcionality:

### @pabitel/plugin-choices

Plugin pro správu voleb, který poskytuje bohatší možnosti interakce ve hře.

```typescript
import { ChoicesPlugin } from '@pabitel/plugin-choices';

const choicesPlugin = new ChoicesPlugin();
engine.registerPlugin(choicesPlugin);
```

### @pabitel/plugin-commands

Plugin pro implementaci textových příkazů, který umožňuje hráčům zadávat příkazy podobně jako v klasických textových adventurách.

```typescript
import { CommandPlugin } from '@pabitel/plugin-commands';

const commandPlugin = new CommandPlugin();
engine.registerPlugin(commandPlugin);
```

### @pabitel/plugin-local-storage

Plugin pro ukládání herního stavu do localStorage prohlížeče.

```typescript
import { LocalStorageSaveStorage } from '@pabitel/plugin-local-storage';

const saveStorage = new LocalStorageSaveStorage();
const saveManager = createSaveManager(engine, { storage: saveStorage });
```

## Pokročilé použití

Pabitel Core obsahuje další pokročilé funkce a možnosti:

### Správa stavu

Framework poskytuje pokročilé možnosti správy stavu:

```typescript
// Získání proměnné ze stavu
const hasMap = engine.getStateManager().getVariable('hasMap', false);

// Nastavení proměnné ve stavu
engine.getStateManager().setVariable('hasMap', true);

// Aktualizace celého stavu
engine.getStateManager().updateState(state => {
  state.variables.health -= 10;
  state.variables.visitedPlaces.push('forest');
});
```

### Systém událostí

Můžete reagovat na různé události v enginu:

```typescript
// Naslouchání na změnu scény
engine.on('sceneChanged', data => {
  console.log('Přechod na novou scénu:', data.sceneKey);
});

// Naslouchání na změnu stavu
engine.on('stateChanged', state => {
  updateUI(state);
});

// Naslouchání na události pluginu
engine.on('choices:choiceSelected', data => {
  playSound('click');
});
```

### Ukládání a načítání her

Framework obsahuje vestavěný systém pro ukládání a načítání her:

```typescript
// Uložení hry
await engine.saveGame('save_slot_1', { name: 'Uložení hry v lese' });

// Načtení hry
await engine.loadGame('save_slot_1');

// Rychlé uložení/načtení
await engine.getSaveManager().quickSave();
await engine.getSaveManager().quickLoad();
```

### Entitní systém

Pro složitější hry můžete využít entitní systém:

```typescript
// Vytvoření entity
const playerEntity = engine.getEntityManager().createEntity('player', {
  name: 'Hráč',
  health: 100,
  inventory: []
});

// Získání entity
const player = engine.getEntityManager().getEntity('player');

// Aktualizace entity
engine.getEntityManager().updateEntity('player', entity => {
  entity.health -= 10;
});
```

## Licence

MIT © Jakub Hájek
</file>

<file path="rollup.config.js">
import typescript from 'rollup-plugin-typescript2';
import { nodeResolve } from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import pkg from './package.json';

export default [
  {
    input: 'src/index.ts',
    output: {
      file: pkg.module,
      format: 'esm',
      sourcemap: true
    },
    plugins: [
      typescript({
        tsconfig: './tsconfig.json',
        useTsconfigDeclarationDir: true
      }),
      nodeResolve(),
      commonjs()
    ],
    external: [...Object.keys(pkg.dependencies || {}), ...Object.keys(pkg.peerDependencies || {})]
  },
  {
    input: 'src/index.ts',
    output: {
      file: pkg.main,
      format: 'cjs',
      sourcemap: true
    },
    plugins: [
      typescript({
        tsconfig: './tsconfig.json',
        useTsconfigDeclarationDir: true
      }),
      nodeResolve(),
      commonjs()
    ],
    external: [...Object.keys(pkg.dependencies || {}), ...Object.keys(pkg.peerDependencies || {})]
  }
];
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "declaration": true,
    "declarationDir": "./dist",
    "outDir": "./dist",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "test", "examples"]
}
</file>

</files>
