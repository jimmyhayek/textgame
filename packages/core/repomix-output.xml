This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
src/
  content/
    GenericContentLoader.ts
    index.ts
    LoaderRegistry.ts
    types.ts
    utils.ts
  effect/
    EffectManager.ts
    index.ts
    processors.ts
    types.ts
    utils.ts
  engine/
    GameEngine.ts
    index.ts
    types.ts
    utils.ts
  event/
    EventEmitter.ts
    index.ts
    TypedEventEmitter.ts
    types.ts
    utils.ts
  plugin/
    AbstractPlugin.ts
    index.ts
    PluginManager.ts
    types.ts
    utils.ts
  save/
    index.ts
    MemoryStorage.ts
    SaveManager.ts
    types.ts
    utils.ts
  scene/
    index.ts
    SceneManager.ts
    types.ts
    utils.ts
  state/
    persistence/
      index.ts
      StateConverter.ts
      StateMigrationService.ts
      types.ts
      utils.ts
    GameStateManager.ts
    index.ts
    types.ts
    utils.ts
  utils/
    immer.ts
    index.ts
    object.ts
    uuid.ts
  index.ts
.prettierignore
.prettierrc.js
eslint.config.mjs
jest.config.js
LICENSE
package.json
rollup.config.js
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/content/GenericContentLoader.ts">
import { produce } from '../utils/immer';

/**
 * Interface pro definování content registry s lazy-loading podporou
 * @template T Typ načítaného obsahu
 * @template K Typ identifikátoru obsahu (obvykle string)
 */
export interface ContentRegistry<T, K extends string = string> {
    [key: string]: T | (() => Promise<T | { default: T }>);
}

/**
 * Konfigurační možnosti pro content loader
 * @template T Typ načítaného obsahu
 * @template K Typ identifikátoru obsahu (obvykle string)
 */
export interface ContentLoaderOptions<T extends object, K extends string = string> {
    /** Počáteční registry obsahu */
    initialRegistry?: ContentRegistry<T, K>;
}

/**
 * Generický loader pro herní obsah s podporou lazy-loadingu
 * @template T Typ načítaného obsahu
 * @template K Typ identifikátoru obsahu (obvykle string)
 */
export class GenericContentLoader<T extends object, K extends string = string> {
    /** Cache načteného obsahu */
    private loadedContent: Map<string, T> = new Map();

    /** Promise pro obsah, který se právě načítá */
    private loadingPromises: Map<string, Promise<T>> = new Map();

    /** Registry definic obsahu s podporou lazy-loadingu */
    private registry: ContentRegistry<T, K> = {} as ContentRegistry<T, K>;

    /**
     * Vytvoří nový content loader
     * @param options Konfigurační možnosti loaderu
     */
    constructor(options: ContentLoaderOptions<T, K> = {}) {
        const { initialRegistry = {} as ContentRegistry<T, K> } = options;
        this.registry = { ...initialRegistry };
    }

    /**
     * Registruje definice obsahu do loaderu
     * @param registry Registry s definicemi nebo funkcemi pro lazy-loading
     */
    public registerContent(registry: ContentRegistry<T, K>): void {
        this.registry = produce(this.registry, (draft) => {
            Object.assign(draft, registry);
        });
    }

    /**
     * Registruje všechen obsah z registry
     * @param registry Registry s definicemi nebo funkcemi pro lazy-loading
     */
    public registerAll(registry: ContentRegistry<T, K>): void {
        this.registerContent(registry);
    }

    /**
     * Načte obsah podle klíče, podporuje jak okamžitý, tak lazy-loaded obsah
     * @param key Klíč obsahu
     * @returns Promise, který se vyřeší načteným obsahem
     * @throws Error pokud obsah s daným klíčem není v registry
     */
    public async loadContent(key: string): Promise<T> {
        // Vrátit z cache, pokud již je načten
        if (this.loadedContent.has(key)) {
            return this.loadedContent.get(key)!;
        }

        // Vrátit existující promise, pokud se již načítá
        if (this.loadingPromises.has(key)) {
            return this.loadingPromises.get(key)!;
        }

        const contentDefOrImport = this.registry[key];

        if (!contentDefOrImport) {
            throw new Error(`Content with key "${key}" not found in registry`);
        }

        let loadPromise: Promise<T>;

        if (typeof contentDefOrImport === 'function') {
            // Zpracování lazy-loaded obsahu
            const loadFunction = contentDefOrImport as () => Promise<T | { default: T }>;
            loadPromise = loadFunction().then((module): T => {
                // Kontrola, zda máme default export (ES module) nebo přímý obsah
                const content = this.isModuleWithDefault(module) ? module.default : module;

                // Přidáme _key do načteného obsahu
                const enhancedContent = typeof content === 'object' && content !== null
                    ? { ...content, _key: key }
                    : content;

                this.loadedContent.set(key, enhancedContent);
                // Odstraníme promise z loadingPromises po úspěšném načtení
                this.loadingPromises.delete(key);
                return enhancedContent;
            }).catch(error => {
                // Odstraníme promise z loadingPromises i v případě chyby
                this.loadingPromises.delete(key);
                console.error(`Failed to load content for key "${key}":`, error);
                // Znovu vyhodíme chybu, aby ji mohl zachytit volající (např. preloadContent)
                throw error;
            });
        } else {
            // Zpracování přímého obsahu
            const content = typeof contentDefOrImport === 'object' && contentDefOrImport !== null
                ? { ...contentDefOrImport, _key: key }
                : contentDefOrImport;

            loadPromise = Promise.resolve(content);
            this.loadedContent.set(key, content);
        }

        // Uložíme promise POUZE pokud se jedná o skutečné načítání (lazy-load)
        if (typeof contentDefOrImport === 'function') {
            this.loadingPromises.set(key, loadPromise);
        }

        return loadPromise;
    }

    /**
     * Kontroluje, zda obsah s daným klíčem existuje v registry
     * @param key Klíč obsahu
     * @returns True pokud obsah existuje, false jinak
     */
    public hasContent(key: string): boolean {
        return key in this.registry;
    }

    /**
     * Získá všechny klíče obsahu registrované v loaderu
     * @returns Pole klíčů obsahu
     */
    public getContentKeys(): string[] {
        return Object.keys(this.registry);
    }

    /**
     * Předem načte obsah podle klíčů.
     * Pokud klíč odkazuje na již načtený obsah, nic se neděje.
     * Pokud klíč odkazuje na lazy-loaded obsah, spustí jeho načítání.
     *
     * @param keys Volitelné pole klíčů obsahu k načtení. Pokud není uvedeno,
     *             pokusí se načíst veškerý *lazy-loaded* obsah registrovaný v loaderu.
     * @returns Promise, který se vyřeší, když jsou všechny požadované položky načteny (nebo jejich načítání selhalo).
     *          Promise bude *rejected*, pokud načtení *alespoň jedné* položky selže.
     * @throws Error pokud načtení některé z položek selže.
     */
    public async preloadContent(keys?: string[]): Promise<void> {
        let keysToLoad: string[];

        if (keys) {
            // Pokud jsou klíče specifikovány, filtrujeme jen ty, které jsou v registry
            keysToLoad = keys.filter(key => this.hasContent(key));
        } else {
            // Pokud nejsou klíče specifikovány, vezmeme všechny klíče z registry,
            // které odpovídají lazy-loading funkcím a ještě nebyly načteny.
            keysToLoad = this.getContentKeys().filter(key =>
                typeof this.registry[key] === 'function' &&
                !this.loadedContent.has(key) &&
                !this.loadingPromises.has(key) // Nepokoušíme se znovu načítat, co se už načítá
            );
        }

        if (keysToLoad.length === 0) {
            // Není co načítat
            return Promise.resolve();
        }

        console.log(`Preloading content for keys: ${keysToLoad.join(', ')}`);

        // Vytvoříme pole promises voláním loadContent pro každý klíč.
        // loadContent() inteligentně použije cache nebo existující loading promises.
        const preloadPromises = keysToLoad.map(key => this.loadContent(key));

        // Použijeme Promise.all ke spuštění všech načítání paralelně.
        // Promise.all se rejectne, pokud jakýkoli z vnitřních promises selže.
        try {
            await Promise.all(preloadPromises);
            console.log(`Successfully preloaded content for keys: ${keysToLoad.join(', ')}`);
        } catch (error) {
            // Chyba byla již zalogována v loadContent, zde ji jen přepošleme dál
            console.error(`Error occurred during preloading content.`);
            throw error; // Umožní volajícímu zjistit, že preload selhal
        }
    }

    /**
     * Získá podkladový registry obsahu
     * @returns Aktuální registry obsahu
     */
    public getRegistry(): ContentRegistry<T, K> {
        return this.registry;
    }

    /**
     * Vyčistí cache načteného obsahu a běžících načítání.
     * Obsah bude znovu načten při příštím požadavku (loadContent nebo preloadContent).
     */
    public clearCache(): void {
        this.loadedContent.clear();
        this.loadingPromises.clear();
        console.log('Content loader cache cleared.');
    }

    /**
     * Type guard pro kontrolu, zda objekt má default export
     * @param obj Objekt ke kontrole
     * @returns True pokud objekt má default vlastnost typu T
     * @private
     */
    private isModuleWithDefault(obj: any): obj is { default: T } {
        // Přidána kontrola, zda obj není null, a zda 'default' existuje
        return obj && typeof obj === 'object' && true && 'default' in obj;
    }
}
</file>

<file path="src/content/index.ts">
// Export typů
export * from './types';

// Export hlavních tříd
export { GenericContentLoader } from './GenericContentLoader';
export { LoaderRegistry } from './LoaderRegistry';

// Export utilit
export {
    createContentLoader,
    defineContent,
    defineScenes,
    mergeContentRegistries,
    generateContentKey,
    extractContentKeys,
    mapContentRegistry
} from './utils';
</file>

<file path="src/content/LoaderRegistry.ts">
import { GenericContentLoader } from './GenericContentLoader';

/**
 * Registry for managing multiple content loaders
 * Provides a central point for registering and accessing loaders for different content types
 */
export class LoaderRegistry {
    /** Map of loaders organized by type */
    private loaders: Map<string, GenericContentLoader<any, any>> = new Map();

    /**
     * Registers a loader for a specific content type
     * @param type Content type identifier
     * @param loader Loader instance for the content type
     * @returns This registry instance for chaining
     */
    public registerLoader<T extends object, K extends string = string>(
        type: string,
        loader: GenericContentLoader<T, K>
    ): LoaderRegistry {
        this.loaders.set(type, loader);
        return this;
    }

    /**
     * Gets a loader for a specific content type
     * @template T Content type
     * @template K Content ID type
     * @param type Content type identifier
     * @returns Loader instance for the content type or undefined if not found
     */
    public getLoader<T extends object, K extends string = string>(
        type: string
    ): GenericContentLoader<T, K> | undefined {
        return this.loaders.get(type) as GenericContentLoader<T, K> | undefined;
    }

    /**
     * Checks if a loader for a specific content type exists
     * @param type Content type identifier
     * @returns True if loader exists, false otherwise
     */
    public hasLoader(type: string): boolean {
        return this.loaders.has(type);
    }

    /**
     * Gets all registered content types
     * @returns Array of content type identifiers
     */
    public getContentTypes(): string[] {
        return Array.from(this.loaders.keys());
    }

    /**
     * Removes a loader for a specific content type
     * @param type Content type identifier
     * @returns True if loader was removed, false if it didn't exist
     */
    public removeLoader(type: string): boolean {
        return this.loaders.delete(type);
    }
}
</file>

<file path="src/content/types.ts">
/**
 * Registry obsahu s podporou lazy-loadingu
 * @template T Typ obsahu (hodnoty v registru)
 * @template K Typ klíče obsahu
 */
export type ContentRegistry<T extends object, K extends string = string> = {
    [key: string]: T | (() => Promise<T | { default: T }>);
};

/**
 * Obecné rozhraní pro definici obsahu k registraci
 * @template T Typ HODNOTY v registru (např. Scene, Item)
 */
export interface ContentDefinition<T extends object> { // Přidáno omezení T extends object
    /** Identifikátor typu obsahu (např. 'scenes', 'items') */
    type: string;
    /** Registry obsahu pro daný typ */
    content: ContentRegistry<T>; // <--- Změna zde: content je nyní typu ContentRegistry<T>
}


/**
 * Funkce pro načtení obsahu podle ID
 * @template T Typ obsahu
 * @template ID Typ identifikátoru obsahu
 */
export type ContentLoader<T, ID = string> = (id: ID) => Promise<T>;

/**
 * Funkce pro kontrolu existence obsahu
 * @template ID Typ identifikátoru obsahu
 */
export type ContentChecker<ID = string> = (id: ID) => boolean;

/**
 * Možnosti pro vytvoření content loaderu
 * @template T Typ obsahu
 * @template K Typ klíče obsahu
 */
export interface ContentLoaderOptions<T extends object, K extends string = string> {
    /** Počáteční registry obsahu */
    initialRegistry?: ContentRegistry<T, K>;
}

/**
 * Událost načtení obsahu
 */
export interface ContentLoadedEvent<T> {
    /** Typ obsahu */
    type: string;
    /** Klíč obsahu */
    key: string;
    /** Načtený obsah */
    content: T;
}

/**
 * Událost registrace obsahu
 */
export interface ContentRegisteredEvent {
    /** Typ obsahu */
    type: string;
    /** Počet registrovaných položek */
    count: number;
    /** Klíče registrovaných položek */
    keys: string[];
}
</file>

<file path="src/content/utils.ts">
import { ContentRegistry, ContentDefinition } from './types';
import { Scene } from '../scene';
import { GenericContentLoader } from './GenericContentLoader';

/**
 * Vytvoří novou instanci content loaderu pro daný typ obsahu
 * @template T Typ obsahu
 * @template K Typ klíče obsahu
 * @param registry Volitelný počáteční registry obsahu
 * @returns Nová instance content loaderu
 */
export function createContentLoader<T extends object, K extends string = string>(
    registry?: ContentRegistry<T, K>
): GenericContentLoader<T, K> {
    return new GenericContentLoader<T, K>({
        initialRegistry: registry
    });
}

/**
 * Vytvoří definici obsahu pro registraci s engine
 * @template T Typ obsahu (hodnoty v registru)
 * @param type Identifikátor typu obsahu
 * @param contentRegistry Registry obsahu
 * @returns Definice obsahu připravená k registraci
 */
export function defineContent<T extends object>( // Omezení T extends object
    type: string,
    contentRegistry: ContentRegistry<T> // Přijímá přímo ContentRegistry<T>
): ContentDefinition<T> { // Vrací správný typ
    return { type, content: contentRegistry };
}

/**
 * Zjednodušená utilita pro definování registru scén.
 * Automaticky nastavuje typ obsahu na 'scenes'.
 * @param registry Objekt mapující klíče scén (string) na objekty Scene nebo funkce pro lazy-loading.
 * @returns Objekt ContentDefinition<Scene> připravený pro registraci v enginu.
 */
export function defineScenes(registry: ContentRegistry<Scene>): ContentDefinition<Scene> {
    // Interně volá generickou funkci defineContent s předvyplněným typem
    return defineContent<Scene>('scenes', registry);
}

/**
 * Spojí více registrů obsahu do jednoho
 * @template T Typ obsahu
 * @template K Typ klíče obsahu
 * @param registries Pole registrů obsahu
 * @returns Spojený registry obsahu
 */
export function mergeContentRegistries<T extends object, K extends string = string>(
    ...registries: ContentRegistry<T, K>[]
): ContentRegistry<T, K> {
    return Object.assign({}, ...registries);
}

/**
 * Generuje normalizovaný klíč obsahu
 * @param parts Části klíče, které budou spojeny lomítkem
 * @returns Normalizovaný klíč obsahu
 */
export function generateContentKey(...parts: string[]): string {
    // Odstranění prázdných částí
    const filteredParts = parts.filter(part => part.trim() !== '');

    // Spojení částí lomítkem a normalizace lomítek
    return filteredParts
        .join('/')
        .replace(/\/+/g, '/') // Nahrazení více lomítek za jedno
        .replace(/^\/|\/$/g, ''); // Odstranění lomítek na začátku a konci
}

/**
 * Extrahuje klíče obsahu z registry
 * @param registry Registry obsahu
 * @returns Pole klíčů obsahu
 */
export function extractContentKeys<T extends object, K extends string = string>(
    registry: ContentRegistry<T, K>
): string[] {
    return Object.keys(registry);
}

/**
 * Transformuje registry obsahu pomocí mapovací funkce
 * @template T Původní typ obsahu
 * @template U Nový typ obsahu
 * @template K Typ klíče obsahu
 * @param registry Původní registry obsahu
 * @param mapFn Funkce pro transformaci každé položky
 * @returns Transformovaný registry obsahu
 */
export function mapContentRegistry<T extends object, U extends object, K extends string = string>(
    registry: ContentRegistry<T, K>,
    mapFn: (content: T, key: string) => U
): ContentRegistry<U, K> {
    const result: ContentRegistry<U, K> = {} as ContentRegistry<U, K>;

    for (const [key, value] of Object.entries(registry)) {
        if (typeof value === 'function') {
            // Pro lazy-loaded obsah
            result[key] = async () => {
                const loadedContent = await (value as Function)();
                // Handle default export from ES modules
                const actualContent = ('default' in loadedContent) ? loadedContent.default : loadedContent;
                return mapFn(actualContent as T, key);
            };
        } else {
            // Pro okamžitý obsah
            result[key] = mapFn(value as T, key);
        }
    }

    return result;
}
</file>

<file path="src/effect/EffectManager.ts">
import { GameState } from '../state';
import { Effect, EffectProcessor, EffectType, BuiltInEffectType } from './types';
import { produce } from '../utils/immer';
import { createDefaultEffectProcessors } from './processors';

const NAMESPACE_SEPARATOR = ':';

/**
 * Manažer efektů pro zpracování herních efektů
 */
export class EffectManager {
  /**
   * Mapa procesorů efektů podle typu
   */
  private effectProcessors: Map<string, EffectProcessor> = new Map();

  /**
   * Záložní procesor pro neznámé typy efektů
   */
  private fallbackProcessor: EffectProcessor | null = null;

  /**
   * Vytvoří novou instanci EffectManager
   *
   * @param options Možnosti konfigurace
   */
  constructor(options: { registerDefaultEffects?: boolean } = {}) {
    const { registerDefaultEffects = true } = options;

    if (registerDefaultEffects) {
      this.registerDefaultEffects();
    }
  }

  /**
   * Zpracuje jeden efekt s využitím příslušného procesoru
   *
   * @param effect Efekt ke zpracování
   * @param draftState Návrh herního stavu pro modifikaci
   * @private
   */
  private processSingleEffect(effect: Effect, draftState: GameState): void {
    const processor = this.effectProcessors.get(effect.type);

    if (processor) {
      processor(effect, draftState);
    } else if (this.fallbackProcessor) {
      this.fallbackProcessor(effect, draftState);
    } else {
      console.warn(`No processor registered for effect type '${effect.type}'`);
    }
  }

  /**
   * Registruje výchozí efektové procesory
   * @private
   */
  private registerDefaultEffects(): void {
    const defaultProcessors = createDefaultEffectProcessors();

    // Registrujeme všechny výchozí procesory
    this.registerEffectProcessors(defaultProcessors);
  }

  /**
   * Odregistruje výchozí efektové procesory
   */
  public unregisterDefaultEffects(): void {
    Object.values(BuiltInEffectType).forEach(type => {
      this.effectProcessors.delete(type);
    });
  }

  /**
   * Sestaví kompletní klíč procesoru včetně jmenného prostoru
   *
   * @param effectType Typ efektu
   * @param namespace Jmenný prostor (volitelný)
   * @returns Kompletní klíč procesoru
   * @private
   */
  private getFullEffectType(effectType: EffectType, namespace?: string): string {
    if (!namespace) {
      return effectType.toString();
    }
    return `${namespace}${NAMESPACE_SEPARATOR}${effectType}`;
  }

  /**
   * Registruje procesor pro daný typ efektu
   *
   * @param effectType Typ efektu
   * @param processor Funkce pro zpracování efektu
   * @param namespace Jmenný prostor (volitelný)
   */
  public registerEffectProcessor(effectType: EffectType, processor: EffectProcessor, namespace?: string): void {
    const fullType = this.getFullEffectType(effectType, namespace);
    this.effectProcessors.set(fullType, processor);
  }

  /**
   * Odregistruje procesor pro daný typ efektu
   *
   * @param effectType Typ efektu
   * @param namespace Jmenný prostor (volitelný)
   * @returns True pokud byl procesor úspěšně odregistrován
   */
  public unregisterEffectProcessor(effectType: EffectType, namespace?: string): boolean {
    const fullType = this.getFullEffectType(effectType, namespace);
    return this.effectProcessors.delete(fullType);
  }

  /**
   * Registruje více procesorů najednou
   *
   * @param processors Objekt mapující typy efektů na procesory
   * @param namespace Jmenný prostor (volitelný)
   */
  public registerEffectProcessors(processors: Record<string, EffectProcessor>, namespace?: string): void {
    for (const [type, processor] of Object.entries(processors)) {
      this.registerEffectProcessor(type as EffectType, processor, namespace);
    }
  }

  /**
   * Odregistruje všechny procesory patřící pod daný jmenný prostor
   *
   * @param namespace Jmenný prostor
   * @returns Počet odregistrovaných procesorů
   */
  public unregisterNamespace(namespace: string): number {
    const prefix = `${namespace}${NAMESPACE_SEPARATOR}`;
    let count = 0;

    for (const key of this.effectProcessors.keys()) {
      if (key.startsWith(prefix)) {
        this.effectProcessors.delete(key);
        count++;
      }
    }

    return count;
  }

  /**
   * Nastaví záložní procesor pro neznámé typy efektů
   *
   * @param processor Záložní procesor nebo null pro deaktivaci
   */
  public setFallbackProcessor(processor: EffectProcessor | null): void {
    this.fallbackProcessor = processor;
  }

  /**
   * Aplikuje efekt na herní stav
   *
   * @param effect Efekt k aplikaci
   * @param state Herní stav
   * @returns Nový herní stav
   */
  public applyEffect(effect: Effect, state: GameState): GameState {
    return produce(state, (draftState: GameState) => {
      this.processSingleEffect(effect, draftState);
    });
  }

  /**
   * Aplikuje více efektů na herní stav
   *
   * @param effects Pole efektů k aplikaci
   * @param state Herní stav
   * @returns Nový herní stav
   */
  public applyEffects(effects: Effect[], state: GameState): GameState {
    if (effects.length === 0) {
      return state;
    }

    return produce(state, (draftState: GameState) => {
      for (const effect of effects) {
        this.processSingleEffect(effect, draftState);
      }
    });
  }

  /**
   * Zkontroluje, zda existuje procesor pro daný typ efektu
   *
   * @param effectType Typ efektu
   * @param namespace Jmenný prostor (volitelný)
   * @returns True pokud procesor existuje
   */
  public hasProcessor(effectType: EffectType, namespace?: string): boolean {
    const fullType = this.getFullEffectType(effectType, namespace);
    return this.effectProcessors.has(fullType);
  }

  /**
   * Vrátí seznam registrovaných typů efektů
   *
   * @returns Pole typů efektů
   */
  public getRegisteredEffectTypes(): string[] {
    return Array.from(this.effectProcessors.keys());
  }
}
</file>

<file path="src/effect/index.ts">
// Export typů
export * from './types';

// Export hlavních tříd
export { EffectManager } from './EffectManager';

// Export procesorů
export { createDefaultEffectProcessors } from './processors';

// Export utilit
export {
    createSetEffect,
    createIncrementEffect,
    createDecrementEffect,
    createToggleEffect,
    createPushEffect,
    createRemoveEffect,
    createBatchEffect,
    createSequenceEffect,
    createConditionalEffect,
    createRepeatEffect,
    toBatchEffect,
    toSequenceEffect,
    isEffectOfType,
    isEffectFromNamespace
} from './utils';
</file>

<file path="src/effect/processors.ts">
import {
    EffectProcessor,
    BuiltInEffectType,
    BatchEffect,
    SequenceEffect,
    ConditionalEffect,
    RepeatEffect,
} from './types';
import { GameState } from '../state/types';
import { produce } from '../utils/immer';
import get from 'lodash/get';
import set from 'lodash/set';

type ProcessorRegistry = Record<string, EffectProcessor>;

/**
 * Pomocná funkce pro zpracování efektu
 * (Lokální ekvivalent processSingleEffect z EffectManager)
 * @private
 */
function processSingleEffect(
    effect: any,
    draftState: GameState,
    processors: ProcessorRegistry
): void {
    const processor = processors[effect.type];

    if (processor) {
        processor(effect, draftState);
    } else {
        console.warn(`No processor registered for effect type '${effect.type}'`);
    }
}

/**
 * Vytvoří registry procesorů výchozích efektů
 *
 * @returns Objekt mapující typy efektů na jejich procesory
 */
export function createDefaultEffectProcessors(): ProcessorRegistry {
    const processors: ProcessorRegistry = {};

    // Základní operace s proměnnými
    processors[BuiltInEffectType.set] = (effect, draftState) => {
        const { variable, value, path } = effect;

        if (path) {
            set(draftState, path, value);
        } else {
            draftState.variables[variable] = value;
        }
    };

    processors[BuiltInEffectType.increment] = (effect, draftState) => {
        const { variable, value = 1, path } = effect;

        if (path) {
            const currentValue = get(draftState, path, 0);
            const newValue = typeof currentValue !== 'number' ? value : currentValue + value;
            set(draftState, path, newValue);
        } else {
            if (typeof draftState.variables[variable] !== 'number') {
                draftState.variables[variable] = 0;
            }
            draftState.variables[variable] += value;
        }
    };

    processors[BuiltInEffectType.decrement] = (effect, draftState) => {
        const { variable, value = 1, path } = effect;

        if (path) {
            const currentValue = get(draftState, path, 0);
            const newValue = typeof currentValue !== 'number' ? -value : currentValue - value;
            set(draftState, path, newValue);
        } else {
            if (typeof draftState.variables[variable] !== 'number') {
                draftState.variables[variable] = 0;
            }
            draftState.variables[variable] -= value;
        }
    };

    processors[BuiltInEffectType.multiply] = (effect, draftState) => {
        const { variable, value, path } = effect;

        if (path) {
            const currentValue = get(draftState, path, 0);
            const newValue = typeof currentValue !== 'number' ? 0 : currentValue * value;
            set(draftState, path, newValue);
        } else {
            if (typeof draftState.variables[variable] !== 'number') {
                draftState.variables[variable] = 0;
            }
            draftState.variables[variable] *= value;
        }
    };

    processors[BuiltInEffectType.divide] = (effect, draftState) => {
        const { variable, value, path } = effect;

        if (value === 0) {
            throw new Error('Cannot divide by zero');
        }

        if (path) {
            const currentValue = get(draftState, path, 0);
            const newValue = typeof currentValue !== 'number' ? 0 : currentValue / value;
            set(draftState, path, newValue);
        } else {
            if (typeof draftState.variables[variable] !== 'number') {
                draftState.variables[variable] = 0;
            }
            draftState.variables[variable] /= value;
        }
    };

    processors[BuiltInEffectType.toggle] = (effect, draftState) => {
        const { variable, path } = effect;

        if (path) {
            const currentValue = get(draftState, path, false);
            set(draftState, path, !currentValue);
        } else {
            draftState.variables[variable] = !draftState.variables[variable];
        }
    };

    // Operace s poli
    processors[BuiltInEffectType.push] = (effect, draftState) => {
        const { array, value, path } = effect;

        if (path) {
            const currentArray = get(draftState, path, []);
            if (!Array.isArray(currentArray)) {
                set(draftState, path, [value]);
            } else {
                currentArray.push(value);
            }
        } else {
            if (!Array.isArray(draftState.variables[array])) {
                draftState.variables[array] = [];
            }
            draftState.variables[array].push(value);
        }
    };

    processors[BuiltInEffectType.remove] = (effect, draftState) => {
        const { array, value, byIndex = false, path } = effect;

        const removeByIndexOrValue = (arr: any[], val: any, useIndex: boolean) => {
            if (useIndex) {
                if (val >= 0 && val < arr.length) {
                    arr.splice(val, 1);
                }
            } else if (typeof val === 'object') {
                // Pro objektové hodnoty hledáme podle equality funkce, pokud je poskytnuta
                const equalityFn = effect.equalityFn || ((a: any, b: any) => a === b);
                const index = arr.findIndex(item => equalityFn(item, val));
                if (index !== -1) {
                    arr.splice(index, 1);
                }
            } else {
                const index = arr.indexOf(val);
                if (index !== -1) {
                    arr.splice(index, 1);
                }
            }
        };

        if (path) {
            const currentArray = get(draftState, path, []);
            if (Array.isArray(currentArray)) {
                removeByIndexOrValue(currentArray, value, byIndex);
            }
        } else {
            if (Array.isArray(draftState.variables[array])) {
                removeByIndexOrValue(draftState.variables[array], value, byIndex);
            }
        }
    };

    // Kompozitní efekty
    processors[BuiltInEffectType.batch] = (effect, draftState) => {
        const batchEffect = effect as BatchEffect;

        if (!batchEffect.effects || !Array.isArray(batchEffect.effects)) {
            throw new Error('Batch effect requires an array of effects');
        }

        for (const subEffect of batchEffect.effects) {
            processSingleEffect(subEffect, draftState, processors);
        }
    };

    processors[BuiltInEffectType.sequence] = (effect, draftState) => {
        const sequenceEffect = effect as SequenceEffect;

        if (!sequenceEffect.effects || !Array.isArray(sequenceEffect.effects)) {
            throw new Error('Sequence effect requires an array of effects');
        }

        for (const subEffect of sequenceEffect.effects) {
            processSingleEffect(subEffect, draftState, processors);
        }
    };

    processors[BuiltInEffectType.conditional] = (effect, draftState) => {
        const conditionalEffect = effect as ConditionalEffect;

        if (!conditionalEffect.condition || typeof conditionalEffect.condition !== 'function') {
            throw new Error('Conditional effect requires a condition function');
        }

        if (!conditionalEffect.thenEffects || !Array.isArray(conditionalEffect.thenEffects)) {
            throw new Error('Conditional effect requires thenEffects array');
        }

        // Pro vyhodnocení podmínky použijeme immutable kopii stavu
        const immutableState = produce(draftState, () => {});
        const conditionResult = conditionalEffect.condition(immutableState);

        if (conditionResult) {
            // Aplikujeme 'then' efekty
            for (const subEffect of conditionalEffect.thenEffects) {
                processSingleEffect(subEffect, draftState, processors);
            }
        } else if (conditionalEffect.elseEffects && Array.isArray(conditionalEffect.elseEffects)) {
            // Aplikujeme 'else' efekty, pokud existují
            for (const subEffect of conditionalEffect.elseEffects) {
                processSingleEffect(subEffect, draftState, processors);
            }
        }
    };

    processors[BuiltInEffectType.repeat] = (effect, draftState) => {
        const repeatEffect = effect as RepeatEffect;

        if (!repeatEffect.effect) {
            throw new Error('Repeat effect requires an effect to repeat');
        }

        let count: number;

        if (typeof repeatEffect.count === 'function') {
            // Pro vyhodnocení počtu opakování použijeme immutable kopii stavu
            const immutableState = produce(draftState, () => {});
            count = repeatEffect.count(immutableState);
        } else {
            count = repeatEffect.count;
        }

        if (!Number.isInteger(count) || count < 0) {
            throw new Error('Repeat count must be a non-negative integer');
        }

        for (let i = 0; i < count; i++) {
            processSingleEffect(repeatEffect.effect, draftState, processors);
        }
    };

    return processors;
}
</file>

<file path="src/effect/types.ts">
import { GameState } from '../state/types';

/**
 * Výčet typů vestavěných efektů
 */
export enum BuiltInEffectType {
  set = 'set',
  increment = 'increment',
  decrement = 'decrement',
  multiply = 'multiply',
  divide = 'divide',
  toggle = 'toggle',

  // Efekty pro pole
  push = 'push',
  remove = 'remove',

  // Kompozitní efekty
  batch = 'batch',
  sequence = 'sequence',
  conditional = 'conditional',
  repeat = 'repeat'
}

/**
 * Typ pro identifikaci efektu (může být vestavěný nebo vlastní)
 */
export type EffectType = BuiltInEffectType | string;

/**
 * Základní rozhraní pro všechny efekty
 */
export interface Effect {
  /**
   * Typ efektu
   */
  type: EffectType;

  /**
   * Indexová signatura pro další vlastnosti
   */
  [key: string]: any;
}

/**
 * Funkce pro zpracování efektu
 */
export type EffectProcessor = (effect: Effect, draftState: GameState) => void;

/**
 * Rozhraní pro efekt z pluginu
 */
export interface PluginEffect extends Effect {
  /**
   * Jmenný prostor pluginu
   */
  namespace: string;
}

// Rozhraní pro kompozitní efekty

/**
 * Efekt pro aplikaci více efektů najednou
 */
export interface BatchEffect extends Effect {
  type: BuiltInEffectType.batch;
  /**
   * Pole efektů k aplikaci
   */
  effects: Effect[];
}

/**
 * Efekt pro sekvenční aplikaci efektů
 */
export interface SequenceEffect extends Effect {
  type: BuiltInEffectType.sequence;
  /**
   * Pole efektů k sekvenční aplikaci
   */
  effects: Effect[];
}

/**
 * Efekt pro podmíněnou aplikaci efektů
 */
export interface ConditionalEffect extends Effect {
  type: BuiltInEffectType.conditional;
  /**
   * Podmínka, která určuje, zda se efekty aplikují
   */
  condition: (state: GameState) => boolean;
  /**
   * Efekty aplikované, pokud je podmínka splněna
   */
  thenEffects: Effect[];
  /**
   * Efekty aplikované, pokud podmínka není splněna
   */
  elseEffects?: Effect[];
}

/**
 * Efekt pro opakování jiného efektu
 */
export interface RepeatEffect extends Effect {
  type: BuiltInEffectType.repeat;
  /**
   * Počet opakování nebo funkce, která vrátí počet opakování
   */
  count: number | ((state: GameState) => number);
  /**
   * Efekt, který se bude opakovat
   */
  effect: Effect;
}

// Rozhraní pro efekty proměnných

/**
 * Základní efekt pro operace s proměnnými
 */
export interface VariableEffect extends Effect {
  /**
   * Název proměnné
   */
  variable: string;
  /**
   * Volitelná cesta k vlastnosti (pro nested properties)
   */
  path?: string;
}

/**
 * Efekt pro nastavení hodnoty proměnné
 */
export interface SetVariableEffect extends VariableEffect {
  type: BuiltInEffectType.set;
  /**
   * Hodnota k nastavení
   */
  value: any;
}

/**
 * Efekt pro zvýšení hodnoty proměnné
 */
export interface IncrementVariableEffect extends VariableEffect {
  type: BuiltInEffectType.increment;
  /**
   * Hodnota k přičtení (výchozí: 1)
   */
  value?: number;
}

/**
 * Efekt pro snížení hodnoty proměnné
 */
export interface DecrementVariableEffect extends VariableEffect {
  type: BuiltInEffectType.decrement;
  /**
   * Hodnota k odečtení (výchozí: 1)
   */
  value?: number;
}

/**
 * Efekt pro násobení hodnoty proměnné
 */
export interface MultiplyVariableEffect extends VariableEffect {
  type: BuiltInEffectType.multiply;
  /**
   * Hodnota, kterou se proměnná vynásobí
   */
  value: number;
}

/**
 * Efekt pro dělení hodnoty proměnné
 */
export interface DivideVariableEffect extends VariableEffect {
  type: BuiltInEffectType.divide;
  /**
   * Hodnota, kterou se proměnná vydělí
   */
  value: number;
}

/**
 * Efekt pro přepnutí hodnoty proměnné (boolean toggle)
 */
export interface ToggleVariableEffect extends VariableEffect {
  type: BuiltInEffectType.toggle;
}

// Rozhraní pro efekty na polích

/**
 * Základní efekt pro operace s poli
 */
export interface ArrayEffect extends Effect {
  /**
   * Název pole
   */
  array: string;
  /**
   * Volitelná cesta k vlastnosti (pro nested properties)
   */
  path?: string;
}

/**
 * Efekt pro přidání hodnoty do pole
 */
export interface PushToArrayEffect extends ArrayEffect {
  type: BuiltInEffectType.push;
  /**
   * Hodnota k přidání do pole
   */
  value: any;
}

/**
 * Efekt pro odstranění hodnoty z pole
 */
export interface RemoveFromArrayEffect extends ArrayEffect {
  type: BuiltInEffectType.remove;
  /**
   * Hodnota k odstranění
   */
  value: any;
  /**
   * Zda se má odstranit podle indexu nebo hodnoty
   */
  byIndex?: boolean;
  /**
   * Volitelná funkce pro porovnání objektů
   */
  equalityFn?: (a: any, b: any) => boolean;
}
</file>

<file path="src/effect/utils.ts">
import {
  Effect,
  BatchEffect,
  SequenceEffect,
  ConditionalEffect,
  RepeatEffect,
  SetVariableEffect,
  IncrementVariableEffect,
  DecrementVariableEffect,
  ToggleVariableEffect,
  PushToArrayEffect,
  RemoveFromArrayEffect,
  BuiltInEffectType
} from './types';
import { GameState } from '../state/types';

/**
 * Vytvoří efekt pro nastavení hodnoty proměnné
 */
export function createSetEffect(variable: string, value: any, path?: string): SetVariableEffect {
  return {
    type: BuiltInEffectType.set,
    variable,
    value,
    path
  };
}

/**
 * Vytvoří efekt pro zvýšení hodnoty proměnné
 */
export function createIncrementEffect(variable: string, value = 1, path?: string): IncrementVariableEffect {
  return {
    type: BuiltInEffectType.increment,
    variable,
    value,
    path
  };
}

/**
 * Vytvoří efekt pro snížení hodnoty proměnné
 */
export function createDecrementEffect(variable: string, value = 1, path?: string): DecrementVariableEffect {
  return {
    type: BuiltInEffectType.decrement,
    variable,
    value,
    path
  };
}

/**
 * Vytvoří efekt pro přepnutí boolean hodnoty proměnné
 */
export function createToggleEffect(variable: string, path?: string): ToggleVariableEffect {
  return {
    type: BuiltInEffectType.toggle,
    variable,
    path
  };
}

/**
 * Vytvoří efekt pro přidání hodnoty do pole
 */
export function createPushEffect(array: string, value: any, path?: string): PushToArrayEffect {
  return {
    type: BuiltInEffectType.push,
    array,
    value,
    path
  };
}

/**
 * Vytvoří efekt pro odstranění hodnoty z pole
 */
export function createRemoveEffect(
    array: string,
    value: any,
    options: { byIndex?: boolean; path?: string; equalityFn?: (a: any, b: any) => boolean } = {}
): RemoveFromArrayEffect {
  return {
    type: BuiltInEffectType.remove,
    array,
    value,
    ...options
  };
}

/**
 * Vytvoří efekt pro dávkové provedení více efektů najednou
 */
export function createBatchEffect(effects: Effect[]): BatchEffect {
  return {
    type: BuiltInEffectType.batch,
    effects
  };
}

/**
 * Vytvoří efekt pro sekvenční provedení více efektů
 */
export function createSequenceEffect(effects: Effect[]): SequenceEffect {
  return {
    type: BuiltInEffectType.sequence,
    effects
  };
}

/**
 * Vytvoří efekt pro podmíněné provedení efektů
 */
export function createConditionalEffect(
    condition: (state: GameState) => boolean,
    thenEffects: Effect[],
    elseEffects?: Effect[]
): ConditionalEffect {
  return {
    type: BuiltInEffectType.conditional,
    condition,
    thenEffects,
    elseEffects
  };
}

/**
 * Vytvoří efekt pro opakované provedení jiného efektu
 */
export function createRepeatEffect(
    effect: Effect,
    count: number | ((state: GameState) => number)
): RepeatEffect {
  return {
    type: BuiltInEffectType.repeat,
    count,
    effect
  };
}

/**
 * Převede neuspořádaný seznam efektů na batch efekt
 */
export function toBatchEffect(effects: Effect[]): BatchEffect {
  return createBatchEffect(effects);
}

/**
 * Převede neuspořádaný seznam efektů na sequence efekt
 */
export function toSequenceEffect(effects: Effect[]): SequenceEffect {
  return createSequenceEffect(effects);
}

/**
 * Zkontroluje, zda je efekt určitého typu
 */
export function isEffectOfType<T extends Effect>(effect: Effect, type: BuiltInEffectType | string): effect is T {
  return effect.type === type;
}

/**
 * Zkontroluje, zda je efekt z určitého jmenného prostoru
 */
export function isEffectFromNamespace(effect: Effect, namespace: string): boolean {
  return 'namespace' in effect && (effect as any).namespace === namespace;
}
</file>

<file path="src/engine/GameEngine.ts">
// Importuj správně typy a enumy
import {
    GameEngineOptions,
    GameEngineCoreEvents, // Použij přejmenovaný enum
    GameStartedEventData,
    GameEndedEventData,
    SceneChangedEventData,
    EffectAppliedEventData,
    EngineEventMap, // Import sjednocené mapy
    EngineCoreEventMap // Import mapy pro core události
} from './types';
import { GameState, GameStateManagerEvents } from '../state/types'; // GameStateManagerEvents z state/types
import { Scene, SceneKey, SceneTransitionOptions } from '../scene/types';
import { Effect } from '../effect/types';
import { EventEmitter } from '../event/EventEmitter';
import { TypedEventEmitter } from '../event/TypedEventEmitter'; // Zkontroluj název souboru!
import { GameStateManager } from '../state'; // GameStateManager z state/index
import { SceneManager } from '../scene/SceneManager';
import { EffectManager } from '../effect/EffectManager';
import { PluginManager } from '../plugin/PluginManager';
import { GenericContentLoader } from '../content/GenericContentLoader';
import { LoaderRegistry } from '../content/LoaderRegistry';
import { SaveManager, SaveEvents, SaveEventMap } from '../save'; // SaveEventMap ze save/index
import { ContentDefinition, ContentRegistry } from '../content/types';
import { Plugin, PluginEvents, PluginEventMap } from '../plugin/types'; // PluginEventMap z plugin/types
import { createSaveManager } from '../save/utils';
import { GameEventType, EventListener } from '../event/types'; // Import z event/types
import { StateManagerPersistenceEvents, PersistedState } from '../state/persistence/types';

/**
 * Hlavní třída herního enginu
 */
export class GameEngine {
    private readonly version: string;
    private readonly eventEmitter: EventEmitter;
    private readonly stateManager: GameStateManager;
    private readonly sceneManager: SceneManager;
    private readonly effectManager: EffectManager;
    private readonly pluginManager: PluginManager;
    private readonly loaderRegistry: LoaderRegistry;
    private readonly saveManager: SaveManager;
    private isRunning: boolean = false;

    constructor(options: GameEngineOptions) {
        const {
            sceneLoader,
            initialState = {},
            plugins = [],
            engineVersion = '0.1.0'
        } = options;

        this.version = engineVersion;
        this.eventEmitter = options.eventEmitter || new EventEmitter();

        // GameStateManager nyní přijímá engine
        this.stateManager = new GameStateManager(this, {
            initialState,
            persistentKeys: options.persistentKeys, // Předání persistentKeys
            onBeforeSerialize: options.onBeforeSerialize, // Předání callbacků
            onAfterDeserialize: options.onAfterDeserialize
        });

        this.loaderRegistry = new LoaderRegistry();
        this.effectManager = new EffectManager({ registerDefaultEffects: options.registerDefaultEffects ?? true });
        this.loaderRegistry.registerLoader('scenes', sceneLoader);
        this.sceneManager = new SceneManager(sceneLoader);

        this.pluginManager = new PluginManager(this, this.eventEmitter, {
            autoActivate: options.autoActivatePlugins ?? true,
            allowOverride: options.allowPluginOverride ?? false
        });

        if (options.saveManager) {
            this.saveManager = options.saveManager;
        } else {
            this.saveManager = createSaveManager(this, {
                storage: options.saveStorage,
                engineVersion: this.version,
                storagePrefix: options.storagePrefix,
                enableAutoSave: options.enableAutoSave,
                autoSaveInterval: options.autoSaveInterval,
                autoSaveSlots: options.autoSaveSlots,
                storageType: options.storageType
            });
        }

        this.initializePlugins(plugins); // Tato metoda je async
    }

    private async initializePlugins(plugins: Plugin[]): Promise<void> {
        for (const plugin of plugins) {
            // Ošetření chyby při registraci pluginu
            try {
                await this.pluginManager.registerPlugin(plugin);
            } catch (error) {
                console.error(`Failed to register or activate plugin '${plugin.name}':`, error);
                // Emituj engine error
                this.getCoreEventEmitter().emit(GameEngineCoreEvents.ERROR, {
                    message: `Plugin registration/activation failed: ${plugin.name}`,
                    error,
                    context: 'pluginInitialization'
                });
            }
        }
    }

    // --- Typed Emitter Getters ---
    // Vrací typovaný emitter pro všechny události procházející enginem
    public getTypedEventEmitter(): TypedEventEmitter<EngineEventMap> {
        return new TypedEventEmitter<EngineEventMap>(this.eventEmitter);
    }
    // Specifické gettery pro jednotlivé mapy událostí
    public getCoreEventEmitter(): TypedEventEmitter<EngineCoreEventMap> {
        return new TypedEventEmitter<EngineCoreEventMap>(this.eventEmitter);
    }
    public getPluginEventEmitter(): TypedEventEmitter<PluginEventMap> {
        return new TypedEventEmitter<PluginEventMap>(this.eventEmitter);
    }
    public getSaveEventEmitter(): TypedEventEmitter<SaveEventMap> {
        return new TypedEventEmitter<SaveEventMap>(this.eventEmitter);
    }
    public getStateManagerEventEmitter<T extends Record<string, unknown>>(): TypedEventEmitter<GameStateManagerEvents<T>> {
        return new TypedEventEmitter<GameStateManagerEvents<T>>(this.eventEmitter);
    }
    public getPersistenceEventEmitter<T extends Record<string, unknown>>(): TypedEventEmitter<StateManagerPersistenceEvents<T>> {
        return new TypedEventEmitter<StateManagerPersistenceEvents<T>>(this.eventEmitter);
    }
    public getGenericEventEmitter(): EventEmitter {
        return this.eventEmitter;
    }
    // ---

    public async start(initialSceneKey: SceneKey, options?: SceneTransitionOptions): Promise<boolean> {
        if (options?.effects && options.effects.length > 0) {
            this.applyEffects(options.effects);
        }

        const success = await this.sceneManager.transitionToScene(
            initialSceneKey,
            this.stateManager.getState(),
            this
        );

        if (success) {
            this.isRunning = true;
            const startEventData: GameStartedEventData = {
                sceneKey: initialSceneKey,
                transitionData: options?.data
            };
            // Použij core emitter
            this.getCoreEventEmitter().emit(GameEngineCoreEvents.GAME_STARTED, startEventData);

            const sceneChangeEventData: SceneChangedEventData = {
                scene: this.sceneManager.getCurrentScene()!,
                sceneKey: initialSceneKey,
                transitionData: options?.data
            };
            // Použij core emitter
            this.getCoreEventEmitter().emit(GameEngineCoreEvents.SCENE_CHANGED, sceneChangeEventData);
        } else {
            console.error(`Failed to start game at scene '${initialSceneKey}'`);
            this.getCoreEventEmitter().emit(GameEngineCoreEvents.ERROR, {
                message: `Failed to start game at scene '${initialSceneKey}'`,
                context: 'startGame'
            });
        }
        return success;
    }

    public end(reason?: string, data: Record<string, any> = {}): void {
        if (!this.isRunning) return;
        this.isRunning = false;
        const eventData: GameEndedEventData = { reason, ...data };
        // Použij core emitter
        this.getCoreEventEmitter().emit(GameEngineCoreEvents.GAME_ENDED, eventData);
    }

    public async transitionToScene(
        sceneKey: SceneKey,
        options?: SceneTransitionOptions
    ): Promise<boolean> {
        if (!this.isRunning) {
            console.warn('Cannot transition: game is not running. Call start() first.');
            return false;
        }
        const previousSceneKey = this.sceneManager.getCurrentSceneKey();
        const previousScene = this.sceneManager.getCurrentScene();

        if (options?.effects && options.effects.length > 0) {
            this.applyEffects(options.effects);
        }

        const success = await this.sceneManager.transitionToScene(
            sceneKey,
            this.stateManager.getState(),
            this
        );

        if (success) {
            const eventData: SceneChangedEventData = {
                scene: this.sceneManager.getCurrentScene()!,
                sceneKey,
                previousScene: previousScene ?? undefined,
                previousSceneKey: previousSceneKey ?? undefined,
                transitionData: options?.data
            };
            // Použij core emitter
            this.getCoreEventEmitter().emit(GameEngineCoreEvents.SCENE_CHANGED, eventData);
        } else {
            console.error(`Failed to transition to scene '${sceneKey}'`);
            this.getCoreEventEmitter().emit(GameEngineCoreEvents.ERROR, {
                message: `Failed to transition to scene '${sceneKey}'`,
                context: 'transitionScene'
            });
        }
        return success;
    }

    public applyEffects(effects: Effect[]): void {
        if (!effects || effects.length === 0) return;

        const currentState = this.stateManager.getState();
        let newState = currentState; // Inicializace pro případ chyby
        try {
            // Předpokládáme, že EffectManager může pracovat s draftem nebo vrátí nový stav
            this.stateManager.updateState(draftState => {
                // Zde EffectManager *musí* modifikovat draft, pokud má být změna efektivní v rámci jednoho updateState
                // Pokud EffectManager vrací nový stav, logika by byla jiná (méně efektivní s Immer)
                this.effectManager.applyEffects(effects, draftState); // Předpokládáme, že toto modifikuje draftState
            }, 'applyEffects');

            newState = this.stateManager.getState(); // Získání nového stavu po úspěšné aktualizaci

            const eventData: EffectAppliedEventData = {
                effect: effects.length === 1 ? effects[0] : { type: 'batch', effects },
                previousState: currentState,
                newState
            };
            this.getCoreEventEmitter().emit(GameEngineCoreEvents.EFFECT_APPLIED, eventData);

        } catch (error) {
            console.error("Error applying effects:", error);
            this.getCoreEventEmitter().emit(GameEngineCoreEvents.ERROR, {
                message: `Error applying effects`,
                error,
                context: 'applyEffects'
            });
            // Stav zůstane 'currentState', protože updateState selhal nebo nebyl dokončen
        }
    }

    public applyEffect(effect: Effect): void {
        if (!effect) return;
        this.applyEffects([effect]);
    }

    public registerContent(
        contentDefinition: ContentDefinition<any>
    ): boolean {
        const { type, content } = contentDefinition;
        const loader = this.loaderRegistry.getLoader<any>(type);
        if (!loader) {
            console.warn(`No loader registered for content type '${type}'`);
            return false;
        }
        try {
            loader.registerContent(content);
            return true;
        } catch (error) {
            console.error(`Failed to register content for type '${type}':`, error);
            this.getCoreEventEmitter().emit(GameEngineCoreEvents.ERROR, {
                message: `Failed to register content for type '${type}'`,
                error,
                context: 'registerContent'
            });
            return false;
        }
    }

    public getLoader<T extends object, K extends string = string>(
        type: string
    ): GenericContentLoader<T, K> | undefined {
        return this.loaderRegistry.getLoader<T, K>(type);
    }

    // Obecné on/off/emit pro flexibilitu
    public on(eventType: GameEventType, listener: EventListener): void {
        this.eventEmitter.on(eventType, listener);
    }
    public off(eventType: GameEventType, listener: EventListener): void {
        this.eventEmitter.off(eventType, listener);
    }
    public emit(eventType: GameEventType, data?: any): void {
        this.eventEmitter.emit(eventType, data);
    }

    // --- Gettery pro managery ---
    public getState(): GameState { return this.stateManager.getState(); }
    public getCurrentScene(): Scene | null { return this.sceneManager.getCurrentScene(); }
    public getCurrentSceneKey(): SceneKey | null { return this.sceneManager.getCurrentSceneKey(); }
    public getVersion(): string { return this.version; }
    public isGameRunning(): boolean { return this.isRunning; }
    public getStateManager(): GameStateManager { return this.stateManager; }
    public getSceneManager(): SceneManager { return this.sceneManager; }
    public getEffectManager(): EffectManager { return this.effectManager; }
    public getPluginManager(): PluginManager { return this.pluginManager; }
    public getLoaderRegistry(): LoaderRegistry { return this.loaderRegistry; }
    public getSaveManager(): SaveManager { return this.saveManager; }

    // --- Metody pro pluginy a ukládání ---
    public async registerPlugin(plugin: Plugin): Promise<boolean> {
        return await this.pluginManager.registerPlugin(plugin);
    }
    public async unregisterPlugin(pluginName: string): Promise<boolean> {
        return await this.pluginManager.unregisterPlugin(pluginName);
    }
    public getPlugin<T extends Plugin>(pluginName: string): T | undefined {
        return this.pluginManager.getPlugin<T>(pluginName);
    }
    public async saveGame(saveId: string, options = {}): Promise<boolean> {
        return await this.saveManager.save(saveId, options);
    }
    public async loadGame(saveId: string): Promise<boolean> {
        return await this.saveManager.load(saveId);
    }
    public async restart(options: {
        initialState?: Partial<GameState>;
        initialSceneKey?: SceneKey;
    } = {}): Promise<boolean> {
        if (this.isRunning) {
            this.end('restart');
        }
        this.stateManager.resetState(options.initialState);
        const initialSceneKey = options.initialSceneKey || this.sceneManager.getCurrentSceneKey() || 'start';
        return await this.start(initialSceneKey);
    }
}
</file>

<file path="src/engine/index.ts">
// Export typů
export * from './types';

// Export hlavních tříd
export { GameEngine } from './GameEngine';

// Export utilit
export { createGameEngine } from './utils';
</file>

<file path="src/engine/types.ts">
import { Scene, SceneKey } from '../scene';
import { GameState, GameStateManagerEvents, StateManagerPersistenceEvents } from '../state';
import { Effect } from '../effect';
import { Plugin, PluginEventMap } from '../plugin';
import { SaveManager, SaveStorage, SaveEventMap } from '../save';
import { GenericContentLoader } from '../content';
import { EventEmitter } from '../event';

/** Možnosti konfigurace herního enginu */
export interface GameEngineOptions {
    sceneLoader: GenericContentLoader<Scene>;
    initialState?: Partial<GameState>;
    plugins?: Plugin[];
    saveManager?: SaveManager;
    engineVersion?: string;
    eventEmitter?: EventEmitter;
    saveStorage?: SaveStorage;
    allowPluginOverride?: boolean; // Příklad
    storagePrefix?: string; // Příklad
    [key: string]: any;
}

/** Události emitované *přímo* herním enginem (core události) */
export enum GameEngineCoreEvents { // Přejmenováno pro odlišení
    GAME_STARTED = 'game:started',
    GAME_ENDED = 'game:ended',
    SCENE_CHANGED = 'scene:changed', // Scéna se změnila (z pohledu enginu)
    EFFECT_APPLIED = 'effect:applied', // Efekt byl aplikován (z pohledu enginu)
    ERROR = 'engine:error' // Obecná chyba enginu
    // STATE_CHANGED se nyní emituje z GameStateManageru
}

// --- Typy dat pro Core události ---

/** Data předávaná při události startu hry */
export interface GameStartedEventData {
    sceneKey: SceneKey;
    transitionData?: any;
}

/** Data předávaná při události konce hry */
export interface GameEndedEventData {
    reason?: string;
    [key: string]: any;
}

/** Data předávaná při události změny scény */
export interface SceneChangedEventData {
    scene: Scene;
    sceneKey: SceneKey;
    previousScene?: Scene;
    previousSceneKey?: SceneKey;
    transitionData?: any;
}

/** Data předávaná při události aplikace efektu */
export interface EffectAppliedEventData {
    effect: Effect | { type: 'batch', effects: Effect[] }; // Zahrnuje i batch pro applyEffects
    previousState: GameState;
    newState: GameState;
}

/** Data předávaná při události chyby enginu */
export interface EngineErrorEventData {
    message: string;
    error?: Error | unknown;
    context?: string; // Kde chyba nastala
}

// --- Mapa pro Core události ---
export type EngineCoreEventMap = {
    [GameEngineCoreEvents.GAME_STARTED]: GameStartedEventData;
    [GameEngineCoreEvents.GAME_ENDED]: GameEndedEventData;
    [GameEngineCoreEvents.SCENE_CHANGED]: SceneChangedEventData;
    [GameEngineCoreEvents.EFFECT_APPLIED]: EffectAppliedEventData;
    [GameEngineCoreEvents.ERROR]: EngineErrorEventData;
};


/**
 * Sjednocená mapa VŠECH událostí, které mohou procházet přes engine emitter.
 * Zahrnuje core události, události pluginů, ukládání a stavu.
 * Používá se pro typování hlavního `TypedEventEmitter` v GameEngine.
 * Použití `<any>` pro generické typy stavu je zde kompromis,
 * pokud nechceme mít GameEngine závislý na konkrétním typu T stavu.
 */
export type EngineEventMap = EngineCoreEventMap
    & PluginEventMap
    & SaveEventMap
    & GameStateManagerEvents<any> // Události runtime stavu
    & StateManagerPersistenceEvents<any>; // Události persistence stavu


// Přejmenování enum pro konzistenci (můžeš použít i původní GameEngineEvents, pokud chceš)
export const GameEngineEvents = GameEngineCoreEvents;
</file>

<file path="src/engine/utils.ts">
import { GameEngine } from './GameEngine';
import { GameEngineOptions } from './types';
import { Scene } from '../scene/types';
import { GenericContentLoader } from '../content/GenericContentLoader';
import { ContentDefinition } from '../content/types';
import { Plugin } from '../plugin/types';
import { GameState } from '../state/types';

/**
 * Možnosti pro vytvoření herního enginu
 */
export interface CreateGameEngineOptions {
    /**
     * Definice obsahu k registraci
     */
    content?: ContentDefinition<any>[];

    /**
     * Pluginy k registraci
     */
    plugins?: Plugin[];

    /**
     * Počáteční stav hry
     */
    initialState?: Partial<GameState>;

    /**
     * Vlastní content loader pro scény
     */
    sceneLoader?: GenericContentLoader<Scene>;

    /**
     * Další možnosti konfigurace enginu
     */
    engineOptions?: Partial<GameEngineOptions>;
}

/**
 * Vytvoří nový herní engine s danou konfigurací
 *
 * @param options Možnosti pro vytvoření enginu
 * @returns Nová instance herního enginu
 */
export function createGameEngine(options: CreateGameEngineOptions = {}): GameEngine {
    const {
        content = [],
        plugins = [],
        initialState = {},
        sceneLoader = new GenericContentLoader<Scene>(),
        engineOptions = {}
    } = options;

    // Vytvoření enginu
    const engine = new GameEngine({
        sceneLoader,
        initialState,
        plugins,
        ...engineOptions
    });

    // Registrace obsahu
    for (const contentDef of content) {
        engine.registerContent(contentDef);
    }

    return engine;
}
</file>

<file path="src/event/EventEmitter.ts">
import { GameEventType, EventListener, EventEmitterOptions } from './types';

/**
 * EventEmitter implementuje návrhový vzor Observer
 * Umožňuje registraci posluchačů událostí a emitování událostí
 */
export class EventEmitter {
    /**
     * Mapa posluchačů událostí
     * Klíč je typ události, hodnota je množina posluchačů
     */
    private listeners: Map<GameEventType, Set<EventListener>> = new Map();

    /**
     * Mapa jednorázových posluchačů událostí
     * Posluchači jsou automaticky odstraněni po prvním zavolání
     */
    private onceListeners: Map<GameEventType, Set<EventListener>> = new Map();

    /**
     * Maximální počet posluchačů na jeden typ události
     */
    private maxListeners: number;

    /**
     * Zda zachytávat chyby v posluchačích
     */
    private catchErrors: boolean;

    /**
     * Vytvoří nový EventEmitter
     *
     * @param options Možnosti konfigurace EventEmitter
     */
    constructor(options: EventEmitterOptions = {}) {
        const { catchErrors = true, maxListeners = 10 } = options;
        this.catchErrors = catchErrors;
        this.maxListeners = maxListeners;
    }

    /**
     * Registruje posluchače pro daný typ události
     *
     * @param eventType Typ události
     * @param listener Funkce posluchače
     */
    public on(eventType: GameEventType, listener: EventListener): void {
        if (!this.listeners.has(eventType)) {
            this.listeners.set(eventType, new Set());
        }

        const eventListeners = this.listeners.get(eventType)!;
        eventListeners.add(listener);

        // Kontrola počtu posluchačů
        if (eventListeners.size > this.maxListeners) {
            console.warn(`Possible EventEmitter memory leak detected. ${eventListeners.size} listeners added for event type '${eventType}'`);
        }
    }

    /**
     * Registruje jednorázového posluchače pro daný typ události
     * Posluchač bude automaticky odstraněn po prvním zavolání
     *
     * @param eventType Typ události
     * @param listener Funkce posluchače
     */
    public once(eventType: GameEventType, listener: EventListener): void {
        if (!this.onceListeners.has(eventType)) {
            this.onceListeners.set(eventType, new Set());
        }

        const eventListeners = this.onceListeners.get(eventType)!;
        eventListeners.add(listener);
    }

    /**
     * Odregistruje posluchače pro daný typ události
     *
     * @param eventType Typ události
     * @param listener Funkce posluchače
     */
    public off(eventType: GameEventType, listener: EventListener): void {
        // Kontrola běžných posluchačů
        const eventListeners = this.listeners.get(eventType);
        if (eventListeners) {
            eventListeners.delete(listener);
            if (eventListeners.size === 0) {
                this.listeners.delete(eventType);
            }
        }

        // Kontrola jednorázových posluchačů
        const onceEventListeners = this.onceListeners.get(eventType);
        if (onceEventListeners) {
            onceEventListeners.delete(listener);
            if (onceEventListeners.size === 0) {
                this.onceListeners.delete(eventType);
            }
        }
    }

    /**
     * Emituje událost daného typu s volitelným datovým objektem
     *
     * @param eventType Typ události
     * @param data Volitelná data předaná posluchačům
     */
    public emit(eventType: GameEventType, data?: any): void {
        // Zavolání běžných posluchačů
        const eventListeners = this.listeners.get(eventType);
        if (eventListeners) {
            this.callListeners(eventListeners, data);
        }

        // Zavolání a odstranění jednorázových posluchačů
        const onceEventListeners = this.onceListeners.get(eventType);
        if (onceEventListeners && onceEventListeners.size > 0) {
            this.callListeners(onceEventListeners, data);
            this.onceListeners.delete(eventType);
        }
    }

    /**
     * Volá všechny posluchače v dané množině s danými daty
     *
     * @param listeners Množina posluchačů
     * @param data Data k předání posluchačům
     * @private
     */
    private callListeners(listeners: Set<EventListener>, data: any): void {
        for (const listener of listeners) {
            try {
                listener(data);
            } catch (error) {
                if (!this.catchErrors) {
                    throw error;
                }
                console.error(`Error in event listener:`, error);
            }
        }
    }

    /**
     * Odstraní všechny posluchače pro daný typ události
     * Pokud není typ události specifikován, odstraní všechny posluchače
     *
     * @param eventType Volitelný typ události
     */
    public removeAllListeners(eventType?: GameEventType): void {
        if (eventType) {
            this.listeners.delete(eventType);
            this.onceListeners.delete(eventType);
        } else {
            this.listeners.clear();
            this.onceListeners.clear();
        }
    }

    /**
     * Vrátí seznam všech registrovaných typů událostí
     *
     * @returns Pole typů událostí
     */
    public getEventTypes(): GameEventType[] {
        const types = new Set([
            ...this.listeners.keys(),
            ...this.onceListeners.keys()
        ]);
        return Array.from(types);
    }

    /**
     * Vrátí počet posluchačů pro daný typ události
     *
     * @param eventType Typ události
     * @returns Počet posluchačů
     */
    public listenerCount(eventType: GameEventType): number {
        let count = 0;

        const eventListeners = this.listeners.get(eventType);
        if (eventListeners) {
            count += eventListeners.size;
        }

        const onceEventListeners = this.onceListeners.get(eventType);
        if (onceEventListeners) {
            count += onceEventListeners.size;
        }

        return count;
    }

    /**
     * Nastaví maximální počet posluchačů na jeden typ události
     *
     * @param n Maximální počet posluchačů
     */
    public setMaxListeners(n: number): void {
        this.maxListeners = n;
    }

    /**
     * Získá maximální počet posluchačů na jeden typ události
     *
     * @returns Maximální počet posluchačů
     */
    public getMaxListeners(): number {
        return this.maxListeners;
    }
}
</file>

<file path="src/event/index.ts">
// Export typů
export * from './types';

// Export hlavních tříd
export { EventEmitter } from './EventEmitter';

// Export utilit
export {
    combineListeners,
    createFilteredListener,
    createCountLimitedListener,
    createDebouncedListener,
    createThrottledListener,
    createAsyncListener
} from './utils';
</file>

<file path="src/event/TypedEventEmitter.ts">
import { EventEmitter } from './EventEmitter';

/**
 * Typově bezpečný EventEmitter
 * @template T Mapa typů eventů na jejich datové typy
 */
export class TypedEventEmitter<T extends Record<string, any>> {
    private emitter: EventEmitter;

    constructor(emitter: EventEmitter) { // Přijímá existující EventEmitter
        this.emitter = emitter;
    }

    public on<K extends keyof T>(event: K, listener: (data: T[K]) => void): void {
        this.emitter.on(event as string, listener);
    }

    public once<K extends keyof T>(event: K, listener: (data: T[K]) => void): void {
        this.emitter.once(event as string, listener);
    }

    public off<K extends keyof T>(event: K, listener: (data: T[K]) => void): void {
        this.emitter.off(event as string, listener);
    }

    public emit<K extends keyof T>(event: K, data: T[K]): void {
        this.emitter.emit(event as string, data);
    }

    public listenerCount<K extends keyof T>(event: K): number {
        return this.emitter.listenerCount(event as string);
    }

    public removeAllListeners<K extends keyof T>(event?: K): void {
        this.emitter.removeAllListeners(event as string | undefined);
    }

    public setMaxListeners(n: number): void {
        this.emitter.setMaxListeners(n);
    }

    public getUnderlyingEmitter(): EventEmitter {
        return this.emitter;
    }
}
</file>

<file path="src/event/types.ts">
/**
 * Typ pro callback funkci posluchače události
 * Přijímá data události (typ 'any' pro obecný emitter, specifický typ pro TypedEventEmitter)
 */
export type EventListener = (data: any) => void;

/**
 * Typ pro identifikátor události
 * Může být řetězec nebo symbol. Zde používáme string.
 */
export type GameEventType = string;

/**
 * Možnosti pro konfiguraci EventEmitter
 */
export interface EventEmitterOptions {
    /**
     * Zachytávat chyby v posluchačích událostí
     * Výchozí: true
     */
    catchErrors?: boolean;

    /**
     * Maximální počet posluchačů na jeden typ události
     * Výchozí: 10
     */
    maxListeners?: number;
}

/**
 * Data předávaná při události změny scény (patří spíše do scene/types nebo engine/types)
 */
export interface SceneChangedEventData {
    scene: any; // Mělo by být importováno z scene/types
    sceneKey: string; // Mělo by být SceneKey z scene/types
    previousScene?: any;
    previousSceneKey?: string;
    transitionData?: any;
}

/**
 * Data předávaná při události startu hry (patří spíše do engine/types)
 */
export interface GameStartedEventData {
    sceneKey: string; // Mělo by být SceneKey z scene/types
    transitionData?: any;
}

/**
 * Data předávaná při události konce hry (patří spíše do engine/types)
 */
export interface GameEndedEventData {
    reason?: string;
    stats?: Record<string, any>; // nebo specifický typ
}

/**
 * Data předávaná při události aplikace efektu (patří spíše do engine/types nebo effect/types)
 */
export interface EffectAppliedEventData {
    effect: any; // Mělo by být Effect z effect/types
    previousState: any; // Mělo by být GameState
    newState: any; // Mělo by být GameState
}
</file>

<file path="src/event/utils.ts">
import { EventEmitter } from './EventEmitter';
import { GameEventType, EventListener } from './types';

/**
 * Vytvoří funkci, která spojí více posluchačů do jednoho
 *
 * @param listeners Pole posluchačů k spojení
 * @returns Funkce, která volá všechny zadané posluchače
 */
export function combineListeners(listeners: EventListener[]): EventListener {
    return (data: any) => {
        for (const listener of listeners) {
            listener(data);
        }
    };
}

/**
 * Vytvoří předfiltrovaného posluchače, který se volá pouze pokud data splňují podmínku
 *
 * @param listener Původní posluchač
 * @param filter Funkce, která určuje, zda se posluchač zavolá
 * @returns Nový posluchač s filtrem
 */
export function createFilteredListener(
    listener: EventListener,
    filter: (data: any) => boolean
): EventListener {
    return (data: any) => {
        if (filter(data)) {
            listener(data);
        }
    };
}

/**
 * Vytvoří posluchače, který se automaticky odregistruje po N voláních
 *
 * @param emitter Instance EventEmitter
 * @param eventType Typ události
 * @param listener Původní posluchač
 * @param count Počet volání před odregistrací
 * @returns Nový posluchač, který se sám odregistruje
 */
export function createCountLimitedListener(
    emitter: EventEmitter,
    eventType: GameEventType,
    listener: EventListener,
    count: number
): EventListener {
    let callCount = 0;

    const wrappedListener: EventListener = (data: any) => {
        listener(data);
        callCount++;

        if (callCount >= count) {
            emitter.off(eventType, wrappedListener);
        }
    };

    return wrappedListener;
}

/**
 * Vytvoří debounced verzi posluchače, která se volá maximálně jednou za daný interval
 *
 * @param listener Původní posluchač
 * @param wait Čekací doba v milisekundách
 * @returns Debounced posluchač
 */
export function createDebouncedListener(
    listener: EventListener,
    wait: number
): EventListener {
    let timeout: any = null;

    return (data: any) => {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
            listener(data);
        }, wait);
    };
}

/**
 * Vytvoří throttled verzi posluchače, která se volá maximálně jednou za daný interval
 *
 * @param listener Původní posluchač
 * @param limit Minimální interval mezi voláními v milisekundách
 * @returns Throttled posluchač
 */
export function createThrottledListener(
    listener: EventListener,
    limit: number
): EventListener {
    let waiting = false;
    let lastData: any = null;

    return (data: any) => {
        if (!waiting) {
            listener(data);
            waiting = true;
            setTimeout(() => {
                waiting = false;
                if (lastData !== null) {
                    const currentData = lastData;
                    lastData = null;
                    listener(currentData);
                }
            }, limit);
        } else {
            lastData = data;
        }
    };
}

/**
 * Zabalí posluchače událostí tak, aby se vykonával asynchronně
 *
 * @param listener Původní posluchač
 * @returns Asynchronní posluchač
 */
export function createAsyncListener(listener: EventListener): EventListener {
    return (data: any) => {
        setTimeout(() => {
            listener(data);
        }, 0);
    };
}
</file>

<file path="src/plugin/AbstractPlugin.ts">
import { GameEngine } from '../engine/GameEngine';
import { Plugin, PluginOptions } from './types';
import { GenericContentLoader } from '../content/GenericContentLoader';
import { Effect, EffectProcessor } from '../effect/types';
import { GameState } from '../state/types'; // GameState zůstává ze state/types
import { GameEventType, EventListener } from '../event/types'; // Opravený import
import { SceneKey, SceneTransitionOptions } from '../scene/types'; // Přidán import SceneTransitionOptions

/**
 * Abstraktní základní třída pro pluginy
 */
export abstract class AbstractPlugin<Options extends PluginOptions = PluginOptions> implements Plugin {
    public readonly name: string;
    protected options: Options;
    protected engine: GameEngine | null = null;
    protected loaders: Map<string, GenericContentLoader<any>> = new Map();
    protected registeredEffects: Set<string> = new Set();
    private eventListeners: Map<GameEventType, Set<EventListener>> = new Map();

    constructor(name: string, options: Options) {
        this.name = name;
        this.options = options;
        this.setupLoaders();
    }

    protected setupLoaders(): void {
        // Přepište v potomkovi pro registraci specifických loaderů
    }

    public async initialize(engine: GameEngine): Promise<void> {
        this.engine = engine;

        this.loaders.forEach((loader, type) => {
            engine.getLoaderRegistry().registerLoader(type, loader);
        });

        await this.registerContent();
        this.registerEventHandlers();
        this.setupEffectProcessors(); // <-- Přejmenovaná metoda
        await this.onInitialize();
    }

    protected async registerContent(): Promise<void> {
        // Přepište v potomkovi pro registraci specifického obsahu
    }

    protected registerEventHandlers(): void {
        // Přepište v potomkovi pro registraci specifických posluchačů událostí
    }

    /**
     * Nastavuje (setup) procesory efektů specifické pro plugin.
     * Přepište tuto metodu pro registraci procesorů specifických pro plugin.
     * Uvnitř této metody můžete volat `this.registerEffectProcessors(...)` s mapou procesorů.
     */
    protected setupEffectProcessors(): void { // <-- PŘEJMENOVANÁ HOOK METODA
        // Přepište v potomkovi pro registraci specifických procesorů efektů
        // Příklad v potomkovi:
        // const myProcessors = { 'myEffect': (effect, state) => { ... } };
        // this.registerEffectProcessors(myProcessors);
    }


    protected async onInitialize(): Promise<void> {
        // Přepište v potomkovi pro logiku specifickou pro plugin
    }

    public async destroy(): Promise<void> {
        if (this.engine) {
            this.unregisterEventHandlers();
            this.unregisterEffectProcessors();
            await this.onDestroy();

            this.loaders.forEach((_, type) => {
                this.engine?.getLoaderRegistry().removeLoader(type);
            });
            this.engine = null;
        }
    }

    protected unregisterEventHandlers(): void {
        if (this.engine) {
            this.eventListeners.forEach((listeners, eventType) => {
                listeners.forEach(listener => {
                    // Použijeme obecný emitter pro odregistraci
                    this.engine?.getGenericEventEmitter().off(eventType, listener);
                });
            });
            this.eventListeners.clear();
        }
    }

    protected unregisterEffectProcessors(): void {
        if (this.engine) {
            this.engine.getEffectManager().unregisterNamespace(this.name);
            this.registeredEffects.clear();
        }
    }

    protected async onDestroy(): Promise<void> {
        // Přepište v potomkovi pro logiku čištění specifickou pro plugin
    }

    protected getState(): GameState | undefined {
        return this.engine?.getState();
    }

    protected getLoader<T extends object, K extends string = string>(type: string): GenericContentLoader<T, K> | undefined {
        return this.engine?.getLoaderRegistry().getLoader<T, K>(type);
    }

    private namespaceEffectType(effectType: string): string {
        // Jednoduchý check, zda už namespace obsahuje - pro případ volání s již namespacovaným typem
        return effectType.includes(':') ? effectType : `${this.name}:${effectType}`;
    }

    protected registerEffectProcessor(effectType: string, processor: EffectProcessor): void {
        if (this.engine) {
            const namespacedType = this.namespaceEffectType(effectType);
            // Registrace přes EffectManager s namespacovaným typem
            this.engine.getEffectManager().registerEffectProcessor(namespacedType, processor);
            this.registeredEffects.add(namespacedType); // Sledujeme namespacovaný typ
        }
    }

    /**
     * Registruje více procesorů efektů najednou s automatickým namespacingem.
     * Tuto metodu volejte z `setupEffectProcessors` nebo `onInitialize`.
     *
     * @param processors Objekt mapující typy efektů na procesory
     */
    protected registerEffectProcessors(processors: Record<string, EffectProcessor>): void { // <-- HELPER METODA ZŮSTÁVÁ
        if (!this.engine) return;

        const namespacedProcessors: Record<string, EffectProcessor> = {};
        for (const [type, processor] of Object.entries(processors)) {
            const namespacedType = this.namespaceEffectType(type);
            namespacedProcessors[namespacedType] = processor;
            this.registeredEffects.add(namespacedType);
        }
        // Registrace přes EffectManager
        this.engine.getEffectManager().registerEffectProcessors(namespacedProcessors);
    }


    protected emitNamespacedEvent(eventType: string, data?: any): void {
        if (this.engine) {
            const namespacedType = eventType.includes(':') ? eventType : `${this.name}:${eventType}`;
            // Použijeme obecný emit enginu
            this.engine.emit(namespacedType, data);
        }
    }

    protected registerEventListener(eventType: GameEventType, listener: EventListener): void {
        if (this.engine) {
            // Registrace přes obecný emitter enginu
            this.engine.getGenericEventEmitter().on(eventType, listener);
            if (!this.eventListeners.has(eventType)) {
                this.eventListeners.set(eventType, new Set());
            }
            this.eventListeners.get(eventType)!.add(listener);
        }
    }

    protected unregisterEventListener(eventType: GameEventType, listener: EventListener): void {
        if (this.engine) {
            // Odregistrace přes obecný emitter enginu
            this.engine.getGenericEventEmitter().off(eventType, listener);
            const listeners = this.eventListeners.get(eventType);
            if (listeners) {
                listeners.delete(listener);
                if (listeners.size === 0) {
                    this.eventListeners.delete(eventType);
                }
            }
        }
    }

    protected async transitionToScene(
        sceneKey: SceneKey,
        options?: SceneTransitionOptions // Použij importovaný typ
    ): Promise<boolean> {
        if (!this.engine) return false;
        return await this.engine.transitionToScene(sceneKey, options);
    }

    protected applyEffect(effect: Effect): void {
        if (!this.engine) return;
        this.engine.applyEffect(effect);
    }

    protected applyEffects(effects: Effect[]): void {
        if (!this.engine) return;
        this.engine.applyEffects(effects);
    }
}
</file>

<file path="src/plugin/index.ts">
// Export typů
export * from './types';

// Export hlavních tříd
export { PluginManager } from './PluginManager';
export { AbstractPlugin } from './AbstractPlugin';

// Export konstant
export const CORE_PLUGIN_EVENTS = {
    REGISTERED: 'plugin:registered',
    UNREGISTERED: 'plugin:unregistered',
    INITIALIZED: 'plugin:initialized',
    ERROR: 'plugin:error'
} as const;

// Export utilit
export {
    createPlugin,
    createCompositePlugin,
    createLazyPlugin,
    createConditionalPlugin,
    createVersionedPlugin,
    createDebouncedPlugin
} from './utils';
</file>

<file path="src/plugin/PluginManager.ts">
import { EventEmitter } from '../event/EventEmitter';
import {
  Plugin,
  PluginRegistryOptions,
  PluginEvents,
  PluginRegisteredEventData,
  PluginUnregisteredEventData,
  PluginInitializedEventData,
  PluginErrorEventData
} from './types';
import { GameEngine } from '../engine/GameEngine';

/**
 * Správce pluginů pro herní engine
 *
 * Zodpovídá za registraci, inicializaci a správu pluginů
 * připojených k hernímu enginu.
 */
export class PluginManager {
  /**
   * Reference na herní engine
   */
  private engine: GameEngine;

  /**
   * Mapa registrovaných pluginů podle názvu
   */
  private plugins: Map<string, Plugin> = new Map();

  /**
   * Množina aktivních (inicializovaných) pluginů
   */
  private activePlugins: Set<string> = new Set();

  /**
   * Event emitter pro události pluginů
   */
  private eventEmitter: EventEmitter;

  /**
   * Možnosti konfigurace manažeru pluginů
   */
  private options: PluginRegistryOptions;

  /**
   * Vytvoří novou instanci PluginManager
   *
   * @param engine Reference na herní engine
   * @param eventEmitter Event emitter pro události
   * @param options Možnosti konfigurace
   */
  constructor(
      engine: GameEngine,
      eventEmitter: EventEmitter,
      options: PluginRegistryOptions = {}
  ) {
    this.engine = engine;
    this.eventEmitter = eventEmitter;
    this.options = {
      autoActivate: true,
      allowOverride: false,
      ...options
    };
  }

  /**
   * Registruje plugin v herním enginu
   *
   * @param plugin Plugin k registraci
   * @param activate Zda aktivovat plugin ihned po registraci
   * @returns Promise který se vyřeší na true, pokud byl plugin úspěšně registrován
   */
  public async registerPlugin(
      plugin: Plugin,
      activate?: boolean
  ): Promise<boolean> {
    const shouldActivate = activate ?? this.options.autoActivate;

    // Kontrola, zda plugin s tímto názvem již existuje
    if (this.plugins.has(plugin.name) && !this.options.allowOverride) {
      console.warn(`Plugin with name '${plugin.name}' is already registered.`);
      return false;
    }

    // Registrace pluginu
    this.plugins.set(plugin.name, plugin);

    // Emitování události registrace
    this.eventEmitter.emit(PluginEvents.REGISTERED, {
      name: plugin.name,
      plugin
    } as PluginRegisteredEventData);

    // Aktivace pluginu, pokud je požadováno
    if (shouldActivate) {
      return await this.activatePlugin(plugin.name);
    }

    return true;
  }

  /**
   * Registruje více pluginů najednou
   *
   * @param plugins Pole pluginů k registraci
   * @param activate Zda aktivovat pluginy ihned po registraci
   * @returns Promise který se vyřeší na počet úspěšně registrovaných pluginů
   */
  public async registerPlugins(
      plugins: Plugin[],
      activate?: boolean
  ): Promise<number> {
    let successCount = 0;

    for (const plugin of plugins) {
      const success = await this.registerPlugin(plugin, activate);
      if (success) {
        successCount++;
      }
    }

    return successCount;
  }

  /**
   * Aktivuje registrovaný plugin
   *
   * @param pluginName Název pluginu k aktivaci
   * @returns Promise který se vyřeší na true, pokud byl plugin úspěšně aktivován
   */
  public async activatePlugin(pluginName: string): Promise<boolean> {
    const plugin = this.plugins.get(pluginName);

    if (!plugin) {
      console.warn(`Plugin with name '${pluginName}' is not registered.`);
      return false;
    }

    // Pokud je plugin již aktivní, vrátíme true
    if (this.activePlugins.has(pluginName)) {
      return true;
    }

    // Inicializace pluginu
    try {
      await Promise.resolve(plugin.initialize(this.engine));

      // Označení pluginu jako aktivního
      this.activePlugins.add(pluginName);

      // Emitování události inicializace
      this.eventEmitter.emit(PluginEvents.INITIALIZED, {
        name: pluginName,
        plugin
      } as PluginInitializedEventData);

      console.log(`Plugin '${pluginName}' successfully initialized.`);
      return true;
    } catch (error) {
      // Emitování události chyby
      this.eventEmitter.emit(PluginEvents.ERROR, {
        name: pluginName,
        plugin,
        error,
        phase: 'initialize'
      } as PluginErrorEventData);

      console.error(`Error initializing plugin '${pluginName}':`, error);
      return false;
    }
  }

  /**
   * Deaktivuje aktivní plugin
   *
   * @param pluginName Název pluginu k deaktivaci
   * @returns Promise který se vyřeší na true, pokud byl plugin úspěšně deaktivován
   */
  public async deactivatePlugin(pluginName: string): Promise<boolean> {
    const plugin = this.plugins.get(pluginName);

    if (!plugin) {
      console.warn(`Plugin with name '${pluginName}' is not registered.`);
      return false;
    }

    // Pokud plugin není aktivní, vrátíme true
    if (!this.activePlugins.has(pluginName)) {
      return true;
    }

    // Volání destroy metody pluginu, pokud existuje
    if (plugin.destroy) {
      try {
        await Promise.resolve(plugin.destroy());
      } catch (error) {
        // Emitování události chyby
        this.eventEmitter.emit(PluginEvents.ERROR, {
          name: pluginName,
          plugin,
          error,
          phase: 'destroy'
        } as PluginErrorEventData);

        console.error(`Error destroying plugin '${pluginName}':`, error);
        return false;
      }
    }

    // Odstranění pluginu ze seznamu aktivních
    this.activePlugins.delete(pluginName);

    return true;
  }

  /**
   * Odregistruje plugin z herního enginu
   *
   * @param pluginName Název pluginu k odregistrování
   * @returns Promise který se vyřeší na true, pokud byl plugin úspěšně odregistrován
   */
  public async unregisterPlugin(pluginName: string): Promise<boolean> {
    const plugin = this.plugins.get(pluginName);

    if (!plugin) {
      console.warn(`Plugin with name '${pluginName}' is not registered.`);
      return false;
    }

    // Nejprve deaktivujeme plugin, pokud je aktivní
    if (this.activePlugins.has(pluginName)) {
      const success = await this.deactivatePlugin(pluginName);
      if (!success) {
        return false;
      }
    }

    // Odregistrace pluginu
    this.plugins.delete(pluginName);

    // Emitování události odregistrace
    this.eventEmitter.emit(PluginEvents.UNREGISTERED, {
      name: pluginName
    } as PluginUnregisteredEventData);

    console.log(`Plugin '${pluginName}' successfully unregistered.`);
    return true;
  }

  /**
   * Získá plugin podle názvu
   *
   * @template T Typ očekávaného pluginu
   * @param pluginName Název pluginu
   * @returns Plugin daného typu nebo undefined pokud plugin nebyl nalezen
   */
  public getPlugin<T extends Plugin = Plugin>(pluginName: string): T | undefined {
    return this.plugins.get(pluginName) as T | undefined;
  }

  /**
   * Vrátí názvy všech registrovaných pluginů
   *
   * @returns Pole názvů registrovaných pluginů
   */
  public getPluginNames(): string[] {
    return Array.from(this.plugins.keys());
  }

  /**
   * Vrátí všechny registrované pluginy
   *
   * @returns Pole registrovaných pluginů
   */
  public getAllPlugins(): Plugin[] {
    return Array.from(this.plugins.values());
  }

  /**
   * Vrátí názvy všech aktivních pluginů
   *
   * @returns Pole názvů aktivních pluginů
   */
  public getActivePluginNames(): string[] {
    return Array.from(this.activePlugins);
  }

  /**
   * Vrátí všechny aktivní pluginy
   *
   * @returns Pole aktivních pluginů
   */
  public getActivePlugins(): Plugin[] {
    return Array.from(this.activePlugins).map(name => this.plugins.get(name)!);
  }

  /**
   * Kontroluje, zda je plugin registrován
   *
   * @param pluginName Název pluginu
   * @returns True pokud je plugin registrován, jinak false
   */
  public hasPlugin(pluginName: string): boolean {
    return this.plugins.has(pluginName);
  }

  /**
   * Kontroluje, zda je plugin aktivní
   *
   * @param pluginName Název pluginu
   * @returns True pokud je plugin aktivní, jinak false
   */
  public isPluginActive(pluginName: string): boolean {
    return this.activePlugins.has(pluginName);
  }

  /**
   * Vrátí počet registrovaných pluginů
   *
   * @returns Počet registrovaných pluginů
   */
  public getPluginCount(): number {
    return this.plugins.size;
  }

  /**
   * Vrátí počet aktivních pluginů
   *
   * @returns Počet aktivních pluginů
   */
  public getActivePluginCount(): number {
    return this.activePlugins.size;
  }

  /**
   * Deaktivuje všechny aktivní pluginy
   *
   * @returns Promise který se vyřeší, když jsou všechny pluginy deaktivovány
   */
  public async deactivateAllPlugins(): Promise<void> {
    const activePluginNames = Array.from(this.activePlugins);

    for (const pluginName of activePluginNames) {
      await this.deactivatePlugin(pluginName);
    }
  }

  /**
   * Nastaví novou instanci enginu pro všechny pluginy
   * Použije se například při resetování či restartování enginu
   *
   * @param engine Nová instance herního enginu
   */
  public setEngine(engine: GameEngine): void {
    this.engine = engine;

    // Reinicializace všech aktivních pluginů s novým enginem
    this.resetPlugins();
  }

  /**
   * Resetuje všechny aktivní pluginy
   * Deaktivuje všechny pluginy a znovu je aktivuje
   *
   * @returns Promise který se vyřeší na true, pokud byly všechny pluginy úspěšně resetovány
   */
  public async resetPlugins(): Promise<boolean> {
    const activePluginNames = Array.from(this.activePlugins);

    // Deaktivujeme všechny pluginy
    await this.deactivateAllPlugins();

    // Opět aktivujeme všechny pluginy, které byly aktivní
    let allSuccessful = true;
    for (const pluginName of activePluginNames) {
      const success = await this.activatePlugin(pluginName);
      if (!success) {
        allSuccessful = false;
      }
    }

    return allSuccessful;
  }
}
</file>

<file path="src/plugin/types.ts">
import { GameEngine } from '../engine/GameEngine';

/** Základní rozhraní pro plugin */
export interface Plugin {
  name: string;
  initialize: (engine: GameEngine) => Promise<void> | void;
  destroy?: () => Promise<void> | void;
}

/** Možnosti konfigurace pluginu */
export interface PluginOptions {
  [key: string]: any;
}

/** Možnosti pro registry pluginů */
export interface PluginRegistryOptions {
  autoActivate?: boolean;
  allowOverride?: boolean;
}

/** Události emitované systémem pluginů */
export enum PluginEvents {
  REGISTERED = 'plugin:registered',
  UNREGISTERED = 'plugin:unregistered',
  INITIALIZED = 'plugin:initialized',
  ERROR = 'plugin:error'
}

/** Data předávaná při události registrace pluginu */
export interface PluginRegisteredEventData {
  name: string;
  plugin: Plugin;
}

/** Data předávaná při události odregistrace pluginu */
export interface PluginUnregisteredEventData {
  name: string;
}

/** Data předávaná při události inicializace pluginu */
export interface PluginInitializedEventData {
  name: string;
  plugin: Plugin;
}

/** Data předávaná při události chyby pluginu */
export interface PluginErrorEventData {
  name: string;
  plugin: Plugin;
  error: Error | unknown; // Použij 'unknown' pro lepší typování chyb
  phase: 'initialize' | 'destroy' | string; // Fáze může být i jiná
}

/** Mapa událostí pro systém pluginů */
export type PluginEventMap = {
  [PluginEvents.REGISTERED]: PluginRegisteredEventData;
  [PluginEvents.UNREGISTERED]: PluginUnregisteredEventData;
  [PluginEvents.INITIALIZED]: PluginInitializedEventData;
  [PluginEvents.ERROR]: PluginErrorEventData;
};
</file>

<file path="src/plugin/utils.ts">
import { Plugin, PluginOptions } from './types';
import { AbstractPlugin } from './AbstractPlugin';
import { GameEngine } from '../engine/GameEngine';

/**
 * Vytvoří jednoduchý plugin pomocí konfigurační funkce
 *
 * @param name Název pluginu
 * @param configureFn Funkce pro konfiguraci pluginu
 * @param options Volitelné možnosti konfigurace
 * @returns Nová instance pluginu
 */
export function createPlugin(
    name: string,
    configureFn: (engine: GameEngine, options: PluginOptions) => void | Promise<void>,
    options: PluginOptions = {}
): Plugin {
    class SimplePlugin extends AbstractPlugin {
        constructor() {
            super(name, options);
        }

        protected async onInitialize(): Promise<void> {
            if (this.engine) {
                await Promise.resolve(configureFn(this.engine, this.options));
            }
        }
    }

    return new SimplePlugin();
}

/**
 * Vytvoří kompozitní plugin z více pluginů
 *
 * @param name Název kompozitního pluginu
 * @param plugins Pole pluginů k zahrnutí
 * @param options Volitelné možnosti konfigurace
 * @returns Nová instance kompozitního pluginu
 */
export function createCompositePlugin(
    name: string,
    plugins: Plugin[],
    options: PluginOptions = {}
): Plugin {
    class CompositePlugin extends AbstractPlugin {
        private childPlugins: Plugin[] = [];

        constructor() {
            super(name, options);
            this.childPlugins = [...plugins];
        }

        protected async onInitialize(): Promise<void> {
            // Inicializace všech podřízených pluginů
            for (const plugin of this.childPlugins) {
                if (this.engine) {
                    await plugin.initialize(this.engine);
                }
            }
        }

        protected async onDestroy(): Promise<void> {
            // Čištění všech podřízených pluginů
            for (const plugin of this.childPlugins) {
                if (plugin.destroy) {
                    await plugin.destroy();
                }
            }
        }
    }

    return new CompositePlugin();
}

/**
 * Vytvoří plugin s možností načtení až při inicializaci (lazy loading)
 *
 * @param name Název pluginu
 * @param pluginFactory Funkce, která vrátí plugin nebo jeho Promise
 * @returns Nová instance lazy-loaded pluginu
 */
export function createLazyPlugin(
    name: string,
    pluginFactory: () => Plugin | Promise<Plugin>
): Plugin {
    class LazyPlugin implements Plugin {
        private innerPlugin: Plugin | null = null;
        public readonly name: string;

        constructor() {
            this.name = name;
        }

        public async initialize(engine: GameEngine): Promise<void> {
            // Načtení pluginu při první inicializaci
            this.innerPlugin = await Promise.resolve(pluginFactory());

            // Inicializace načteného pluginu
            await this.innerPlugin.initialize(engine);
        }

        public async destroy(): Promise<void> {
            // Čištění načteného pluginu
            if (this.innerPlugin && this.innerPlugin.destroy) {
                await this.innerPlugin.destroy();
            }
            this.innerPlugin = null;
        }
    }

    return new LazyPlugin();
}

/**
 * Vytvoří podmíněný plugin, který se inicializuje pouze pokud je splněna podmínka
 *
 * @param plugin Základní plugin
 * @param condition Funkce, která určuje, zda se plugin inicializuje
 * @returns Nová instance podmíněného pluginu
 */
export function createConditionalPlugin(
    plugin: Plugin,
    condition: (engine: GameEngine) => boolean | Promise<boolean>
): Plugin {
    class ConditionalPlugin implements Plugin {
        private initialized = false;
        public readonly name: string;

        constructor() {
            this.name = `conditional:${plugin.name}`;
        }

        public async initialize(engine: GameEngine): Promise<void> {
            // Kontrola podmínky
            const shouldInitialize = await Promise.resolve(condition(engine));

            if (shouldInitialize) {
                await plugin.initialize(engine);
                this.initialized = true;
            }
        }

        public async destroy(): Promise<void> {
            if (this.initialized && plugin.destroy) {
                await plugin.destroy();
                this.initialized = false;
            }
        }
    }

    return new ConditionalPlugin();
}

/**
 * Vytvoří verzovaný plugin s kontrolou kompatibility
 *
 * @param plugin Základní plugin
 * @param version Verze pluginu
 * @param compatibilityCheck Funkce pro kontrolu kompatibility
 * @returns Nová instance verzovaného pluginu
 */
export function createVersionedPlugin(
    plugin: Plugin,
    version: string,
    compatibilityCheck: (engineVersion: string) => boolean
): Plugin {
    class VersionedPlugin implements Plugin {
        public readonly name: string;
        public readonly version: string;

        constructor() {
            this.name = plugin.name;
            this.version = version;
        }

        public async initialize(engine: GameEngine): Promise<void> {
            // Kontrola kompatibility s enginem
            const engineVersion = engine.getVersion();
            if (!compatibilityCheck(engineVersion)) {
                throw new Error(
                    `Plugin '${this.name}' version ${this.version} is not compatible with engine version ${engineVersion}.`
                );
            }

            await plugin.initialize(engine);
        }

        public async destroy(): Promise<void> {
            if (plugin.destroy) {
                await plugin.destroy();
            }
        }
    }

    return new VersionedPlugin();
}

/**
 * Vytvoří debounced verzi pluginu, který odloží inicializaci
 * Užitečné pro optimalizaci při hromadné registraci více pluginů
 *
 * @param plugin Základní plugin
 * @param delay Zpoždění inicializace v ms
 * @returns Nová instance pluginu s odloženou inicializací
 */
export function createDebouncedPlugin(
    plugin: Plugin,
    delay: number = 100
): Plugin {
    class DebouncedPlugin implements Plugin {
        private engine: GameEngine | null = null;
        private initTimeout: any = null;
        private initialized = false;
        public readonly name: string;

        constructor() {
            this.name = `debounced:${plugin.name}`;
        }

        public async initialize(engine: GameEngine): Promise<void> {
            this.engine = engine;

            // Zrušení předchozího timeoutu, pokud existuje
            if (this.initTimeout) {
                clearTimeout(this.initTimeout);
            }

            // Odložení inicializace
            return new Promise<void>((resolve) => {
                this.initTimeout = setTimeout(async () => {
                    await plugin.initialize(engine);
                    this.initialized = true;
                    resolve();
                }, delay);
            });
        }

        public async destroy(): Promise<void> {
            // Zrušení timeoutu, pokud inicializace ještě neproběhla
            if (this.initTimeout) {
                clearTimeout(this.initTimeout);
                this.initTimeout = null;
            }

            if (this.initialized && plugin.destroy) {
                await plugin.destroy();
                this.initialized = false;
            }

            this.engine = null;
        }
    }

    return new DebouncedPlugin();
}
</file>

<file path="src/save/index.ts">
// Export typů
export * from './types';

// Export hlavních tříd
export { SaveManager } from './SaveManager';
export { MemoryStorage } from './MemoryStorage';

// Export utilit
export {
    createSaveManager,
    validateSaveData,
    generateSaveId,
    formatPlayTime,
    exportSaveToFile,
    importSaveFromFile
} from './utils';
</file>

<file path="src/save/MemoryStorage.ts">
import { SaveData, SaveMetadata, SaveStorage } from './types';

/**
 * In-memory implementace SaveStorage
 * Používá se hlavně pro testování nebo pro dočasné ukládání
 */
export class MemoryStorage implements SaveStorage {
    /**
     * Mapa uložených her (ID -> data)
     */
    private saves: Map<string, SaveData> = new Map();

    /**
     * Uloží data do paměti
     *
     * @param id Identifikátor uložené hry
     * @param data Data k uložení
     * @returns Promise rozhodnutý na true
     */
    public async save(id: string, data: SaveData): Promise<boolean> {
        this.saves.set(id, { ...data });
        return true;
    }

    /**
     * Načte data z paměti
     *
     * @param id Identifikátor uložené hry
     * @returns Promise rozhodnutý na data, nebo null pokud neexistují
     */
    public async load(id: string): Promise<SaveData | null> {
        const save = this.saves.get(id);
        return save ? { ...save } : null;
    }

    /**
     * Vrátí seznam všech uložených her
     *
     * @returns Promise rozhodnutý na objekt mapující ID na metadata
     */
    public async list(): Promise<Record<string, SaveMetadata>> {
        const result: Record<string, SaveMetadata> = {};
        for (const [id, data] of this.saves.entries()) {
            result[id] = { ...data.metadata };
        }
        return result;
    }

    /**
     * Smaže uloženou hru
     *
     * @param id Identifikátor uložené hry
     * @returns Promise rozhodnutý na true, pokud byla hra smazána
     */
    public async delete(id: string): Promise<boolean> {
        return this.saves.delete(id);
    }

    /**
     * Zkontroluje, zda existuje uložená hra
     *
     * @param id Identifikátor uložené hry
     * @returns Promise rozhodnutý na true, pokud hra existuje
     */
    public async exists(id: string): Promise<boolean> {
        return this.saves.has(id);
    }

    /**
     * Vymaže všechna uložení
     *
     * @returns Promise rozhodnutý na true
     */
    public async clearAll(): Promise<boolean> {
        this.saves.clear();
        return true;
    }

    /**
     * Vrátí počet uložených her
     *
     * @returns Počet uložených her
     */
    public getCount(): number {
        return this.saves.size;
    }
}
</file>

<file path="src/save/SaveManager.ts">
import {
    SaveData,
    SaveMetadata,
    SaveOptions,
    SaveStorage,
    AutoSaveOptions,
    SaveEvents,
    SaveEventMap, // Import mapy událostí
    GameSavedEventData,
    GameLoadedEventData,
    GameDeletedEventData,
    AllSavesClearedEventData,
    StorageChangedEventData,
    AutoSaveEnabledEventData,
    AutoSaveDisabledEventData
} from './types';
import { GameEngine } from '../engine/GameEngine';
// EventEmitter a TypedEventEmitter už by neměly být potřeba přímo zde
// import { EventEmitter } from '../event/EventEmitter';
// import { TypedEventEmitter } from '../event/TypedEventEmmitter';
import { SceneKey } from '../scene/types';
import { GameStateManager } from '../state/GameStateManager';
import { StateConverter } from '../state/persistence/StateConverter';
import { StateMigrationService } from '../state/persistence/StateMigrationService';
import { PersistedState, StateManagerPersistenceEvents } from '../state/persistence/types';

const CURRENT_SAVE_DATA_FORMAT_VERSION = 1;

/**
 * Správce ukládání a načítání her
 * @template T Typ proměnných ve stavu hry
 */
export class SaveManager<T extends Record<string, unknown> = Record<string, unknown>> {
    private engine: GameEngine;
    private storage: SaveStorage;
    private readonly saveDataFormatVersion: number;
    private readonly engineVersion: string;
    private autoSaveTimer: ReturnType<typeof setInterval> | null = null; // Použij správný typ
    private autoSaveOptions: AutoSaveOptions | null = null;
    private autoSaveCounter: number = 0;
    private gameStartTime: number;
    private totalPlayTime: number = 0;
    private readonly quickSaveId: string = 'quicksave';
    private stateConverter: typeof StateConverter; // Statické reference
    private stateMigrationService: typeof StateMigrationService; // Statické reference

    constructor(engine: GameEngine, options: {
        storage: SaveStorage;
        engineVersion?: string;
        saveDataFormatVersion?: number;
        // eventEmitter?: EventEmitter; // Už není potřeba předávat emitter
        stateConverter?: typeof StateConverter;
        stateMigrationService?: typeof StateMigrationService;
    }) {
        this.engine = engine;
        this.storage = options.storage;
        this.engineVersion = options.engineVersion || (typeof engine.getVersion === 'function' ? engine.getVersion() : '0.1.0');
        this.saveDataFormatVersion = options.saveDataFormatVersion || CURRENT_SAVE_DATA_FORMAT_VERSION;
        this.gameStartTime = Date.now();
        this.stateConverter = options.stateConverter || StateConverter;
        this.stateMigrationService = options.stateMigrationService || StateMigrationService;
        this.setupEventListeners();
    }

    private setupEventListeners(): void {
        // Naslouchání na core události z enginu
        this.engine.getCoreEventEmitter().on('gameStarted', () => {
            console.log("SaveManager: Game started event received. Resetting play time.");
            this.gameStartTime = Date.now();
            this.totalPlayTime = 0;
        });

        // Naslouchání na save události (emitované SaveManagerem samotným přes engine)
        this.engine.getSaveEventEmitter().on(SaveEvents.GAME_LOADED, (data) => { // Typ dat je z SaveEventMap
            if (data.success) {
                console.log("SaveManager: Game loaded event received. Setting play time from metadata and resetting start time.");
                this.gameStartTime = Date.now();
            }
        });
    }

    public async save(saveId: string, options: SaveOptions = {}): Promise<boolean> {
        // Odstraněna kontrola `typeof saveId !== 'string'`
        if (!saveId) {
            console.error("SaveManager: Invalid save ID provided (empty string).", saveId);
            const errorData: GameSavedEventData = { saveId, success: false, error: 'invalid id' };
            this.engine.getSaveEventEmitter().emit(SaveEvents.GAME_SAVED, errorData);
            return false;
        }

        this.updatePlayTime();
        const gameStateManager = this.engine.getStateManager<T>();
        const currentState = gameStateManager.getState();
        const persistentKeys = gameStateManager.getPersistentKeys();

        const metadata: SaveMetadata = {
            id: saveId, // ID by mělo být nastaveno zde, ne přepsáno z options níže
            name: options.name || this.generateDefaultSaveName(),
            createdAt: Date.now(),
            updatedAt: Date.now(),
            playTime: this.totalPlayTime,
            engineVersion: this.engineVersion,
            // Opravené názvy verzí podle SaveMetadata
            saveDataFormatVersion: this.saveDataFormatVersion,
            stateFormatVersion: this.stateMigrationService.getCurrentStateFormatVersion(),
            currentSceneKey: this.engine.getCurrentSceneKey(),
            // Zkopírujeme POUZE bezpečné vlastnosti z options
            thumbnail: options.thumbnail,
            // Můžete přidat další povolené klíče z options
            ...(options.customData && { customData: options.customData }) // Příklad pro vlastní data
        };

        let serializedState: string;
        try {
            // Získání typovaného emitteru pro persistenci z enginu
            const persistenceEmitter = this.engine.getPersistenceEventEmitter<T>();
            serializedState = this.stateConverter.serialize(
                currentState,
                persistentKeys,
                { includeMetadata: true, replacer: options.replacer },
                gameStateManager.getOnBeforeSerializeCallback(),
                persistenceEmitter // <-- Předání bez přetypování
            );
        } catch (error) {
            console.error(`SaveManager: Failed to serialize game state for save id '${saveId}':`, error);
            const errorData: GameSavedEventData = { saveId, metadata, success: false, error };
            this.engine.getSaveEventEmitter().emit(SaveEvents.GAME_SAVED, errorData);
            return false;
        }

        const saveData: SaveData = { metadata, state: serializedState };

        try {
            const success = await this.storage.save(saveId, saveData);
            const eventData: GameSavedEventData = { saveId, metadata, success, error: success ? undefined : 'storage failed' };
            this.engine.getSaveEventEmitter().emit(SaveEvents.GAME_SAVED, eventData);
            return success;
        } catch (error) {
            console.error(`SaveManager: Failed to save game to storage for id '${saveId}':`, error);
            const errorData: GameSavedEventData = { saveId, metadata, success: false, error };
            this.engine.getSaveEventEmitter().emit(SaveEvents.GAME_SAVED, errorData);
            return false;
        }
    }

    public async load(saveId: string): Promise<boolean> {
        if (!saveId) { // Pouze kontrola na prázdný řetězec
            console.error("SaveManager: Invalid save ID provided for loading.", saveId);
            const errorData: GameLoadedEventData = { saveId, success: false, error: 'invalid id' };
            this.engine.getSaveEventEmitter().emit(SaveEvents.GAME_LOADED, errorData);
            return false;
        }

        let saveData: SaveData | null;
        try {
            saveData = await this.storage.load(saveId);
        } catch (error) {
            console.error(`SaveManager: Failed to load data from storage for id '${saveId}':`, error);
            const errorData: GameLoadedEventData = { saveId, success: false, error };
            this.engine.getSaveEventEmitter().emit(SaveEvents.GAME_LOADED, errorData);
            return false;
        }

        if (!saveData) {
            console.error(`SaveManager: Save with id '${saveId}' not found in storage.`);
            const errorData: GameLoadedEventData = { saveId, success: false, error: 'not found' };
            this.engine.getSaveEventEmitter().emit(SaveEvents.GAME_LOADED, errorData);
            return false;
        }

        // Validace a migrace SaveData formátu
        let migratedSaveData = this.migrateSaveDataFormatIfNeeded(saveData);
        if (!migratedSaveData) {
            console.error(`SaveManager: Failed to migrate SaveData format for id '${saveId}'.`);
            const errorData: GameLoadedEventData = { saveId, success: false, error: 'SaveData format migration failed' };
            this.engine.getSaveEventEmitter().emit(SaveEvents.GAME_LOADED, errorData);
            return false;
        }
        saveData = migratedSaveData;

        try {
            const gameStateManager = this.engine.getStateManager<T>();
            // Získání typovaného emitteru pro persistenci z enginu
            const persistenceEmitter = this.engine.getPersistenceEventEmitter<T>();

            const migratedPersistedState = this.stateConverter.deserialize<T>(
                saveData.state,
                {},
                undefined, // Callback se volá v GameStateManageru
                persistenceEmitter // <-- Předání bez přetypování
            );

            // GameStateManager.applyPersistentState nyní volá onAfterDeserialize callback
            gameStateManager.applyPersistentState(migratedPersistedState, 'loadGame');

            this.totalPlayTime = saveData.metadata.playTime || 0;
            // this.gameStartTime = Date.now(); // Toto se děje v listeneru

            const currentSceneKey = saveData.metadata.currentSceneKey;
            if (currentSceneKey) {
                // Použijeme engine pro přechod, ne voláme metodu SceneManageru přímo
                await this.engine.transitionToScene(currentSceneKey as SceneKey, {
                    // data: saveData.metadata.customData // Příklad předání custom dat
                });
            } else {
                console.warn(`SaveManager: Save data for id '${saveId}' does not contain current scene key.`);
            }

            console.log(`SaveManager: Game loaded successfully with id '${saveId}'.`);
            const eventData: GameLoadedEventData = { saveId, metadata: saveData.metadata, success: true };
            this.engine.getSaveEventEmitter().emit(SaveEvents.GAME_LOADED, eventData);
            return true;

        } catch (error) {
            console.error(`SaveManager: Failed to process and apply loaded state for id '${saveId}':`, error);
            const errorData: GameLoadedEventData = { saveId, success: false, error };
            this.engine.getSaveEventEmitter().emit(SaveEvents.GAME_LOADED, errorData);
            return false;
        }
    }

    public async getSaves(): Promise<Record<string, SaveMetadata>> {
        try {
            return await this.storage.list();
        } catch (error) {
            console.error("SaveManager: Failed to list saves from storage:", error);
            return {};
        }
    }

    public async deleteSave(saveId: string): Promise<boolean> {
        if (!saveId) {
            console.error("SaveManager: Invalid save ID provided for deletion.", saveId);
            const errorData: GameDeletedEventData = { saveId, success: false, error: 'invalid id' };
            this.engine.getSaveEventEmitter().emit(SaveEvents.GAME_DELETED, errorData);
            return false;
        }
        try {
            const success = await this.storage.delete(saveId);
            const eventData: GameDeletedEventData = { saveId, success, error: success ? undefined : 'storage failed or not found' };
            this.engine.getSaveEventEmitter().emit(SaveEvents.GAME_DELETED, eventData);
            return success;
        } catch (error) {
            console.error(`SaveManager: Failed to delete game with id '${saveId}' from storage:`, error);
            const errorData: GameDeletedEventData = { saveId, success: false, error };
            this.engine.getSaveEventEmitter().emit(SaveEvents.GAME_DELETED, errorData);
            return false;
        }
    }

    public async quickSave(): Promise<boolean> {
        console.log("SaveManager: Performing quick save...");
        return await this.save(this.quickSaveId, {
            name: 'Rychlé uložení',
            isQuickSave: true // Příklad custom data v metadatech
        });
    }

    public async quickLoad(): Promise<boolean> {
        console.log("SaveManager: Attempting quick load...");
        try {
            const exists = await this.storage.exists(this.quickSaveId);
            if (!exists) {
                console.warn('SaveManager: No quicksave found to load.');
                // Neemitujeme GAME_LOADED error zde, load() to udělá, pokud je voláno
                return false;
            }
            return await this.load(this.quickSaveId);
        } catch (error) {
            console.error("SaveManager: Failed to check existence or load quicksave:", error);
            // Emit error? load() by měl emitovat chybu, pokud selže
            return false;
        }
    }

    public enableAutoSave(options: AutoSaveOptions = {}): void {
        this.disableAutoSave();
        const interval = options.interval || 5 * 60 * 1000;
        const slots = options.slots || 3;
        if (interval <= 0 || slots <= 0 || !Number.isInteger(slots)) {
            console.error("SaveManager: Invalid auto-save interval or slots.");
            return;
        }

        this.autoSaveOptions = {
            interval,
            slots,
            prefix: options.prefix || 'auto',
            beforeSave: options.beforeSave,
            afterSave: options.afterSave
        };

        this.autoSaveTimer = setInterval(() => {
            this.performAutoSave().catch(error => {
                console.error("SaveManager: Uncaught error during auto-save execution:", error);
            });
        }, this.autoSaveOptions.interval);

        console.log(`SaveManager: Auto-save enabled with interval ${interval}ms and ${slots} slots.`);
        const eventData: AutoSaveEnabledEventData = { options: this.autoSaveOptions };
        this.engine.getSaveEventEmitter().emit(SaveEvents.AUTO_SAVE_ENABLED, eventData);
    }

    public disableAutoSave(): void {
        if (this.autoSaveTimer !== null) {
            clearInterval(this.autoSaveTimer);
            this.autoSaveTimer = null;
            this.autoSaveOptions = null;
            this.autoSaveCounter = 0;
            console.log("SaveManager: Auto-save disabled.");
            const eventData: AutoSaveDisabledEventData = {};
            this.engine.getSaveEventEmitter().emit(SaveEvents.AUTO_SAVE_DISABLED, eventData);
        }
    }

    private async performAutoSave(): Promise<boolean> {
        if (!this.autoSaveOptions || this.autoSaveTimer === null) return false;

        if (this.autoSaveOptions.beforeSave) {
            try {
                const shouldSave = await Promise.resolve(this.autoSaveOptions.beforeSave());
                if (!shouldSave) {
                    console.log("SaveManager: Auto-save skipped by beforeSave callback.");
                    return false;
                }
            } catch (error) {
                console.error("SaveManager: Error in auto-save beforeSave callback:", error);
                return false;
            }
        }

        const autoSaveSlotIndex = this.autoSaveCounter % this.autoSaveOptions.slots;
        this.autoSaveCounter++;
        const saveId = `${this.autoSaveOptions.prefix}_${autoSaveSlotIndex}`;
        const saveName = `Automatické uložení ${autoSaveSlotIndex + 1}`;

        console.log(`SaveManager: Performing auto-save to slot ${autoSaveSlotIndex + 1} (id: ${saveId}).`);
        const success = await this.save(saveId, {
            name: saveName,
            isAutoSave: true, // Příklad custom data
            autoSaveSlot: autoSaveSlotIndex + 1 // Příklad custom data
        });

        if (success && this.autoSaveOptions.afterSave) {
            try {
                await Promise.resolve(this.autoSaveOptions.afterSave(saveId));
            } catch (error) {
                console.error("SaveManager: Error in auto-save afterSave callback:", error);
            }
        }
        return success;
    }

    private generateDefaultSaveName(): string {
        const now = new Date();
        const dateOptions: Intl.DateTimeFormatOptions = { year: 'numeric', month: '2-digit', day: '2-digit' };
        const timeOptions: Intl.DateTimeFormatOptions = { hour: '2-digit', minute: '2-digit', second: '2-digit' };
        const dateStr = now.toLocaleDateString(undefined, dateOptions);
        const timeStr = now.toLocaleTimeString(undefined, timeOptions);
        const sceneTitle = this.engine.getCurrentScene()?.title || 'Neznámá scéna';
        return `${sceneTitle} - ${dateStr} ${timeStr}`;
    }

    private updatePlayTime(): void {
        const now = Date.now();
        if (this.gameStartTime) { // Přidána kontrola pro jistotu
            this.totalPlayTime += now - this.gameStartTime;
        }
        this.gameStartTime = now;
    }

    /**
     * Migruje formát SaveData objektu (metadata atd.), NE formát stavu.
     * @param saveData Data k migraci.
     * @returns Migrovaná data nebo null při selhání.
     */
    private migrateSaveDataFormatIfNeeded(saveData: SaveData): SaveData | null {
        let currentSaveData = { ...saveData }; // Pracujeme s kopií

        if (!currentSaveData.metadata) {
            console.error("SaveManager: Cannot migrate SaveData missing metadata.");
            return null;
        }

        // Získání nebo inicializace verze SaveData formátu
        let currentFormatVersion = typeof currentSaveData.metadata.saveDataFormatVersion === 'number'
            ? currentSaveData.metadata.saveDataFormatVersion
            : 0; // Předpokládáme verzi 0, pokud chybí

        // Pokud je verze nižší než aktuální cílová verze SaveData formátu
        if (currentFormatVersion < this.saveDataFormatVersion) {
            console.log(`SaveManager: Migrating SaveData format for id '${currentSaveData.metadata.id}' from version ${currentFormatVersion} to ${this.saveDataFormatVersion}.`);

            // Migrace z 0 na 1 (Příklad: přejmenování saveVersion na stateFormatVersion, přidání saveDataFormatVersion)
            if (currentFormatVersion === 0 && this.saveDataFormatVersion >= 1) {
                // Přejmenování/přesun 'saveVersion' (pokud existovala a znamenala verzi stavu) na 'stateFormatVersion'
                if (typeof (currentSaveData.metadata as any).saveVersion === 'number' && typeof currentSaveData.metadata.stateFormatVersion !== 'number') {
                    currentSaveData.metadata.stateFormatVersion = (currentSaveData.metadata as any).saveVersion;
                    console.log(`SaveManager: Migrated old 'saveVersion' field to 'stateFormatVersion' in SaveData metadata.`);
                }
                delete (currentSaveData.metadata as any).saveVersion; // Odstranění starého pole

                // Nastavení saveDataFormatVersion na 1
                currentSaveData.metadata.saveDataFormatVersion = 1;
                currentFormatVersion = 1; // Aktualizace pro další případné migrace
                console.log(`SaveManager: Applied SaveData format migration from 0 to 1.`);
            }

            // Zde přidat další migrační kroky pro SaveData formát (např. 1 -> 2)
            // if (currentFormatVersion === 1 && this.saveDataFormatVersion >= 2) {
            //     // ... logika migrace SaveData formátu 1 -> 2 ...
            //     currentSaveData.metadata.saveDataFormatVersion = 2;
            //     currentFormatVersion = 2;
            //     console.log(`SaveManager: Applied SaveData format migration from 1 to 2.`);
            // }

            // Kontrola, zda migrace dosáhla cílové verze
            if (currentFormatVersion !== this.saveDataFormatVersion) {
                console.warn(`SaveManager: Could not fully migrate SaveData format to target version ${this.saveDataFormatVersion}. Current version after migration: ${currentFormatVersion}.`);
                // Můžete se rozhodnout vrátit null nebo částečně migrovaná data
            }
        }

        // Zajistíme, že stateFormatVersion existuje (pro stará uložení bez něj)
        if (typeof currentSaveData.metadata.stateFormatVersion !== 'number') {
            console.warn(`SaveManager: SaveData metadata for id '${currentSaveData.metadata.id}' missing 'stateFormatVersion'. Assuming version 0.`);
            currentSaveData.metadata.stateFormatVersion = 0;
        }


        return currentSaveData;
    }


    public getPlayTime(): number {
        return this.totalPlayTime + (Date.now() - (this.gameStartTime || Date.now())); // Přidána fallback hodnota pro gameStartTime
    }

    public formatPlayTime(timeMs?: number): string {
        // Použijeme utilitu z utils
        const time = timeMs !== undefined ? timeMs : this.getPlayTime();
        // return formatPlayTimeUtil(time); // Předpokládá existenci formatPlayTimeUtil v utils
        // Dočasná implementace:
        const seconds = Math.floor((time / 1000) % 60);
        const minutes = Math.floor((time / (1000 * 60)) % 60);
        const hours = Math.floor(time / (1000 * 60 * 60));
        return [
            hours.toString().padStart(2, '0'),
            minutes.toString().padStart(2, '0'),
            seconds.toString().padStart(2, '0')
        ].join(':');
    }

    public async clearAllSaves(): Promise<boolean> {
        console.log("SaveManager: Attempting to clear all saves...");
        try {
            let success = false;
            if (typeof this.storage.clearAll === 'function') {
                success = await this.storage.clearAll();
            } else {
                console.warn("SaveManager: Storage does not implement clearAll. Deleting saves individually.");
                const saves = await this.getSaves();
                const saveIds = Object.keys(saves);
                if (saveIds.length === 0) {
                    success = true; // Nic ke smazání
                } else {
                    const results = await Promise.all(saveIds.map(id => this.deleteSave(id)));
                    success = results.every(result => result);
                }
            }

            console.log(`SaveManager: Clear all saves ${success ? 'successful' : 'failed'}.`);
            const eventData: AllSavesClearedEventData = { success, error: success ? undefined : 'clear failed' };
            this.engine.getSaveEventEmitter().emit(SaveEvents.ALL_SAVES_CLEARED, eventData);
            return success;

        } catch (error) {
            console.error("SaveManager: Failed to clear all saves:", error);
            const eventData: AllSavesClearedEventData = { success: false, error };
            this.engine.getSaveEventEmitter().emit(SaveEvents.ALL_SAVES_CLEARED, eventData);
            return false;
        }
    }

    public getStorage(): SaveStorage {
        return this.storage;
    }

    public setStorage(storage: SaveStorage): void {
        this.storage = storage;
        console.log("SaveManager: Storage changed.");
        const eventData: StorageChangedEventData = { storage };
        this.engine.getSaveEventEmitter().emit(SaveEvents.STORAGE_CHANGED, eventData);
    }

    public getSaveDataFormatVersion(): number {
        return this.saveDataFormatVersion;
    }

    public getStateFormatVersion(): number {
        return this.stateMigrationService.getCurrentStateFormatVersion();
    }
}
</file>

<file path="src/save/types.ts">
/**
 * Metadata uložené hry
 * Obsahuje informace o uložené hře bez herního stavu samotného
 */
export interface SaveMetadata {
    /** Unikátní identifikátor uložené hry */
    id: string;
    /** Název nebo popis uložené hry */
    name: string;
    /** Časové razítko vytvoření uložené hry */
    createdAt: number;
    /** Časové razítko poslední aktualizace uložené hry */
    updatedAt: number;
    /** Celkový čas strávený hrou v milisekundách */
    playTime: number;
    /** Verze enginu, ve které byla hra uložena */
    engineVersion: string;

    /** Verze formátu struktury uložených dat (SaveData). */
    saveDataFormatVersion: number; // <--- Přidáno/Přejmenováno

    /** Verze formátu herního stavu (pro migraci stavu). */
    stateFormatVersion: number; // <--- Přidáno/Přejmenováno

    /** Klíč aktuální scény v době uložení */
    currentSceneKey: string | null;
    /** Thumbnail nebo obrázek reprezentující uloženou hru (volitelné) */
    thumbnail?: string;
    /** Další vlastnosti specifické pro konkrétní hru nebo implementaci úložiště */
    [key: string]: any;
}

/**
 * Reprezentace uložené hry včetně herního stavu
 */
export interface SaveData {
    /** Metadata o uložené hře */
    metadata: SaveMetadata;
    /** Serializovaný herní stav */
    state: string;
    /** Volitelné dodatečné údaje specifické pro implementaci úložiště */
    [key: string]: any;
}

/**
 * Možnosti pro vytvoření nové uložené hry
 */
export interface SaveOptions {
    /** Název nebo popis uložené hry (volitelné) */
    name?: string;
    /** Thumbnail nebo obrázek reprezentující uloženou hru (volitelné) */
    thumbnail?: string;
    /** Další možnosti specifické pro implementaci úložiště */
    [key: string]: any;
}

/**
 * Nastavení pro automatické ukládání
 */
export interface AutoSaveOptions {
    /** Interval v milisekundách mezi automatickými uloženími */
    interval?: number;
    /** Maximální počet automatických uložení */
    slots?: number;
    /** Prefix pro názvy automatických uložení */
    prefix?: string;
    /** Callback volaný před automatickým uložením */
    beforeSave?: () => boolean | Promise<boolean>;
    /** Callback volaný po automatickém uložení */
    afterSave?: (saveId: string) => void | Promise<void>;
    /** Další možnosti specifické pro implementaci úložiště */
    [key: string]: any;
}

/**
 * Metody pro práci s úložištěm uložených her
 */
export interface SaveStorage {
    /** Uloží data do úložiště */
    save(id: string, data: SaveData): Promise<boolean>;
    /** Načte data z úložiště */
    load(id: string): Promise<SaveData | null>;
    /** Vrátí seznam všech uložených her */
    list(): Promise<Record<string, SaveMetadata>>;
    /** Smaže uloženou hru */
    delete(id: string): Promise<boolean>;
    /** Zkontroluje, zda existuje uložená hra s daným ID */
    exists(id: string): Promise<boolean>;
    /** (Volitelné) Vymaže všechna uložení */
    clearAll?: () => Promise<boolean>;
}

/**
 * Typy událostí emitovaných SaveManager
 */
export enum SaveEvents {
    GAME_SAVED = 'save:gameSaved',
    GAME_LOADED = 'save:gameLoaded',
    GAME_DELETED = 'save:gameDeleted',
    AUTO_SAVE_ENABLED = 'save:autoSaveEnabled',
    AUTO_SAVE_DISABLED = 'save:autoSaveDisabled',
    ALL_SAVES_CLEARED = 'save:allSavesCleared',
    STORAGE_CHANGED = 'save:storageChanged'
}

// Přidání typů pro data událostí SaveManageru (příklad)
export interface GameSavedEventData {
    saveId: string;
    metadata?: SaveMetadata; // Metadata mohou chybět při selhání před jejich vytvořením
    success: boolean;
    error?: any;
}

export interface GameLoadedEventData {
    saveId: string;
    metadata?: SaveMetadata; // Metadata jsou dostupná jen při úspěchu
    success: boolean;
    error?: any;
}

export interface GameDeletedEventData {
    saveId: string;
    success: boolean;
    error?: any;
}

export interface AutoSaveEnabledEventData {
    options: AutoSaveOptions;
}
export interface AutoSaveDisabledEventData {}

export interface AllSavesClearedEventData {
    success: boolean;
    error?: any;
}

export interface StorageChangedEventData {
    storage: SaveStorage;
}

// Mapa událostí pro SaveManager
export type SaveEventMap = {
    [SaveEvents.GAME_SAVED]: GameSavedEventData;
    [SaveEvents.GAME_LOADED]: GameLoadedEventData;
    [SaveEvents.GAME_DELETED]: GameDeletedEventData;
    [SaveEvents.AUTO_SAVE_ENABLED]: AutoSaveEnabledEventData;
    [SaveEvents.AUTO_SAVE_DISABLED]: AutoSaveDisabledEventData;
    [SaveEvents.ALL_SAVES_CLEARED]: AllSavesClearedEventData;
    [SaveEvents.STORAGE_CHANGED]: StorageChangedEventData;
};
</file>

<file path="src/save/utils.ts">
import { GameEngine } from '../engine/GameEngine';
import { SaveManager } from './SaveManager';
import { SaveStorage, AutoSaveOptions } from './types';
import { MemoryStorage } from './MemoryStorage';
import { LocalStorageProxy } from './LocalStorageProxy';

/**
 * Možnosti pro vytvoření SaveManageru
 */
export interface CreateSaveManagerOptions {
    /**
     * Úložiště pro uložené hry
     */
    storage?: SaveStorage;

    /**
     * Verze enginu
     */
    engineVersion?: string;

    /**
     * Zda automaticky aktivovat automatické ukládání
     */
    enableAutoSave?: boolean;

    /**
     * Interval automatického ukládání v milisekundách
     */
    autoSaveInterval?: number;

    /**
     * Počet slotů pro automatické ukládání
     */
    autoSaveSlots?: number;

    /**
     * Prefix pro klíče v localStorage (pouze pro localStorage úložiště)
     */
    storagePrefix?: string;

    /**
     * Typ úložiště
     * 'memory' - uložení do paměti (pouze pro běh aplikace)
     * 'localStorage' - uložení do localStorage prohlížeče
     * Výchozí: 'localStorage'
     */
    storageType?: 'memory' | 'localStorage';
}

/**
 * Vytvoří SaveManager s předkonfigurovaným nastavením
 *
 * @param engine Instance herního enginu
 * @param options Možnosti pro vytvoření SaveManageru
 * @returns Instance SaveManageru
 */
export function createSaveManager(
    engine: GameEngine,
    options: CreateSaveManagerOptions = {}
): SaveManager {
    // Vytvoření úložiště, pokud není specifikováno
    let storage = options.storage;
    if (!storage) {
        const storageType = options.storageType || 'localStorage';
        if (storageType === 'memory') {
            storage = new MemoryStorage();
        } else {
            storage = new LocalStorageProxy({ prefix: options.storagePrefix });
        }
    }

    // Získání verze enginu z enginu, pokud existuje metoda getVersion
    const engineVersion = options.engineVersion ||
        (typeof engine.getVersion === 'function' ? engine.getVersion() : '0.1.0');

    // Vytvoření SaveManageru
    const saveManager = new SaveManager(engine, {
        storage,
        engineVersion
    });

    // Aktivace automatického ukládání, pokud je požadováno
    if (options.enableAutoSave) {
        const autoSaveOptions: AutoSaveOptions = {};

        if (options.autoSaveInterval) {
            autoSaveOptions.interval = options.autoSaveInterval;
        }

        if (options.autoSaveSlots) {
            autoSaveOptions.slots = options.autoSaveSlots;
        }

        saveManager.enableAutoSave(autoSaveOptions);
    }

    return saveManager;
}

/**
 * Validuje data uložené hry
 *
 * @param saveData Data k validaci
 * @returns True pokud jsou data validní, jinak false
 */
export function validateSaveData(saveData: any): boolean {
    if (!saveData || typeof saveData !== 'object') {
        return false;
    }

    // Kontrola existence a typu požadovaných vlastností
    if (!saveData.metadata || typeof saveData.metadata !== 'object') {
        return false;
    }

    if (typeof saveData.state !== 'string') {
        return false;
    }

    // Kontrola požadovaných polí metadat
    const requiredMetadataFields = ['id', 'name', 'createdAt', 'updatedAt', 'saveVersion'];
    for (const field of requiredMetadataFields) {
        if (!(field in saveData.metadata)) {
            return false;
        }
    }

    return true;
}

/**
 * Vytvoří jedinečné ID pro uloženou hru
 *
 * @param prefix Volitelný prefix
 * @returns Jedinečné ID
 */
export function generateSaveId(prefix: string = 'save'): string {
    const timestamp = Date.now();
    const random = Math.floor(Math.random() * 1000000).toString().padStart(6, '0');
    return `${prefix}_${timestamp}_${random}`;
}

/**
 * Převede čas hraní z milisekund na formátovaný řetězec
 *
 * @param timeMs Čas v milisekundách
 * @param format Formát výstupu ('short', 'medium', 'long')
 * @returns Naformátovaný řetězec
 */
export function formatPlayTime(
    timeMs: number,
    format: 'short' | 'medium' | 'long' = 'medium'
): string {
    const seconds = Math.floor((timeMs / 1000) % 60);
    const minutes = Math.floor((timeMs / (1000 * 60)) % 60);
    const hours = Math.floor(timeMs / (1000 * 60 * 60));
    const days = Math.floor(timeMs / (1000 * 60 * 60 * 24));

    switch (format) {
        case 'short':
            if (hours > 0) {
                return `${hours}h ${minutes}m`;
            } else {
                return `${minutes}m ${seconds}s`;
            }
        case 'long':
            let parts = [];
            if (days > 0) parts.push(`${days} ${days === 1 ? 'den' : 'dnů'}`);
            if (hours > 0) parts.push(`${hours} ${getHoursText(hours)}`);
            if (minutes > 0) parts.push(`${minutes} ${getMinutesText(minutes)}`);
            if (seconds > 0 || parts.length === 0) {
                parts.push(`${seconds} ${getSecondsText(seconds)}`);
            }
            return parts.join(', ');
        case 'medium':
        default:
            return [
                hours.toString().padStart(2, '0'),
                minutes.toString().padStart(2, '0'),
                seconds.toString().padStart(2, '0')
            ].join(':');
    }
}

// Pomocné funkce pro českou lokalizaci
function getHoursText(hours: number): string {
    if (hours === 1) return 'hodina';
    if (hours >= 2 && hours <= 4) return 'hodiny';
    return 'hodin';
}

function getMinutesText(minutes: number): string {
    if (minutes === 1) return 'minuta';
    if (minutes >= 2 && minutes <= 4) return 'minuty';
    return 'minut';
}

function getSecondsText(seconds: number): string {
    if (seconds === 1) return 'sekunda';
    if (seconds >= 2 && seconds <= 4) return 'sekundy';
    return 'sekund';
}

/**
 * Exportuje uloženou hru do souboru
 *
 * @param saveData Data uložené hry
 * @param filename Název souboru
 */
export function exportSaveToFile(saveData: any, filename: string = 'save.json'): void {
    if (typeof window === 'undefined') {
        console.warn('Export to file is only available in browser environment');
        return;
    }

    try {
        const json = JSON.stringify(saveData, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();

        // Uvolnění URL po stažení
        setTimeout(() => {
            URL.revokeObjectURL(url);
        }, 100);
    } catch (error) {
        console.error('Failed to export save file:', error);
    }
}

/**
 * Importuje uloženou hru ze souboru
 *
 * @param file Soubor k importu
 * @returns Promise rozhodnutý na data uložené hry
 */
export function importSaveFromFile(file: File): Promise<any> {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();

        reader.onload = (e) => {
            try {
                const content = e.target?.result as string;
                const saveData = JSON.parse(content);

                if (!validateSaveData(saveData)) {
                    reject(new Error('Invalid save file format'));
                    return;
                }

                resolve(saveData);
            } catch (error) {
                reject(error);
            }
        };

        reader.onerror = () => {
            reject(new Error('Error reading file'));
        };

        reader.readAsText(file);
    });
}
</file>

<file path="src/scene/index.ts">
// Export typů
export * from './types';

// Export hlavních tříd
export { SceneManager } from './SceneManager';

// Export utilit
export {
    getSceneContent,
    isSceneVisited,
    validateScene,
    normalizeSceneKey,
    getParentSceneKey,
    getSceneNameFromKey
} from './utils';
</file>

<file path="src/scene/SceneManager.ts">
import { GameState } from '../state/types';
import { Scene, SceneKey } from './types';
import { GenericContentLoader } from '../content/GenericContentLoader';

/**
 * Spravuje scény a přechody mezi nimi
 */
export class SceneManager {
    /** Klíč aktuální scény */
    private currentSceneKey: SceneKey | null = null;

    /** Reference na objekt aktuální scény */
    private currentScene: Scene | null = null;

    /** Content loader pro scény */
    private sceneLoader: GenericContentLoader<Scene>;

    /**
     * Vytvoří novou instanci SceneManager
     */
    constructor(sceneLoader: GenericContentLoader<Scene>) {
        this.sceneLoader = sceneLoader;
    }

    /**
     * Přechod na novou scénu
     */
    public async transitionToScene(
        sceneKey: SceneKey,
        state: GameState,
        engine: any
    ): Promise<boolean> {
        try {
            const targetScene: Scene = await this.sceneLoader.loadContent(sceneKey);

            if (!targetScene) {
                console.error(`Scene with key '${sceneKey}' not found.`);
                return false;
            }

            // Pokud existuje aktuální scéna, zavolá se její onExit metoda
            if (this.currentScene && this.currentScene.onExit) {
                this.currentScene.onExit(state, engine);
            }

            // Aktualizace aktuální scény
            this.currentSceneKey = sceneKey;
            this.currentScene = targetScene;

            // Aktualizace stavu pro sledování navštívených scén
            if (engine.getStateManager && typeof engine.getStateManager === 'function') {
                engine.getStateManager().updateState((draftState: GameState) => {
                    draftState.visitedScenes.add(sceneKey);
                });
            } else {
                state.visitedScenes.add(sceneKey);
            }

            // Zavolání onEnter metody nové scény
            if (targetScene.onEnter) {
                targetScene.onEnter(state, engine);
            }

            return true;
        } catch (error) {
            console.error(`Error transitioning to scene '${sceneKey}':`, error);
            return false;
        }
    }

    /**
     * Získá aktuální scénu
     */
    public getCurrentScene(): Scene | null {
        return this.currentScene;
    }

    /**
     * Získá klíč aktuální scény
     */
    public getCurrentSceneKey(): SceneKey | null {
        return this.currentSceneKey;
    }

    /**
     * Předem načte scény podle klíčů
     */
    public async preloadScenes(sceneKeys?: SceneKey[]): Promise<void> {
        return this.sceneLoader.preloadContent(sceneKeys);
    }

    /**
     * Získá loader používaný tímto managerem
     */
    public getSceneLoader(): GenericContentLoader<Scene> {
        return this.sceneLoader;
    }
}
</file>

<file path="src/scene/types.ts">
import { GameState } from '../state/types';
import { Effect } from '../effect/types';

/**
 * Typ pro klíč scény
 */
export type SceneKey = string;

/**
 * Reprezentuje scénu ve hře
 */
export interface Scene {
    /**
     * Titulek scény
     */
    title: string;

    /**
     * Obsah scény, může být statický nebo dynamický
     */
    content: string | ((state: GameState) => string);

    /**
     * Handler volaný při vstupu do scény
     */
    onEnter?: (state: GameState, engine: any) => void;

    /**
     * Handler volaný při odchodu ze scény
     */
    onExit?: (state: GameState, engine: any) => void;

    /**
     * Další metadata pro rozšíření funkcionality
     */
    metadata?: Record<string, any>;

    /**
     * Interní property obsahující klíč scény
     * @internal
     */
    _key?: SceneKey;
}

/**
 * Funkce pro načtení scény
 */
export type SceneLoader = () => Promise<{ default: Scene } | Scene>;

/**
 * Registry scén mapující klíče na definice nebo loadery
 */
export type ScenesRegistry = Record<SceneKey, Scene | SceneLoader>;

/**
 * Možnosti pro přechod mezi scénami
 */
export interface SceneTransitionOptions {
    /** Volitelné efekty, které se aplikují před přechodem */
    effects?: Effect[];

    /** Volitelná data pro předání scéně při přechodu */
    data?: any;
}
</file>

<file path="src/scene/utils.ts">
import { Scene, SceneKey, ScenesRegistry } from './types';
import { GameState } from '../state/types';

/**
 * Získá text obsahu scény, řeší dynamický i statický obsah
 */
export function getSceneContent(scene: Scene, state: GameState): string {
    if (typeof scene.content === 'function') {
        return scene.content(state);
    }
    return scene.content;
}

/**
 * Zjistí, zda scéna byla již navštívena
 */
export function isSceneVisited(sceneKey: SceneKey, state: GameState): boolean {
    return state.visitedScenes.has(sceneKey);
}

/**
 * Validuje kompletnost a správnost definice scény
 */
export function validateScene(scene: Scene): boolean {
    if (!scene.title || !scene.content) {
        return false;
    }

    return true;
}

/**
 * Normalizuje klíč scény (např. převod neplatných znaků, normalizace cesty)
 */
export function normalizeSceneKey(key: string): SceneKey {
    return key.trim().replace(/\/{2,}/g, '/').replace(/^\/|\/$/g, '');
}

/**
 * Získá rodičovský klíč scény (např. pro 'forest/clearing' vrátí 'forest')
 */
export function getParentSceneKey(sceneKey: SceneKey): SceneKey | null {
    const lastSlashIndex = sceneKey.lastIndexOf('/');
    if (lastSlashIndex === -1) {
        return null;
    }
    return sceneKey.substring(0, lastSlashIndex);
}

/**
 * Získá název scény z klíče (např. pro 'forest/clearing' vrátí 'clearing')
 */
export function getSceneNameFromKey(sceneKey: SceneKey): string {
    const lastSlashIndex = sceneKey.lastIndexOf('/');
    if (lastSlashIndex === -1) {
        return sceneKey;
    }
    return sceneKey.substring(lastSlashIndex + 1);
}
</file>

<file path="src/state/persistence/index.ts">
// Export typů specifických pro persistenci
export * from './types';

// Export hlavních služeb pro persistenci
export { StateConverter } from './StateConverter';
export { StateMigrationService } from './StateMigrationService';

// Export utilit pro vytváření migračních funkcí
export * from './utils';
</file>

<file path="src/state/persistence/StateConverter.ts">
import { GameState } from '../types';
import {
    PersistedState,
    StateMetadata,
    SerializationOptions,
    StateManagerPersistenceEvents
} from './types';
import { StateMigrationService } from './StateMigrationService';
import { TypedEventEmitter } from '../../event/TypedEventEmitter'; // Zkontroluj název souboru/třídy

/**
 * Služba zodpovědná za převod mezi runtime GameState a serializovatelnou PersistedState a zpět.
 */
export class StateConverter {
    private constructor() {}

    public static serialize<T extends Record<string, unknown>>(
        state: GameState<T>,
        persistentKeys: string[],
        options: SerializationOptions = {},
        onBeforeSerializeCallback?: (state: GameState<T>) => void,
        // Přijímá typovaný emitter
        eventEmitter?: TypedEventEmitter<StateManagerPersistenceEvents<T>>
    ): string {
        const { includeMetadata = true, replacer } = options;

        if (onBeforeSerializeCallback) {
            try {
                onBeforeSerializeCallback(state);
            } catch (error) {
                console.error("Error in onBeforeSerialize callback:", error);
                // Pokračovat v serializaci i přes chybu v callbacku? Záleží na požadavcích.
            }
        }

        eventEmitter?.emit('beforeSerialize', { state });

        const serializableState: PersistedState<T> = {} as PersistedState<T>;

        for (const key of persistentKeys) {
            if (key in state) {
                const value = (state as any)[key];
                if (key === 'visitedScenes') {
                    serializableState.visitedScenes = this.convertSetToArray(value);
                } else if (key === 'variables') {
                    serializableState.variables = value as T;
                } else {
                    (serializableState as any)[key] = value;
                }
            } else {
                console.warn(`StateConverter: Persistent key '${key}' not found in GameState during serialization.`);
            }
        }

        if (includeMetadata) {
            serializableState._metadata = this.createStateMetadata();
        }

        try {
            return JSON.stringify(serializableState, replacer);
        } catch (error) {
            console.error("StateConverter: Failed to stringify serializable state.", error);
            throw new Error("Failed to serialize state to JSON");
        }
    }

    public static deserialize<T extends Record<string, unknown>>(
        serializedState: string,
        options: SerializationOptions = {},
        onAfterDeserializeCallback?: (state: GameState<T>) => void, // Stále zde, ale volá se z GameStateManageru
        // Přijímá typovaný emitter
        eventEmitter?: TypedEventEmitter<StateManagerPersistenceEvents<T>>
    ): PersistedState<T> {
        let parsedState: PersistedState<unknown>;
        try {
            parsedState = JSON.parse(serializedState) as PersistedState<unknown>;
        } catch (error) {
            console.error("StateConverter: Failed to parse serialized state string.", error);
            throw new Error("Invalid serialized state format");
        }

        const targetVersion = StateMigrationService.getCurrentStateFormatVersion();
        let migratedState: PersistedState<unknown>;
        try {
            // Předání typovaného emitteru migraci
            migratedState = StateMigrationService.migrate(
                parsedState,
                targetVersion,
                // StateMigrationService očekává emitter pro <unknown>
                eventEmitter as TypedEventEmitter<StateManagerPersistenceEvents<unknown>> | undefined
            );
        } catch (error) {
            console.error(`StateConverter: Failed to migrate state to version ${targetVersion}.`, error);
            throw error;
        }

        // Emitování události po deserializaci a migraci
        eventEmitter?.emit('afterDeserialize', { state: migratedState as PersistedState<T> });

        // Callback onAfterDeserialize se už zde nevolá, volá ho GameStateManager.applyPersistentState

        return migratedState as PersistedState<T>;
    }

    private static createStateMetadata(): StateMetadata {
        return {
            version: StateMigrationService.getCurrentStateFormatVersion(),
            timestamp: Date.now()
        };
    }

    private static convertSetToArray(setOrArray: Set<string> | string[] | undefined): string[] {
        if (setOrArray instanceof Set) {
            return Array.from(setOrArray);
        }
        if (Array.isArray(setOrArray)) {
            return setOrArray;
        }
        if (setOrArray !== undefined && setOrArray !== null) {
            console.warn("StateConverter: Expected Set<string> or Array<string> for visitedScenes, received", typeof setOrArray);
        }
        return [];
    }
}
</file>

<file path="src/state/persistence/StateMigrationService.ts">
import {
    PersistedState,
    StateMetadata,
    StateMigrationFn,
    StateManagerPersistenceEvents
} from './types';
import { TypedEventEmitter } from '../../event/TypedEventEmitter'; // Zkontroluj název souboru/třídy

const CURRENT_STATE_FORMAT_VERSION = 1;

/**
 * Služba zodpovědná za správu a aplikaci migračních funkcí pro persistovaný stav.
 */
export class StateMigrationService {
    private static migrations = new Map<number, StateMigrationFn>();
    private constructor() {}

    public static registerMigration(fromVersion: number, migrationFn: StateMigrationFn): () => boolean {
        if (StateMigrationService.migrations.has(fromVersion)) {
            console.warn(`StateMigrationService: Migration for version ${fromVersion} is already registered. Overwriting.`);
        }
        StateMigrationService.migrations.set(fromVersion, migrationFn);
        return () => StateMigrationService.unregisterMigration(fromVersion);
    }

    public static unregisterMigration(fromVersion: number): boolean {
        return StateMigrationService.migrations.delete(fromVersion);
    }

    public static getCurrentStateFormatVersion(): number {
        return CURRENT_STATE_FORMAT_VERSION;
    }

    public static migrate(
        state: PersistedState<unknown>,
        targetVersion: number = CURRENT_STATE_FORMAT_VERSION,
        // Přijímá typovaný emitter pro <unknown>
        eventEmitter?: TypedEventEmitter<StateManagerPersistenceEvents<unknown>>
    ): PersistedState<unknown> {
        let migratedState = state; // Pracujeme s referencí, migrační funkce by měly být čisté nebo pracovat s kopiemi

        if (!migratedState._metadata) {
            console.warn("StateMigrationService: State is missing _metadata. Assuming version 0.");
            migratedState._metadata = { version: 0, timestamp: Date.now() };
        }

        let currentStateVersion = migratedState._metadata.version;

        if (currentStateVersion >= targetVersion) {
            if (currentStateVersion > targetVersion) {
                console.warn(`StateMigrationService: State version (${currentStateVersion}) is higher than target version (${targetVersion}). No migration applied.`);
            }
            // No migration needed if versions match
            return migratedState;
        }

        console.log(`StateMigrationService: Migrating state from version ${currentStateVersion} to ${targetVersion}`);

        for (let v = currentStateVersion; v < targetVersion; v++) {
            const migrationFn = StateMigrationService.migrations.get(v);

            if (migrationFn) {
                console.log(`StateMigrationService: Applying migration from version ${v} to ${v + 1}`);
                try {
                    // Migrační funkce může modifikovat migratedState nebo vrátit nový
                    migratedState = migrationFn(migratedState, v, v + 1);

                    // Aktualizace verze v metadatech migrovaného stavu
                    if (!migratedState._metadata) {
                        // Mělo by být vytvořeno v prvním kroku, pokud chybělo
                        migratedState._metadata = { version: v + 1, timestamp: Date.now() };
                    } else {
                        migratedState._metadata.version = v + 1;
                    }

                    // Emitování události
                    eventEmitter?.emit('migrationApplied', {
                        fromVersion: v,
                        toVersion: v + 1,
                        state: migratedState // Emitujeme stav po aplikaci kroku
                    });

                } catch (migrationError) {
                    console.error(`StateMigrationService: Migration from version ${v} to ${v + 1} failed:`, migrationError);
                    throw migrationError;
                }
            } else {
                const errorMsg = `StateMigrationService: Missing migration function for version ${v} to ${v + 1}`;
                console.error(errorMsg);
                throw new Error(errorMsg);
            }
        }

        console.log(`StateMigrationService: Migration complete. State is now version ${targetVersion}.`);
        return migratedState;
    }
}
</file>

<file path="src/state/persistence/types.ts">
import { GameState } from '../types'; // Import GameState from runtime types

/**
 * Možnosti pro serializaci stavu
 */
export interface SerializationOptions {
    /**
     * Zda zahrnout metadata o stavu (např. verzi stavu)
     * Výchozí: true
     */
    includeMetadata?: boolean;

    /**
     * Vlastní replacer funkce pro JSON.stringify
     */
    replacer?: (key: string, value: any) => any;

    /**
     * Další volby specifické pro implementaci
     */
    [key: string]: any;
}

/**
 * Metadata o formátu stavu, uložená v persistovaném stavu
 */
export interface StateMetadata {
    /**
     * Verze formátu stavu (pro účely migrace)
     */
    version: number;

    /**
     * Časové razítko vytvoření metadat
     */
    timestamp: number;

    /**
     * Další metadata
     */
    [key: string]: any;
}

/**
 * Typ pro persistovanou část stavu (formát pro serializaci/deserializaci)
 * Jedná se o plain object, který může být konvertován na JSON.
 * Obsahuje pouze perzistentní klíče z GameState a metadata.
 */
export interface PersistedState<T extends Record<string, unknown> = Record<string, unknown>> {
    /**
     * Navštívené scény - konvertované na pole pro JSON serializaci.
     * Volitelné, pokud by persistentKeys neobsahovalo 'visitedScenes'.
     */
    visitedScenes?: string[];

    /**
     * Herní proměnné.
     * Volitelné, pokud by persistentKeys neobsahovalo 'variables'.
     */
    variables?: T;

    /**
     * Metadata stavu (volitelné, pokud includeMetadata=false).
     */
    _metadata?: StateMetadata;

    /**
     * Indexová signatura pro další persistované vlastnosti.
     */
    [key: string]: unknown;
}

/**
 * Typ pro migrační funkci
 * Přijímá PersistedState (ne GameState) a vrací novou PersistedState.
 */
export type StateMigrationFn = (state: PersistedState<unknown>, fromVersion: number, toVersion: number) => PersistedState<unknown>;


/**
 * Eventy emitované Persistence vrstvou StateManageru (serializace, deserializace, migrace)
 */
export interface StateManagerPersistenceEvents<T extends Record<string, unknown> = Record<string, unknown>> {
    /**
     * Emitováno po aplikaci jednoho kroku migrace.
     */
    migrationApplied: {
        fromVersion: number;
        toVersion: number;
        state: PersistedState<T>; // Emituje PersistedState po kroku migrace
    };

    /**
     * Emitováno před serializací stavu (v rámci StateConverter).
     */
    beforeSerialize: { state: GameState<T> }; // Emituje GameState před konverzí na PersistedState

    /**
     * Emitováno po deserializaci stringu a migraci (v rámci StateConverter),
     * před jeho aplikací na GameStateManager.
     */
    afterDeserialize: { state: PersistedState<T> }; // Emituje PersistedState po deserializaci a migraci
}
</file>

<file path="src/state/persistence/utils.ts">
import { PersistedState, StateMigrationFn } from './types';

/**
 * Vytvoří migrační funkci pro přejmenování vlastnosti na dané cestě v persistovaném stavu.
 * Používá standardní JS/lodash operace na plain objektu (PersistedState).
 * @param oldPath Původní cesta k vlastnosti (dot notation, např. 'variables.player.name' nebo 'inventory')
 * @param newPath Nová cesta k vlastnosti (dot notation)
 * @returns Migrační funkce
 */
export function createRenameMigration(
    oldPath: string,
    newPath: string
): StateMigrationFn {
    return (state, fromVersion, toVersion) => {
        // Vytvoříme kopii stavu, aby migrační funkce byly immutable ve svém vstupu
        // a neměnily původní objekt předávaný do migrate().
        // Aplikace Immer produce by zde byla náročnější, ale bezpečnější pro složité struktury.
        // Pro jednoduché plain objekty stačí spread.
        const newState = { ...state }; // Kopie první úrovně

        // Implementace pro zanořené cesty
        const oldPathParts = oldPath.split('.');
        const newPathParts = newPath.split('.');

        let currentOld: any = newState;
        let parentOfOld: any = null;
        let oldKey: string | undefined;

        // Najdeme hodnotu na staré cestě a rodiče
        for (let i = 0; i < oldPathParts.length; i++) {
            oldKey = oldPathParts[i];
            if (currentOld === undefined || currentOld === null || typeof currentOld !== 'object') {
                console.warn(`Migration Warning (v${fromVersion} to v${toVersion}): Path segment '${oldPathParts[i]}' in old path '${oldPath}' is not an object. Skipping rename.`);
                return state; // Cesta se zlomila, nic neděláme
            }
            if (i < oldPathParts.length - 1) {
                parentOfOld = currentOld;
                currentOld = currentOld[oldKey];
            } else {
                currentOld = currentOld[oldKey]; // Hodnota na konci staré cesty
            }
        }


        // Pokud hodnota na staré cestě existuje (není undefined), provedeme přenos
        if (currentOld !== undefined) {
            // Vytvoříme novou strukturu pro novou cestu, pokud neexistuje
            let currentNew: any = newState;
            for (let i = 0; i < newPathParts.length - 1; i++) {
                const newKeyPart = newPathParts[i];
                if (currentNew[newKeyPart] === undefined || currentNew[newKeyPart] === null || typeof currentNew[newKeyPart] !== 'object') {
                    currentNew[newKeyPart] = {}; // Vytvoříme zanořený objekt
                }
                currentNew = currentNew[newKeyPart];
            }

            // Nastavíme hodnotu na nové cestě
            const newKey = newPathParts[newPathParts.length - 1];
            currentNew[newKey] = currentOld;

            // Odstraníme hodnotu na staré cestě, pokud existuje rodič a klíč
            if (parentOfOld && oldKey !== undefined && typeof parentOfOld === 'object') {
                delete parentOfOld[oldKey];
            } else if (oldKey !== undefined && parentOfOld === null) {
                // Případ, kdy stará cesta začíná přímo na kořeni (např. 'myOldProp')
                delete newState[oldKey];
            }


            console.log(`Migration Applied (v${fromVersion} to v${toVersion}): Renamed '${oldPath}' to '${newPath}'`);
        } else {
            console.warn(`Migration Warning (v${fromVersion} to v${toVersion}): Value at old path '${oldPath}' is undefined. Skipping rename.`);
        }


        return newState; // Vracíme (modifikovaný) objekt stavu
    };
}

/**
 * Vytvoří migrační funkci pro transformaci hodnoty na dané cestě v persistovaném stavu.
 * @template T Původní typ hodnoty na cestě
 * @template U Nový typ hodnoty na cestě
 * @param path Cesta k hodnotě (dot notation)
 * @param transformFn Funkce pro transformaci hodnoty (oldValue: T => newValue: U)
 * @returns Migrační funkce
 */
export function createTransformMigration<T, U>(
    path: string,
    transformFn: (oldValue: T) => U
): StateMigrationFn {
    return (state, fromVersion, toVersion) => {
        const newState = { ...state }; // Kopie první úrovně
        const pathParts = path.split('.');
        let current: any = newState;
        let parent: any = null;
        let key: string | undefined;

        // Najdeme hodnotu na cestě a rodiče
        for (let i = 0; i < pathParts.length; i++) {
            key = pathParts[i];
            if (current === undefined || current === null || typeof current !== 'object') {
                console.warn(`Migration Warning (v${fromVersion} to v${toVersion}): Path segment '${pathParts[i]}' in path '${path}' is not an object. Skipping transform.`);
                return state; // Cesta se zlomila, nic neděláme
            }
            if (i < pathParts.length - 1) {
                parent = current;
                current = current[key];
            } else {
                parent = current; // Rodič je objekt před posledním klíčem
                current = current[key]; // Hodnota na konci cesty
            }
        }


        // Pokud hodnota na cestě existuje (není undefined) a rodič je objekt, provedeme transformaci
        if (current !== undefined && parent && key !== undefined && typeof parent === 'object') {
            try {
                parent[key] = transformFn(current as T);
                console.log(`Migration Applied (v${fromVersion} to v${toVersion}): Transformed value at '${path}'`);
            } catch (error) {
                console.error(`Migration Error (v${fromVersion} to v${toVersion}): Failed to transform value at '${path}'.`, error);
                // Můžete se rozhodnout vyhodit chybu nebo jen zalogovat a vrátit původní stav
                // throw error; // Vyhození chyby zastaví migrační proces
            }
        } else {
            console.warn(`Migration Warning (v${fromVersion} to v${toVersion}): Value at path '${path}' is undefined or path invalid. Skipping transform.`);
        }


        return newState; // Vracíme (modifikovaný) objekt stavu
    };
}

/**
 * Vytvoří migrační funkci pro přidání nové vlastnosti s výchozí hodnotou na dané cestě, pokud neexistuje.
 * Vytvoří zanořené objekty na cestě, pokud je to nutné.
 * @template T Typ výchozí hodnoty
 * @param path Cesta k nové vlastnosti (dot notation)
 * @param defaultValue Výchozí hodnota
 * @returns Migrační funkce
 */
export function createAddPropertyMigration<T>(
    path: string,
    defaultValue: T
): StateMigrationFn {
    return (state, fromVersion, toVersion) => {
        const newState = { ...state }; // Kopie první úrovně
        const pathParts = path.split('.');
        let current: any = newState;
        let parent: any = null;
        let key: string | undefined;

        // Projdeme cestu a vytvoříme zanořené objekty
        for (let i = 0; i < pathParts.length; i++) {
            key = pathParts[i];
            if (current === undefined || current === null || typeof current !== 'object') {
                // Nelze pokračovat po neobjektové hodnotě, cesta pro přidání není platná v této struktuře
                console.warn(`Migration Warning (v${fromVersion} to v${toVersion}): Cannot add property at invalid path '${path}'. Path segment '${pathParts[i]}' is not an object.`);
                return state;
            }
            if (i < pathParts.length - 1) {
                parent = current;
                // Pokud neexistuje další zanořený objekt nebo není objekt, vytvoříme ho
                if (current[key] === undefined || current[key] === null || typeof current[key] !== 'object') {
                    current[key] = {};
                }
                current = current[key];
            } else {
                // Jsme na poslední úrovni, kde má být vlastnost přidána
                parent = current;
                current = current[key]; // Toto je hodnota, kterou chceme zkontrolovat, zda existuje
            }
        }


        // Pokud vlastnost na cílové cestě neexistuje (je undefined), přidáme ji
        if (current === undefined && parent && key !== undefined && typeof parent === 'object') {
            parent[key] = defaultValue;
            console.log(`Migration Applied (v${fromVersion} to v${toVersion}): Added new property at '${path}'`);
        } else {
            // Vlastnost už existuje nebo cesta byla nevalidní (varování již zalogováno výše)
            if (current !== undefined) {
                console.warn(`Migration Warning (v${fromVersion} to v${toVersion}): Property at '${path}' already exists. Skipping add.`);
            }
        }

        return newState; // Vracíme (modifikovaný) objekt stavu
    };
}


/**
 * Vytvoří migrační funkci pro odstranění vlastnosti na dané cestě v persistovaném stavu.
 * @param path Cesta k vlastnosti (dot notation)
 * @returns Migrační funkce
 */
export function createRemovePropertyMigration(
    path: string
): StateMigrationFn {
    return (state, fromVersion, toVersion) => {
        const newState = { ...state }; // Kopie první úrovně
        const pathParts = path.split('.');
        let current: any = newState;
        let parent: any = null;
        let key: string | undefined;

        // Najdeme rodiče a klíč cesty
        for (let i = 0; i < pathParts.length; i++) {
            key = pathParts[i];
            if (current === undefined || current === null || typeof current !== 'object') {
                console.warn(`Migration Warning (v${fromVersion} to v${toVersion}): Path segment '${pathParts[i]}' in path '${path}' is not an object. Skipping remove.`);
                return state; // Cesta se zlomila, nic neděláme
            }
            if (i < pathParts.length - 1) {
                parent = current;
                current = current[key];
            } else {
                parent = current; // Rodič je objekt před posledním klíčem
                current = current[key]; // Toto je hodnota, kterou chceme zkontrolovat, zda existuje k odstranění
            }
        }

        // Pokud vlastnost existuje (není undefined) a rodič je objekt, odstraníme ji
        if (current !== undefined && parent && key !== undefined && typeof parent === 'object') {
            delete parent[key];
            console.log(`Migration Applied (v${fromVersion} to v${toVersion}): Removed property at '${path}'`);
        } else {
            console.warn(`Migration Warning (v${fromVersion} to v${toVersion}): Property at '${path}' does not exist or path invalid. Skipping remove.`);
        }

        return newState; // Vracíme (modifikovaný) objekt stavu
    };
}


/**
 * Kombinuje více migračních funkcí do jedné.
 * Aplikuje funkce postupně v pořadí, v jakém jsou zadány.
 * @param migrations Pole migračních funkcí
 * @returns Kombinovaná migrační funkce
 */
export function combineMigrations(...migrations: StateMigrationFn[]): StateMigrationFn {
    return (state, fromVersion, toVersion) => {
        let currentState = state;
        for (const migration of migrations) {
            // Každá migrace pracuje na výstupu té předchozí
            currentState = migration(currentState, fromVersion, toVersion);
        }
        return currentState;
    };
}

/**
 * Vytvoří migrační funkci, která aplikuje libovolnou transformaci na celý persistovaný stav.
 * @param transformFn Funkce pro transformaci celého stavu (state: PersistedState<unknown> => PersistedState<unknown>)
 * @returns Migrační funkce
 */
export function createStateMigration(
    transformFn: (state: PersistedState<unknown>) => PersistedState<unknown>
): StateMigrationFn {
    return (state, fromVersion, toVersion) => {
        try {
            const newState = transformFn(state);
            console.log(`Migration Applied (v${fromVersion} to v${toVersion}): Applied custom state transformation.`);
            return newState;
        } catch (error) {
            console.error(`Migration Error (v${fromVersion} to v${toVersion}): Error during custom state transformation.`, error);
            // Propagace chyby, aby se migrační proces zastavil
            throw error;
        }
    };
}

// Speciální utility pro migraci variables (zde jako aliasy pro obecnější funkce)
// Tyto předpokládají, že proměnné jsou přímo na první úrovni 'variables'.
export const createVariableRenameMigration = (oldName: string, newName: string) =>
    createRenameMigration(`variables.${oldName}`, `variables.${newName}`);

export const createVariableTransformMigration = <T, U>(name: string, transformFn: (oldValue: T) => U) =>
    createTransformMigration<T, U>(`variables.${name}`, transformFn);

export const createAddVariableMigration = <T>(name: string, defaultValue: T) =>
    createAddPropertyMigration(`variables.${name}`, defaultValue);

export const createRemoveVariableMigration = (name: string) =>
    createRemovePropertyMigration(`variables.${name}`);
</file>

<file path="src/state/GameStateManager.ts">
import {
    GameState,
    GameStateManagerOptions,
    DEFAULT_PERSISTENT_KEYS,
    StateChangedEvent,
    GameStateManagerEvents // Importuj typ pro mapu událostí
} from './types';
import { PersistedState } from './persistence/types';
import { produce } from '../utils/immer';
import { TypedEventEmitter } from '../event/TypedEventEmitter';
import { validateState } from './utils';
import { GameEngine } from '../engine/GameEngine'; // Importuj GameEngine

/**
 * Spravuje herní stav s důrazem na neměnnost.
 * @template T Typ proměnných ve stavu
 */
export class GameStateManager<T extends Record<string, unknown> = Record<string, unknown>> {
    private state: GameState<T>;
    private persistentKeys: string[];
    // Emitter specifický pro události tohoto manažeru
    private readonly eventEmitter: TypedEventEmitter<GameStateManagerEvents<T>>;
    private onBeforeSerialize?: (state: GameState<T>) => void;
    private onAfterDeserialize?: (state: GameState<T>) => void;

    /**
     * Vytvoří novou instanci GameStateManager.
     * @param engine Instance GameEngine pro získání typovaného emitteru.
     * @param options Možnosti konfigurace GameStateManageru.
     */
    constructor(engine: GameEngine, options: GameStateManagerOptions<T> = {}) {
        this.state = this.createInitialState(options.initialState || {});
        this.persistentKeys = Array.isArray(options.persistentKeys)
            ? [...options.persistentKeys]
            : [...DEFAULT_PERSISTENT_KEYS];

        // Získání specifického emitteru z enginu
        this.eventEmitter = engine.getStateManagerEventEmitter<T>();

        this.onBeforeSerialize = options.onBeforeSerialize;
        this.onAfterDeserialize = options.onAfterDeserialize;
        this.ensureDefaultPersistentKeys();
    }

    private ensureDefaultPersistentKeys(): void {
        if (!this.persistentKeys.includes('visitedScenes')) {
            this.persistentKeys.push('visitedScenes');
        }
        if (!this.persistentKeys.includes('variables')) {
            this.persistentKeys.push('variables');
        }
    }

    private createInitialState(initialState: Partial<GameState<T>>): GameState<T> {
        const baseState: GameState<T> = {
            visitedScenes: new Set<string>(),
            variables: {} as T,
        };
        const state = { ...baseState, ...initialState } as GameState<T>;

        if (!(state.visitedScenes instanceof Set)) {
            console.warn("GameStateManager: Initial state for visitedScenes was not a Set. Converting to Set.");
            state.visitedScenes = new Set(Array.isArray(state.visitedScenes) ? state.visitedScenes : []);
        }
        if (typeof state.variables !== 'object' || state.variables === null) {
            console.warn("GameStateManager: Initial state for variables was not an object. Initializing as empty object.");
            state.variables = {} as T;
        }
        return state;
    }

    public getState(): GameState<T> {
        return this.state;
    }

    public updateState(updater: (state: GameState<T>) => void, source?: string): void {
        const previousState = this.state;
        this.state = produce(this.state, (draft: GameState<T>) => {
            updater(draft);
        });
        if (this.state !== previousState) {
            this.emitStateChanged(previousState, this.state, source || 'update');
        }
    }

    public setState(newState: GameState<T>, source?: string): void {
        if (!validateState(newState)) {
            console.error("GameStateManager: Attempted to set invalid state.", newState);
            throw new Error("Attempted to set invalid state.");
        }
        const previousState = this.state;
        this.state = newState;
        this.emitStateChanged(previousState, this.state, source || 'setState');
    }

    public applyPersistentState(persistedStateData: PersistedState<T>, source?: string): void {
        const previousState = this.state;
        const newState: GameState<T> = {
            visitedScenes: new Set(Array.isArray(persistedStateData.visitedScenes) ? persistedStateData.visitedScenes : []),
            variables: (typeof persistedStateData.variables === 'object' && persistedStateData.variables !== null ? persistedStateData.variables : {}) as T,
        } as GameState<T>;

        for (const key of this.persistentKeys) {
            if (key === 'visitedScenes' || key === 'variables') continue;
            if (key in persistedStateData && key !== '_metadata') {
                (newState as any)[key] = (persistedStateData as any)[key];
            }
        }

        this.state = newState;

        if (this.onAfterDeserialize) {
            try {
                this.onAfterDeserialize(this.state);
            } catch (error) {
                console.error("Error in onAfterDeserialize callback:", error)
            }
        }

        this.emitStateChanged(previousState, this.state, source || 'applyPersistentState');
    }

    public resetState(options: Partial<GameState<T>> = {}): void {
        const previousState = this.state;
        this.state = this.createInitialState(options);
        this.emitStateChanged(previousState, this.state, 'reset');
    }

    public mergeState(externalState: Partial<GameState<T>>): void {
        this.updateState(state => {
            if (externalState.visitedScenes) {
                const scenesToAdd = externalState.visitedScenes instanceof Set
                    ? externalState.visitedScenes
                    : Array.isArray(externalState.visitedScenes)
                        ? new Set(externalState.visitedScenes)
                        : [];
                for (const sceneKey of scenesToAdd) {
                    state.visitedScenes.add(sceneKey);
                }
            }
            if (externalState.variables && typeof externalState.variables === 'object') {
                Object.assign(state.variables, externalState.variables);
            }
            for (const key in externalState) {
                if (Object.prototype.hasOwnProperty.call(externalState, key) && key !== 'visitedScenes' && key !== 'variables') {
                    (state as any)[key] = (externalState as any)[key];
                }
            }
        }, 'mergeState');
    }

    public getVariable<K extends keyof T>(name: K, defaultValue?: T[K]): T[K] | undefined {
        return this.state.variables[name] ?? defaultValue;
    }

    public setVariable<K extends keyof T>(name: K, value: T[K]): void {
        this.updateState(state => { state.variables[name] = value; }, 'setVariable');
    }

    public hasVariable<K extends keyof T>(name: K): boolean {
        return this.state.variables[name] !== undefined;
    }

    public removeVariable<K extends keyof T>(name: K): void {
        this.updateState(state => { delete state.variables[name]; }, 'removeVariable');
    }

    public markSceneVisited(sceneKey: string): void {
        this.updateState(state => { state.visitedScenes.add(sceneKey); }, 'markSceneVisited');
    }

    public unmarkSceneVisited(sceneKey: string): void {
        this.updateState(state => { state.visitedScenes.delete(sceneKey); }, 'unmarkSceneVisited');
    }

    public clearVisitedScenes(): void {
        this.updateState(state => { state.visitedScenes.clear(); }, 'clearVisitedScenes');
    }

    public hasVisitedScene(sceneKey: string): boolean {
        return this.state.visitedScenes.has(sceneKey);
    }

    public getVisitedScenesCount(): number {
        return this.state.visitedScenes.size;
    }

    public setPersistentKeys(keys: string[]): void {
        this.persistentKeys = Array.isArray(keys) ? [...keys] : [];
        this.ensureDefaultPersistentKeys();
        this.eventEmitter.emit('persistentKeysChanged', { keys: [...this.persistentKeys] });
    }

    public getPersistentKeys(): string[] {
        return [...this.persistentKeys];
    }

    public addPersistentKey(key: string): void {
        if (typeof key !== 'string' || key.length === 0) return;
        if (!this.persistentKeys.includes(key)) {
            this.persistentKeys = [...this.persistentKeys, key];
            this.eventEmitter.emit('persistentKeysChanged', { keys: [...this.persistentKeys] });
        }
    }

    public removePersistentKey(key: string): void {
        if (typeof key !== 'string' || key.length === 0) return;
        if (key === 'visitedScenes' || key === 'variables') {
            console.warn(`GameStateManager: Cannot remove default persistent key "${key}".`);
            return;
        }
        const index = this.persistentKeys.indexOf(key);
        if (index !== -1) {
            this.persistentKeys = [
                ...this.persistentKeys.slice(0, index),
                ...this.persistentKeys.slice(index + 1)
            ];
            this.eventEmitter.emit('persistentKeysChanged', { keys: [...this.persistentKeys] });
        }
    }

    private emitStateChanged(previousState: GameState<T> | null, newState: GameState<T>, source?: string): void {
        const eventData: StateChangedEvent<T> = { previousState, newState, source };
        this.eventEmitter.emit('stateChanged', eventData);
    }

    // Veřejné on/off metody pro naslouchání na události GameStateManageru
    public on<K extends keyof GameStateManagerEvents<T>>(
        event: K,
        listener: (data: GameStateManagerEvents<T>[K]) => void
    ): void {
        this.eventEmitter.on(event, listener);
    }

    public off<K extends keyof GameStateManagerEvents<T>>(
        event: K,
        listener: (data: GameStateManagerEvents<T>[K]) => void
    ): void {
        this.eventEmitter.off(event, listener);
    }

    public getOnBeforeSerializeCallback(): ((state: GameState<T>) => void) | undefined {
        return this.onBeforeSerialize;
    }

    public getOnAfterDeserializeCallback(): ((state: GameState<T>) => void) | undefined {
        return this.onAfterDeserialize;
    }
}
</file>

<file path="src/state/index.ts">
// Export runtime typů
export * from './types';

// Export hlavního runtime správce stavu
export { GameStateManager } from './GameStateManager';

// Export obecných runtime utilit pro stav
export * from './utils';

// Export všeho z persistence podsložky
// Tím se persistence služby a typy stávají součástí veřejného API modulu 'state'
export * from './persistence';
</file>

<file path="src/state/types.ts">
/**
 * Základní herní stav
 * Obsahuje základní strukturu pro ukládání herního stavu
 * @template T Typ pro proměnné, výchozí je prázdný objekt
 */
export interface GameState<T extends Record<string, unknown> = Record<string, unknown>> {
    /**
     * Množina klíčů navštívených scén
     */
    visitedScenes: Set<string>;

    /**
     * Úložiště herních proměnných
     */
    variables: T;

    /**
     * Indexová signatura pro další vlastnosti
     * Umožňuje rozšiřování stavu pluginy a dalšími komponentami
     */
    [key: string]: any;
}

/**
 * Klíč pro perzistentní vlastnosti ve stavu - pro dokumentaci/API reference, ne interně
 */
export const PERSISTENT_KEYS_KEY = '__persistentKeys'; // Konstanta zůstává pro referenci

/**
 * Výchozí perzistentní klíče, které by měly být vždy ukládány
 */
export const DEFAULT_PERSISTENT_KEYS = ['visitedScenes', 'variables'];

/**
 * Funkce pro aktualizaci herního stavu
 * Používá se s immer pro bezpečné mutace
 * @template T Typ proměnných ve stavu
 */
export type StateUpdater<T extends Record<string, unknown> = Record<string, unknown>> = (state: GameState<T>) => void;

/**
 * Možnosti pro vytvoření GameStateManager
 * @template T Typ proměnných ve stavu
 */
export interface GameStateManagerOptions<T extends Record<string, unknown> = Record<string, unknown>> {
    /**
     * Počáteční stav, který bude sloučen s výchozím prázdným stavem
     */
    initialState?: Partial<GameState<T>>;

    /**
     * Seznam klíčů, které budou persistovány při serializaci
     * Pokud není uveden, použijí se DEFAULT_PERSISTENT_KEYS
     */
    persistentKeys?: string[];

    /**
     * Callback volaný PŘED serializací stavu.
     * Tuto funkcionalitu by měl primárně implementovat SaveManager nebo PersistenceService,
     * ale je zde ponechána pro možnost, aby GameStateManager mohl provést přípravu.
     */
    onBeforeSerialize?: (state: GameState<T>) => void;

    /**
     * Callback volaný PO deserializaci stavu a jeho aplikaci na GameStateManager.
     * Stejně jako onBeforeSerialize, primárně patří do persistence vrstvy.
     */
    onAfterDeserialize?: (state: GameState<T>) => void;
}

/**
 * Data předávaná při události změny stavu
 */
export interface StateChangedEvent<T extends Record<string, unknown> = Record<string, unknown>> {
    /**
     * Předchozí stav (null při deserializaci)
     */
    previousState: GameState<T> | null;

    /**
     * Nový stav
     */
    newState: GameState<T>;

    /**
     * Zdroj změny (např. 'effect', 'scene', 'plugin', 'deserialize', 'reset', atd.)
     */
    source?: string;
}

/**
 * Eventy emitované GameStateManagerem (runtime události)
 */
export interface GameStateManagerEvents<T extends Record<string, unknown> = Record<string, unknown>> {
    /**
     * Emitováno při změně stavu
     */
    stateChanged: StateChangedEvent<T>;

    /**
     * Emitováno při změně perzistentních klíčů
     */
    persistentKeysChanged: { keys: string[] };

    // Události související s persistencí (jako beforeSerialize/afterDeserialize/migrationApplied)
    // by se nyní měly emitovat z StatePersistenceService nebo StateMigrationService,
    // jak je definováno v src/state/persistence/types.ts.
    // GameStateManager na ně může volitelně naslouchat, pokud je to potřeba.
}
</file>

<file path="src/state/utils.ts">
import { GameState } from './types';
import lodashGet from 'lodash/get';
import lodashSet from 'lodash/set';
import lodashHas from 'lodash/has';
import { produce } from '../utils/immer'; // Předpokládá se, že Immer utilities jsou stále zde

/**
 * Získá hodnotu z herního stavu pomocí cesty (dot notation)
 * Používá Lodash get pro pohodlí a robustnost.
 * @template T Typ očekávaného výstupu
 * @param state Herní stav
 * @param path Cesta k hodnotě (např. 'variables.player.health', 'visitedScenes', 'somePluginData.config.value')
 * @param defaultValue Výchozí hodnota, pokud cesta neexistuje nebo je výsledek undefined.
 * @returns Hodnota proměnné nebo defaultValue, pokud je poskytnuto.
 */
export function getStatePath<T>(state: GameState<any>, path: string, defaultValue?: T): T | undefined {
    // Lodash get umí procházet objekty i pole podle indexu nebo klíče
    return lodashGet(state, path, defaultValue);
}

/**
 * Nastaví hodnotu v herním stavu pomocí cesty (dot notation)
 * Tato funkce by se měla používat *uvnitř* `updateState` callbacku,
 * kde pracujete s draftem.
 * @param draftState Draft herního stavu (z Immer produce)
 * @param path Cesta k hodnotě (např. 'variables.player.health', 'somePluginData.config.value')
 * @param value Hodnota k nastavení
 */
export function setStatePath<T extends Record<string, unknown>>(
    draftState: GameState<T>, // Pracuje s draftem!
    path: string,
    value: any
): void { // V Immer draftu se mutuje in-place, nevrací se nový stav
    // Lodash set umí vytvářet zanořené objekty/pole, pokud neexistují
    lodashSet(draftState, path, value);
}

/**
 * Zkontroluje, zda cesta existuje v herním stavu a hodnota na ní není undefined.
 * Používá Lodash has.
 * @param state Herní stav
 * @param path Cesta k kontrole (např. 'variables.player.health', 'visitedScenes', 'somePluginData.config.value')
 * @returns True pokud cesta existuje a hodnota na ní není undefined.
 */
export function hasStatePath(state: GameState<any>, path: string): boolean {
    // Lodash has kontroluje pouze existenci klíče/indexu na cestě, ne hodnotu != undefined/null
    // Pokud potřebujete zkontrolovat, zda hodnota není undefined/null, použijte getStatePath !== undefined && getStatePath !== null
    return lodashHas(state, path);
}

/**
 * Vytvoří snapshot stavu (hluboká kopie).
 * Umožňuje bezpečně pracovat s kopií stavu, aniž by ovlivňoval aktuální runtime stav.
 * Poznámka: Tato utilita provede hlubokou kopii. Buďte opatrní s velkými nebo složitými stavy.
 * Používá JSON.parse/stringify a ručně zpracovává Set (předpokládá serializovatelný obsah Setu).
 * Pro komplexnější typy (Date, RegExp, Map, třídy) může být nutné použít vlastní rekurzivní klonování nebo specializovanou knihovnu pro deep clone (např. z lodash nebo vlastní implementaci deepClone z utils/object).
 * @param state Herní stav
 * @returns Hluboká kopie stavu.
 */
export function createStateSnapshot<T extends Record<string, unknown>>(state: GameState<T>): GameState<T> {
    // Použijeme JSON.parse/stringify pro hluboké klonování, což je jednoduché pro plain objekty a pole.
    // Je nutné ručně převést Set na Array pro serializaci.
    try {
        const serializableState = {
            ...state,
            // visitedScenes je Set, převedeme na Array pro serializaci
            visitedScenes: Array.from(state.visitedScenes)
        };

        // Stringifikace
        const serialized = JSON.stringify(serializableState);
        // Parsvání
        const parsed = JSON.parse(serialized);

        // Převedeme Array zpět na Set a vrátíme hotový GameState objekt
        return {
            ...parsed,
            visitedScenes: new Set(parsed.visitedScenes) // Convert back to Set
        } as GameState<T>; // Přetypování pro jistotu

    } catch (error) {
        console.error("createStateSnapshot: Failed to create a deep copy of the state.", error);
        // V případě chyby vracíme původní referenci nebo null/undefined?
        // Vrátit původní referenci by porušilo očekávání, že jde o kopii.
        // V závislosti na aplikaci můžete chtít vyhodit chybu.
        throw new Error("Failed to create state snapshot.");
    }
}

/**
 * Porovná dva stavy a vrátí rozdíly.
 * Pomáhá při ladění a sledování změn stavu.
 * Poznámka: Toto porovnání používá JSON.stringify pro hluboké porovnání,
 * což nemusí být vhodné pro všechny datové typy (např. funkce, cirkulární reference) nebo pro velký výkon.
 * Pro robustnější porovnání lze použít dedikovanou deepEqual funkci (např. z lodash nebo vlastní implementaci z utils/object).
 * @param oldState Starý stav
 * @param newState Nový stav
 * @returns Objekt s rozdíly (klíč -> { old: any, new: any }). Zahrnuje rozdíly v visitedScenes (added/removed) a variables.
 */
export function compareStates<T extends Record<string, unknown>>(
    oldState: GameState<T>,
    newState: GameState<T>
): Record<string, any> {
    const differences: Record<string, any> = {};

    // Klíče, které jsou systémové nebo by se neměly přímo porovnávat na první úrovni
    const excludeKeys = ['_metadata'];

    // Kombinace všech klíčů z obou stavů
    const allKeys = new Set([...Object.keys(oldState), ...Object.keys(newState)]);


    for (const key of allKeys) {
        if (!excludeKeys.includes(key)) {
            const oldValue = (oldState as any)[key];
            const newValue = (newState as any)[key];

            // Speciální porovnání pro visitedScenes (Set)
            if (key === 'visitedScenes') {
                const oldScenes = oldValue instanceof Set ? Array.from(oldValue) : [];
                const newScenes = newValue instanceof Set ? Array.from(newValue) : [];

                // Porovnáme sady klíčů
                const addedScenes = newScenes.filter(scene => !((oldValue as Set<string>)?.has(scene)));
                const removedScenes = oldScenes.filter(scene => !((newValue as Set<string>)?.has(scene)));

                if (addedScenes.length > 0 || removedScenes.length > 0) {
                    // Logujeme přidané/odebrané prvky Setu
                    differences[key] = { added: addedScenes, removed: removedScenes };
                } else if (oldValue instanceof Set !== newValue instanceof Set) {
                    // Pokud se změnil typ (např. Set na něco jiného)
                    differences[key] = { old: oldValue, new: newValue };
                }


            } else if (key === 'variables') {
                // Porovnání variables (objekt)
                const oldVars = oldValue || {}; // Treat null/undefined as empty object for comparison
                const newVars = newValue || {};
                const variableKeys = new Set([...Object.keys(oldVars), ...Object.keys(newVars)]);
                const changedVars: Record<string, { old: any; new: any }> = {};

                // Projdeme všechny klíče proměnných a porovnáme jejich hodnoty
                for (const varKey of variableKeys) {
                    const oldVal = oldVars[varKey];
                    const newVal = newVars[varKey];

                    // Hluboké porovnání hodnot proměnných pomocí JSON.stringify
                    // Může být neefektivní nebo nesprávné pro některé typy (funkce, instance tříd).
                    // Zvažte použití deepEqual utility z utils/object, pokud je potřeba robustnější porovnání.
                    if (JSON.stringify(oldVal) !== JSON.stringify(newVal)) {
                        changedVars[varKey] = { old: oldVal, new: newVal };
                    }
                }
                if (Object.keys(changedVars).length > 0) {
                    differences.variables = changedVars;
                }

            } else {
                // Standardní porovnání ostatních vlastností na první úrovni (JSON.stringify)
                // Toto je "hluboké" porovnání hodnot, ne jen referencí.
                if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {
                    differences[key] = { old: oldValue, new: newValue };
                }
            }
        }
    }

    // Můžete přidat logiku pro detekci klíčů, které byly odstraněny v newState
    // Iterace přes oldState klíče a kontrola, zda neexistují v newState
    for (const key in oldState) {
        if (Object.prototype.hasOwnProperty.call(oldState, key) && !excludeKeys.includes(key) && !(key in newState)) {
            // Klíč existoval ve starém stavu, ale neexistuje v novém
            differences[key] = { old: (oldState as any)[key], new: undefined };
        }
    }


    return differences;
}

/**
 * Validuje herní stav a kontroluje základní strukturu a typy klíčových vlastností.
 * @param state Herní stav
 * @returns True pokud je stav validní, jinak False.
 */
export function validateState<T extends Record<string, unknown>>(state: GameState<T>): boolean {
    if (!state || typeof state !== 'object') {
        console.error("Validation failed: State is null, undefined, or not an object.");
        return false;
    }

    // Kontrola základní struktury a typů
    if (!('variables' in state) || typeof state.variables !== 'object' || state.variables === null) {
        console.error("Validation failed: state.variables is missing, not an object, or null.");
        return false;
    }

    if (!('visitedScenes' in state)) {
        console.error("Validation failed: state.visitedScenes is missing.");
        return false;
    }

    // Zajištění, že visitedScenes je Set
    if (!(state.visitedScenes instanceof Set)) {
        // Může se stát po deserializaci, pokud nebyl použit applyPersistentState
        console.warn("Validation warning: state.visitedScenes is not a Set.", state.visitedScenes);
        // Můžeme se pokusit o konverzi nebo to označit jako chybu
        if (Array.isArray(state.visitedScenes)) {
            try {
                state.visitedScenes = new Set(state.visitedScenes);
                console.warn("Validation warning: Successfully converted state.visitedScenes from Array to Set.");
            } catch (e) {
                console.error("Validation failed: Error converting state.visitedScenes from Array to Set.", e);
                return false;
            }
        } else {
            console.error("Validation failed: state.visitedScenes is neither a Set nor an Array.");
            return false;
        }
    }

    // Další vlastní validační logiku můžete přidat zde
    // Např. kontrola existence a typu specifických pluginových dat
    // if ('myPluginData' in state && (typeof state.myPluginData !== 'object' || state.myPluginData === null)) {
    //      console.error("Validation failed: state.myPluginData is not an object.");
    //      return false;
    // }


    return true;
}
</file>

<file path="src/utils/immer.ts">
/**
 * Reexport funkcionality z immer pro použití v aplikaci
 * Centralizuje konfiguraci a poskytuje konzistentní API
 */
import { enableMapSet, enablePatches } from 'immer';

// Aktivace podpory pro Map a Set v immer
enableMapSet();

// Aktivace podpory pro patches (příplaty)
enablePatches();

// Reexport hlavních funkcí
export { produce, current, createDraft, finishDraft } from 'immer';
</file>

<file path="src/utils/index.ts">
// Reexport utilit pro immer
export * from './immer';

// Reexport utilit pro UUID
export * from './uuid';

// Reexport utilit pro práci s objekty
export * from './object';

// Reexport utilities pro vytvoření enginu
export * from '../engine/utils';

// Reexport utility pro SaveManager
export * from '../save/utils';
</file>

<file path="src/utils/object.ts">
/**
 * Hluboká kopie objektu
 *
 * @param obj Objekt ke kopírování
 * @returns Hluboká kopie objektu
 */
export function deepClone<T>(obj: T): T {
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }

    // Převede Set na Array pro klonování a zpět
    if (obj instanceof Set) {
        return new Set(Array.from(obj).map(item => deepClone(item))) as any;
    }

    // Převede Map na Array pro klonování a zpět
    if (obj instanceof Map) {
        return new Map(
            Array.from(obj.entries()).map(([key, value]) => [
                deepClone(key),
                deepClone(value)
            ])
        ) as any;
    }

    // Zpracování Date
    if (obj instanceof Date) {
        return new Date(obj.getTime()) as any;
    }

    // Zpracování RegExp
    if (obj instanceof RegExp) {
        return new RegExp(obj.source, obj.flags) as any;
    }

    // Zpracování Array
    if (Array.isArray(obj)) {
        return obj.map(item => deepClone(item)) as any;
    }

    // Zpracování obyčejného Object
    const clonedObj = {} as T;
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            clonedObj[key] = deepClone(obj[key]);
        }
    }

    return clonedObj;
}

/**
 * Hluboké porovnání dvou objektů
 *
 * @param obj1 První objekt
 * @param obj2 Druhý objekt
 * @returns True pokud jsou objekty hluboce rovny
 */
export function deepEqual(obj1: any, obj2: any): boolean {
    // Kontrola primitivních typů a null/undefined
    if (obj1 === obj2) {
        return true;
    }

    // Kontrola, že oba objekty jsou objekty
    if (typeof obj1 !== 'object' || obj1 === null ||
        typeof obj2 !== 'object' || obj2 === null) {
        return false;
    }

    // Speciální ošetření pro Date
    if (obj1 instanceof Date && obj2 instanceof Date) {
        return obj1.getTime() === obj2.getTime();
    }

    // Speciální ošetření pro RegExp
    if (obj1 instanceof RegExp && obj2 instanceof RegExp) {
        return obj1.toString() === obj2.toString();
    }

    // Speciální ošetření pro Set
    if (obj1 instanceof Set && obj2 instanceof Set) {
        if (obj1.size !== obj2.size) return false;
        for (const item of obj1) {
            let found = false;
            for (const item2 of obj2) {
                if (deepEqual(item, item2)) {
                    found = true;
                    break;
                }
            }
            if (!found) return false;
        }
        return true;
    }

    // Speciální ošetření pro Map
    if (obj1 instanceof Map && obj2 instanceof Map) {
        if (obj1.size !== obj2.size) return false;
        for (const [key, val1] of obj1.entries()) {
            let found = false;
            for (const [key2, val2] of obj2.entries()) {
                if (deepEqual(key, key2) && deepEqual(val1, val2)) {
                    found = true;
                    break;
                }
            }
            if (!found) return false;
        }
        return true;
    }

    // Kontrola, že mají stejný konstruktor (jsou stejného typu)
    if (obj1.constructor !== obj2.constructor) {
        return false;
    }

    // Pro pole kontrolujeme délku a každý prvek
    if (Array.isArray(obj1)) {
        if (obj1.length !== obj2.length) {
            return false;
        }
        for (let i = 0; i < obj1.length; i++) {
            if (!deepEqual(obj1[i], obj2[i])) {
                return false;
            }
        }
        return true;
    }

    // Pro objekty kontrolujeme klíče a hodnoty
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);

    if (keys1.length !== keys2.length) {
        return false;
    }

    for (const key of keys1) {
        if (!Object.prototype.hasOwnProperty.call(obj2, key)) {
            return false;
        }
        if (!deepEqual(obj1[key], obj2[key])) {
            return false;
        }
    }

    return true;
}

/**
 * Bezpečné získání hodnoty z objektu pomocí cesty (dot notation)
 *
 * @param obj Objekt
 * @param path Cesta k vlastnosti (např. 'user.address.street')
 * @param defaultValue Výchozí hodnota, pokud vlastnost neexistuje
 * @returns Hodnota vlastnosti nebo defaultValue
 */
export function getPath<T = any>(obj: any, path: string, defaultValue?: T): T | undefined {
    if (!obj || !path) return defaultValue;

    const keys = path.split('.');
    let result = obj;

    for (const key of keys) {
        if (result === null || result === undefined || typeof result !== 'object') {
            return defaultValue;
        }
        result = result[key];
    }

    return (result === undefined) ? defaultValue : result as T;
}

/**
 * Bezpečné nastavení hodnoty v objektu pomocí cesty (dot notation)
 *
 * @param obj Objekt
 * @param path Cesta k vlastnosti (např. 'user.address.street')
 * @param value Hodnota k nastavení
 * @returns Modifikovaný objekt
 */
export function setPath<T>(obj: T, path: string, value: any): T {
    if (!obj || !path) return obj;

    const keys = path.split('.');
    let current: any = obj;

    for (let i = 0; i < keys.length - 1; i++) {
        const key = keys[i];

        // Vytvoříme nové zanořené objekty, pokud neexistují
        if (current[key] === undefined || current[key] === null || typeof current[key] !== 'object') {
            current[key] = {};
        }

        current = current[key];
    }

    // Nastavíme hodnotu na poslední úrovni
    const lastKey = keys[keys.length - 1];
    current[lastKey] = value;

    return obj;
}
</file>

<file path="src/utils/uuid.ts">
/**
 * Generuje jedinečný identifikátor (UUID v4)
 *
 * @returns Jedinečný identifikátor
 */
export function generateUUID(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
        const r = (Math.random() * 16) | 0;
        const v = c === 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
}

/**
 * Generuje krátký identifikátor (8 znaků)
 *
 * @param prefix Volitelný prefix pro ID
 * @returns Krátký jedinečný identifikátor
 */
export function generateShortId(prefix?: string): string {
    const randomPart = Math.random().toString(36).substring(2, 8);
    return prefix ? `${prefix}_${randomPart}` : randomPart;
}

/**
 * Kontroluje, zda řetězec je validní UUID
 *
 * @param id Řetězec k kontrole
 * @returns True pokud je validní UUID
 */
export function isValidUUID(id: string): boolean {
    const pattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    return pattern.test(id);
}
</file>

<file path="src/index.ts">
export * from './event';

export { GameEngine, createGameEngine } from './engine';
export { GameEngineOptions, GameEngineEvents } from './engine/types';

export * from './scene';
export * from './state';
export * from './content';
export * from './effect';
export * from './plugin';
export * from './save';
export * from './utils';
</file>

<file path=".prettierignore">
node_modules
dist
coverage
*.md
*.json
</file>

<file path=".prettierrc.js">
module.exports = {
  singleQuote: true,
  trailingComma: 'es5',
  printWidth: 100,
  tabWidth: 2,
  semi: true,
  bracketSpacing: true,
  arrowParens: 'avoid',
  endOfLine: 'lf',
};
</file>

<file path="eslint.config.mjs">
// eslint.config.mjs
import eslintJs from '@eslint/js';
import tseslint from '@typescript-eslint/eslint-plugin';
import tsparser from '@typescript-eslint/parser';
import prettierPlugin from 'eslint-plugin-prettier';

export default [
  eslintJs.configs.recommended,
  {
    ignores: [
      'node_modules/**',
      'dist/**',
      'coverage/**',
      'rollup.config.js',
      'jest.config.js'
    ]
  },
  {
    files: ['**/*.ts'],
    languageOptions: {
      parser: tsparser,
      ecmaVersion: 2020,
      sourceType: 'module',
      globals: {
        // Přidáno pro vyřešení 'console is not defined'
        console: 'readonly',
        // Další globální proměnné, které mohou být potřeba
        process: 'readonly',
        setTimeout: 'readonly',
        clearTimeout: 'readonly',
        Set: 'readonly',
        Map: 'readonly',
        Promise: 'readonly'
      }
    },
    plugins: {
      '@typescript-eslint': tseslint,
      'prettier': prettierPlugin
    },
    rules: {
      'prettier/prettier': 'error',
      'no-console': ['warn', { allow: ['warn', 'error'] }],
      'no-unused-vars': 'off'
    }
  }
];
</file>

<file path="jest.config.js">
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ['**/test/**/*.test.ts'],
  collectCoverage: true,
  coverageDirectory: 'coverage',
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.d.ts',
    '!src/**/index.ts',
    '!src/types/**/*.ts'
  ],
  transform: {
    '^.+\\.tsx?$': [
      'ts-jest',
      {
        tsconfig: 'tsconfig.json',
      },
    ],
  },
};
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Jakub Hájek

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="package.json">
{
  "name": "@pabitel/core",
  "version": "0.1.0",
  "description": "A minimalist framework for building text-based games and interactive narratives",
  "license": "MIT",
  "main": "dist/index.js",
  "module": "dist/index.esm.js",
  "types": "dist/index.d.ts",
  "files": [
    "dist"
  ],
  "exports": {
    ".": {
      "import": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.esm.js"
      },
      "require": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.js"
      },
      "development": "./src/index.ts"
    },
    "./package.json": "./package.json"
  },
  "scripts": {
    "build": "tsc && rollup -c",
    "dev": "tsc --watch",
    "test": "jest",
    "lint": "eslint src --ext .ts",
    "lint:fix": "eslint src --ext .ts --fix",
    "format": "prettier --write \"src/**/*.ts\"",
    "format:check": "prettier --check \"src/**/*.ts\"",
    "prepublishOnly": "npm run lint && npm run test && npm run build"
  },
  "devDependencies": {
    "@eslint/js": "^9.23.0",
    "@rollup/plugin-commonjs": "^28.0.3",
    "@rollup/plugin-node-resolve": "^16.0.1",
    "@types/jest": "^29.5.14",
    "@types/lodash": "^4.17.16",
    "@types/uuid": "^10.0.0",
    "@typescript-eslint/eslint-plugin": "^8.29.0",
    "@typescript-eslint/parser": "^8.29.0",
    "eslint": "^9",
    "eslint-config-prettier": "^10",
    "eslint-plugin-prettier": "^5",
    "jest": "^29.7.0",
    "prettier": "^3",
    "rollup": "^4",
    "rollup-plugin-typescript2": "^0.36.0",
    "ts-jest": "^29.3.1",
    "typescript": "^5.8.2"
  },
  "author": "Jakub Hájek",
  "repository": {
    "type": "git",
    "url": "https://github.com/jimmyhayek/textgame.git"
  },
  "keywords": [
    "text-game",
    "interactive-fiction",
    "game-engine",
    "narrative",
    "text-adventure"
  ],
  "dependencies": {
    "immer": "^10.1.1",
    "lodash": "^4.17.21",
    "uuid": "^11.1.0"
  }
}
</file>

<file path="rollup.config.js">
import typescript from 'rollup-plugin-typescript2';
import { nodeResolve } from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import pkg from './package.json';

export default [
  {
    input: 'src/index.ts',
    output: {
      file: pkg.module,
      format: 'esm',
      sourcemap: true
    },
    plugins: [
      typescript({
        tsconfig: './tsconfig.json',
        useTsconfigDeclarationDir: true
      }),
      nodeResolve(),
      commonjs()
    ],
    external: [...Object.keys(pkg.dependencies || {}), ...Object.keys(pkg.peerDependencies || {})]
  },
  {
    input: 'src/index.ts',
    output: {
      file: pkg.main,
      format: 'cjs',
      sourcemap: true
    },
    plugins: [
      typescript({
        tsconfig: './tsconfig.json',
        useTsconfigDeclarationDir: true
      }),
      nodeResolve(),
      commonjs()
    ],
    external: [...Object.keys(pkg.dependencies || {}), ...Object.keys(pkg.peerDependencies || {})]
  }
];
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "declaration": true,
    "declarationDir": "./dist",
    "outDir": "./dist",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "test", "examples"]
}
</file>

</files>
